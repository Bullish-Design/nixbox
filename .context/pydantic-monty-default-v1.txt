Repo: https://github.com/pydantic/monty
Ref: (default)
Generated: 2026-02-13T14:04:52.846Z

Directory Structure:

./
├── crates
│   ├── monty-python
│   │   ├── python
│   │   │   └── pydantic_monty
│   │   │       ├── __init__.py
│   │   │       └── os_access.py
│   │   ├── tests
│   │   │   ├── test_async.py
│   │   │   ├── test_basic.py
│   │   │   ├── test_dataclasses.py
│   │   │   ├── test_exceptions.py
│   │   │   ├── test_external.py
│   │   │   ├── test_inputs.py
│   │   │   ├── test_limits.py
│   │   │   ├── test_os_access_compat.py
│   │   │   ├── test_os_access_raw.py
│   │   │   ├── test_os_access.py
│   │   │   ├── test_os_calls.py
│   │   │   ├── test_print.py
│   │   │   ├── test_readme_examples.py
│   │   │   ├── test_serialize.py
│   │   │   ├── test_start.py
│   │   │   ├── test_threading.py
│   │   │   ├── test_type_check.py
│   │   │   └── test_types.py
│   │   ├── example.py
│   │   ├── exercise.py
│   │   ├── pyproject.toml
│   │   └── README.md
│   ├── monty-type-checking
│   │   ├── src
│   │   │   └── type_check.rs
│   │   └── tests
│   │       ├── bad_types_output.txt
│   │       ├── bad_types.py
│   │       ├── good_types.py
│   │       ├── main.rs
│   │       ├── reveal_types_output.txt
│   │       └── reveal_types.py
│   └── monty-typeshed
│       ├── README.md
│       └── update.py
├── examples
│   ├── expense_analysis
│   │   ├── data.py
│   │   ├── main.py
│   │   └── README.md
│   ├── sql_playground
│   │   ├── external_functions.py
│   │   ├── main.py
│   │   ├── README.md
│   │   ├── sandbox_code.py
│   │   └── type_stubs.pyi
│   └── README.md
├── scripts
│   ├── check_imports.py
│   ├── codecov_diff.py
│   ├── complete_tests.py
│   ├── flamegraph_to_text.py
│   ├── iter_test_methods.py
│   ├── run_traceback.py
│   └── startup_performance.py
├── CLAUDE.md
└── README.md




------------------------------------------
File: CLAUDE.md
------------------------------------------

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Monty is a sandboxed Python interpreter written in Rust. It parses Python code using Ruff's `ruff_python_parser` but implements its own runtime execution model for safety and performance. This is a work-in-progress project that currently supports a subset of Python features.

Project goals:

- **Safety**: Execute untrusted Python code safely without FFI or C dependencies, instead sandbox will call back to host to run foreign/external functions.
- **Performance**: Fast execution through compile-time optimizations and efficient memory layout
- **Simplicity**: Clean, understandable implementation focused on a Python subset
- **Snapshotting and iteration**: Plan is to allow code to be iteratively executed and snapshotted at each function call
- Targets the latest stable version of Python, currently Python 3.14

## Important Security Notice

It's ABSOLUTELY CRITICAL that there's no way for code run in a Monty sandbox to access the host filesystem, or environment or to in any way "escape the sandbox".

**Monty will be used to run untrusted, potentially malicious code.**

Make sure there's no risk of this, either in the implementation, or in the public API that makes it more like that a developer using the pydantic_monty package might make such a mistake.

Possible security risks to consider:
* filesystem access
* path traversal to access files the users did not intend to expose to the monty sandbox
* memory errors - use of unsafe memory operations
* excessive memory usage - evading monty's resource limits
* infinite loops - evading monty's resource limits
* network access - sockets, HTTP requests
* subprocess/shell execution - os.system, subprocess, etc.
* import system abuse - importing modules with side effects or accessing `__import__`
* external function/callback misuse - callbacks run in host environment
* deserialization attacks - loading untrusted serialized Monty/snapshot data
* regex/string DoS - catastrophic backtracking or operations bypassing limits
* information leakage via timing or error messages
* Python/Javascript/Rust APIs that accidentally allow developers to expose their host to monty code

## Bytecode VM Architecture

Monty is implemented as a bytecode VM, same as CPython.

### Reference Count Safety

All types that implement `DropWithHeap` hold heap references and **must** be cleaned up correctly on every code path — not just the happy path, but also early returns via `?`, `continue`, conditional branches, etc. A missed `drop_with_heap` on any branch leaks reference counts. There are three mechanisms for ensuring this, listed in order of preference:

#### 1. `defer_drop!` macro (preferred)

The simplest and safest approach. Use `defer_drop!` (or `defer_drop_mut!` when mutable access to the value is needed) to bind a value into a guard that automatically drops it when scope exits — whether that's normal completion, early return via `?`, `continue`, or any other branch. The macro rebinds the value and heap variables as borrows from the guard, so you keep using them by name as before:

```rust
let value = self.pop();
defer_drop!(value, heap);          // value is now &Value, heap is now &mut Heap
let result = value.py_repr(heap)?; // guard handles cleanup on all paths
```

Beyond safety, `defer_drop!` is often much more concise than inserting `drop_with_heap` calls in every branch of complex control flow.

`defer_drop!` gives you an immutable reference to the value. Use `defer_drop_mut!` when you need a mutable reference (e.g. iterators, values you may swap):

```rust
let iter = heap.get_iter(iter_ref);
defer_drop_mut!(iter, heap);
while let Some(item) = iter.for_next(heap)? { ... }
```

**Limitation:** because the macro rebinds the heap, it cannot be used inside `&mut self` methods where `self` owns the heap — first assign `let this = self;` and pass `this` instead.

#### 2. `HeapGuard` (when you need control over the value's fate)

Use `HeapGuard` directly when `defer_drop!` is too restrictive — specifically when you need to conditionally extract the value instead of dropping it. `HeapGuard` provides `into_inner()` and `into_parts()` to reclaim ownership, while its `Drop` impl still guarantees cleanup on all other paths:

```rust
// HeapGuard needed here because on success we push lhs back onto the stack
// instead of dropping it
let mut lhs_guard = HeapGuard::new(self.pop(), self);
let (lhs, this) = lhs_guard.as_parts_mut();

if lhs.py_iadd(rhs, this.heap)? {
    let (lhs, this) = lhs_guard.into_parts(); // reclaim lhs, don't drop
    this.push(lhs);
    return Ok(());
}
// otherwise lhs_guard drops lhs automatically at scope exit
```

#### 3. Manual `drop_with_heap` (for trivially simple cases)

For very simple cases with a single linear code path and no branching between acquiring and releasing the value, a direct `drop_with_heap` call is fine:

```rust
let iter = self.pop();
iter.drop_with_heap(&mut self.heap); // single path, no branching
```

Avoid manual `drop_with_heap` whenever there are multiple code paths (branching, `?`, `continue`, early returns) between acquiring and releasing the value — that is exactly where `defer_drop!` or `HeapGuard` prevent leaks by guaranteeing cleanup on every path.

## Dev Commands

DO NOT run `cargo build` or `cargo run`, it will fail because of issues with Python bindings.

Instead use the following `make` commands:

```bash
make install-py           Install python dependencies
make install-js           Install JS package dependencies
make install              Install the package, dependencies, and pre-commit for local development
make dev-py               Install the python package for development
make dev-js               Build the JS package (debug)
make lint-js              Lint JS code with oxlint
make test-js              Build and test the JS package
make dev-py-release       Install the python package for development with a release build
make dev-js-release       Build the JS package (release)
make dev-py-pgo           Install the python package for development with profile-guided optimization
make format-rs            Format Rust code with fmt
make format-py            Format Python code - WARNING be careful about this command as it may modify code and break tests silently!
make format-js            Format JS code with prettier
make format               Format Rust code, this does not format Python code as we have to be careful with that
make lint-rs              Lint Rust code with clippy and import checks
make clippy-fix           Fix Rust code with clippy
make lint-py              Lint Python code with ruff
make lint                 Lint the code with ruff and clippy
make format-lint-rs       Format and lint Rust code with fmt and clippy
make format-lint-py       Format and lint Python code with ruff
make test-no-features     Run rust tests without any features enabled
make test-ref-count-panic Run rust tests with ref-count-panic enabled
make test-ref-count-return Run rust tests with ref-count-return enabled
make test-cases           Run tests cases only
make test-type-checking   Run rust tests on monty_type_checking
make pytest               Run Python tests with pytest
make test-py              Build the python package (debug profile) and run tests
make test-docs            Test docs examples only
make test                 Run rust tests
make testcov              Run Rust tests with coverage, print table, and generate HTML report
make complete-tests       Fill in incomplete test expectations using CPython
make update-typeshed      Update vendored typeshed from upstream
make bench                Run benchmarks
make dev-bench            Run benchmarks to test with dev profile
make profile              Profile the code with pprof and generate flamegraphs
make type-sizes           Write type sizes for the crate to ./type-sizes.txt (requires nightly and top-type-sizes)
make main                 run linting and the most important tests
make help                 Show this help (usage: make help)
```

Use the /python-playground skill to check cpython and monty behavior.

## Releasing

See [RELEASING.md](RELEASING.md) for the release process.

## Exception

It's important that exceptions raised/returned by this library match those raised by Python.

Wherever you see an Exception with a repeated message, create a dedicated method to create that exception `src/exceptions.rs`.

When writing exception messages, always check `src/exceptions.rs` for existing methods to generate that message.

## Code style

Avoid local imports, unless there's a very good reason, all imports should be at the top of the file.

Avoid `fn my_func<T: MyTrait>(..., param: T)` style function definitions, STRONGLY prefer `fn my_func(param: impl MyTrait)` syntax since changes are more localized. This includes in trait definitions and implementations.

Also avoid using functions and structs via a path like `std::borrow::Cow::Owned(...)`, instead import `Cow` globally with `use std::borrow::Cow;`.

NEVER use `allow()` in rust lint markers, instead use `expect()` so any unnecessary markers are removed. E.g. use

```rs
#[expect(clippy::too_many_arguments)]
```

NOT!

```rs
#[allow(clippy::too_many_arguments)]
```

### Docstrings and comments.

IMPORTANT: every struct, enum and function should be a comprehensive but concise docstring to
explain what it does and why and any considerations or potential foot-guns of using that type.

The only exception is trait implementation methods where a docstring is not necessary if the method is self-explanatory.

It's important that docstrings cover the motivation and primary usage patterns of code, not just the simple "what it does".

Similarly, you should add comments to code, especially if the code is complex or esoteric.

Only add examples to docstrings of public functions and structs, examples should be <=8 lines, if the example is more, remove it.

If you add example code to docstrings, it must be run in tests. NEVER add examples that are ignored.

If you encounter a comment or docstring that's out of date - you MUST update it to be correct.

Similarly, if you encounter code that has no docstrings or comments, or they are minimal, you should add more detail.

NOTE: COMMENTS AND DOCSTRINGS ARE EXTREMELY IMPORTANT TO THE LONG TERM HEALTH OF THE PROJECT.

## Tests

Do **NOT** write tests within modules unless explicitly prompted to do so.

Tests should live in the relevant `tests/` directory.

Commands:

```bash
# Build the project
cargo build

# Run tests (this is the best way to run all tests as it enables the ref-count-panic feature)
make test-ref-count-panic

# Run crates/monty/test_cases tests only
make test-cases

# Run a specific test
cargo test -p monty --test datatest_runner --features ref-count-panic str__ops

# Run the interpreter on a Python file
cargo run -- <file.py>
```

See more test commands above.

### Experimentation and Playground

Read `Makefile` for other useful commands.

DO NOT run `cargo run --`, it will fail because of issues with Python bindings.

You can use the `./playground` directory (excluded from git, create with `mkdir -p playground`) to write files
when you want to experiment by running a file with cpython or monty, e.g.:
* `python3 playground/test.py` to run the file with cpython
* `cargo run -- playground/test.py` to run the file with monty

DO NOT use `/tmp` or pipe code to the interpreter as it requires extra permissions and can slow you down!

More details in the "python-playground" skill.

### Test File Structure

Most functionality should be tested via python files in the `crates/monty/test_cases` directory.

**DO NOT create many small test files.** This would be unmaintainable.

ALWAYS consolidate related tests into single files using multiple `assert` statements. Follow `crates/monty/test_cases/fstring__all.py` as the gold standard pattern:

```python
# === Section name ===
# brief comment if needed
assert condition, 'descriptive message'
assert another_condition, 'another descriptive message'

# === Next section ===
x = setup_value
assert x == expected, 'test description'
```

Each `assert` should have a descriptive message.

Do NOT Write tests like `assert 'thing' in msg` it's lazy and inexact unless explicitly told to do so, instead write tests like `assert msg == 'expected message'` to ensure clarity and accuracy and most importantly, to identify differences between Monty and CPython.

### When to Create Separate Test Files

Only create a separate test file when you MUST use one of these special expectation formats:

- `"""TRACEBACK:..."""` - Test expects an exception with full traceback (PREFERRED for error tests)
- `# Raise=Exception('message')` - Test expects an exception without traceback verification - NOT RECOMMENDED, use `TRACEBACK` instead
- `# ref-counts={...}` - Test checks reference counts (special mode)
- you're writing tests for a different behavior or section of the language

For everything else, **add asserts to an existing test file** or create ONE consolidated file for the feature.

### File Naming

Name files by feature, not by micro-variant:
- ✅ `str__ops.py` - all string operations (add, iadd, len, etc.)
- ✅ `list__methods.py` - all list method tests
- ❌ `str__add_basic.py`, `str__add_empty.py`, `str__add_multiple.py` - TOO GRANULAR

### Expectation Formats (use sparingly)

Only use these when `assert` won't work (on last line of file):
- `# Return=value` - Check `repr()` output (prefer assert instead)
- `# Return.str=value` - Check `str()` output (prefer assert instead)
- `# Return.type=typename` - Check `type()` output (prefer assert instead)
- `# Raise=Exception('message')` - Expect exception without traceback (REQUIRES separate file)
- `"""TRACEBACK:..."""` - Expect exception with full traceback (PREFERRED over `# Raise=`)
- `# ref-counts={...}` - Check reference counts (REQUIRES separate file)
- No expectation comment - Assert-based test (PREFERRED)

Do NOT use `# Return=` when you could use `assert` instead

### Traceback Tests (Preferred for Errors)

For tests that expect exceptions, **prefer traceback tests over `# Raise=`** because they verify:
- The full traceback with all stack frames
- Correct line numbers for each frame
- Function names in the traceback
- The caret markers (`~`) pointing to the error location

Traceback test format - add a triple-quoted string at the end of the file starting with `\nTRACEBACK:`:
```python
def foo():
    raise ValueError('oops')

foo()
"""
TRACEBACK:
Traceback (most recent call last):
  File "my_test.py", line 4, in <module>
    foo()
    ~~~~~
  File "my_test.py", line 2, in foo
    raise ValueError('oops')
ValueError: oops
"""
```

Key points:
- The filename in the traceback should match the test file name (just the basename, not the full path)
- Use `~` for caret markers (the test runner normalizes CPython's `^` to `~`)
- The `<module>` frame name is used for top-level code
- Tests run against both Monty and CPython, so the traceback must match both

Only use `# Raise=` when you only care about the exception type/message and not the traceback.

### Python fixture markers

You may mark python files with:
* `# call-external` to support calling external functions
* `# run-async` to support running async code

NEVER MARK TESTS AS XFAIL UNDER ANY CIRCUMSTANCES!!! INSTEAD FIX THE BEHAVIOR SO THAT THE TEST PASSES.

Never mark tests as:
- `# xfail=cpython` - Test is required to fail on CPython
- `# xfail=monty` - Test is required to fail on Monty

NEVER MARK TESTS AS XFAIL UNDER ANY CIRCUMSTANCES!!! INSTEAD FIX THE BEHAVIOR SO THAT THE TEST PASSES.

All these markers must be at the start of comment lines to be recognized.

### Other Notes

- Prefer single quotes for strings in Python tests
- Do NOT add `# noqa` or  `# pyright: ignore` comments to test code, instead add the failing code to `pyproject.toml`
- The ONLY exception is `await` expressions outside of async functions, where you should add `# pyright: ignore`
- Run `make lint-py` after adding tests
- Use `make complete-tests` to fill in blank expectations
- Tests run via `datatest-stable` harness in `tests/datatest_runner.rs`, use `make test-cases` to run them

## Python Package (`pydantic-monty`)

The Python package provides Python bindings for the Monty interpreter, located in `crates/monty-python/`.

### Structure

- `crates/monty-python/src/` - Rust source for PyO3 bindings
- `crates/monty-python/python/pydantic_monty/_monty.pyi` - Type stubs for the Python module
- `crates/monty-python/tests/` - Python tests using pytest

### Building and Testing

Dependencies needed for python testing are installed in `crates/monty-python/pyproject.toml`.
To install these dependencies, use `uv sync --all-packages --only-dev`.

```bash
# Build the Python package for development (required before running tests)
make dev-py

# Run Python tests
make test-py

# Or run pytest directly (after dev-py)
uv run pytest

# Run a specific test file
uv run pytest crates/monty-python/tests/test_basic.py

# Run a specific test
uv run pytest crates/monty-python/tests/test_basic.py::test_simple_expression
```

### Python Test Guidelines

Check and follow the style of other python tests.

Make sure you put tests in the correct file.

**DO NOT use python/pytest tests for `monty` core functionality!** When testing core functionality, add tests to `crates/monty/test_cases/` or `crates/monty/tests/`. Only use python/pytest tests for `pydantic_monty` functionality testing.

**NEVER use class-based tests.** All tests should be simple functions.

Use `@pytest.mark.parametrize` whenever testing multiple similar cases.

Use `snapshot` from `inline-snapshot` for all test asserts.

NEVER do the lazy `assert '...' in ...` instead always do `assert value == snapshot()`,
then run the test and inline-snapshot will fill in the missing value in the `snapshot()` call.

Use `pytest.raises` for expected exceptions, like this

```py
with pytest.raises(ValueError) as exc_info:
    m.run(print_callback=callback)
assert exc_info.value.args[0] == snapshot('stopped at 3')
```

## Reference Counting

Heap-allocated values (`Value::Ref`) use manual reference counting. Key rules:

- **Cloning**: Use `clone_with_heap(heap)` which increments refcounts for `Ref` variants.
- **Dropping**: Call `drop_with_heap(heap)` when discarding an `Value` that may be a `Ref`.
- **Borrow conflicts**: When you need to read from the heap and then mutate it, use `copy_for_extend()` to copy the `Value` without incrementing refcount, then call `heap.inc_ref()` separately after the borrow ends.

Container types (`List`, `Tuple`, `Dict`) also have `clone_with_heap()` methods.

**Resource limits**: When resource limits (allocations, memory, time) are exceeded, execution terminates with a `ResourceError`. No guarantees are made about the state of the heap or reference counts after a resource limit is exceeded. The heap may contain orphaned objects with incorrect refcounts. This is acceptable because resource exhaustion is a terminal error - the execution context should be discarded.

## NOTES

ALWAYS consider code quality when adding new code, if functions are getting too complex or code is duplicated, move relevant logic to a new file.
Make sure functions are added in the most logical place, e.g. as methods on a struct where appropriate.

The code should follow the "newspaper" style where public and primary functions are at the top of the file, followed by private functions and utilities.
ALWAYS put utility, private functions and "sub functions" underneath the function they're used in.

It is important to the long term health of the project and maintainability of the codebase that code is well structured and organized, this is very important.

ALWAYS run `make format-rs` and `make lint-rs` after making changes to rust code and fix all suggestions to maintain code quality.

ALWAYS run `make lint-py` after making changes to python code and fix all suggestions to maintain code quality.

ALWAYS update this file when it is out of date.

NEVER add imports anywhere except at the top of the file, this applies to both python and rust.

NEVER write `unsafe` code, if you think you need to write unsafe code, explicitly ask the user or leave a `todo!()` with a suggestion and explanation.

## JavaScript Package (`monty-js`)

The JavaScript package provides Node.js bindings for the Monty interpreter via napi-rs, located in `crates/monty-js/`.

### Structure

- `crates/monty-js/src/lib.rs` - Rust source for napi-rs bindings
- `crates/monty-js/index.js` - Auto-generated JS loader that detects platform and loads the appropriate native binding
- `crates/monty-js/index.d.ts` - TypeScript type declarations (auto-generated)
- `crates/monty-js/__test__/` - Tests using ava

### Current API

The package exposes:

- `Monty` class - Parse and execute Python code with inputs, external functions, and resource limits
- `MontySnapshot` / `MontyComplete` - For iterative execution with `start()` / `resume()`
- `runMontyAsync()` - Helper for async external functions
- `MontySyntaxError` / `MontyRuntimeError` / `MontyTypingError` - Error classes

```ts
import { Monty, MontySnapshot, runMontyAsync } from '@pydantic/monty'

// Basic execution
const m = new Monty('x + 1', { inputs: ['x'] })
const result = m.run({ inputs: { x: 10 } }) // returns 11

// Iterative execution for external functions
const m2 = new Monty('fetch(url)', { inputs: ['url'], externalFunctions: ['fetch'] })
let progress = m2.start({ inputs: { url: 'https://...' } })
if (progress instanceof MontySnapshot) {
  progress = progress.resume({ returnValue: 'response data' })
}
```

See `crates/monty-js/README.md` for full API documentation.

### Building and Testing

```bash
# Install dependencies
make install-js

# Build native binding (debug)
make build-js

# Build native binding (release)
make build-js-release

# Run tests
make test-js

# Format JavaScript code
make format-js

# Lint JavaScript code
make lint-js
```

Or run directly in `crates/monty-js`:

```bash
npm install
npm run build        # release build
npm run build:debug  # debug build
npm test
```

### JavaScript Test Guidelines

- Tests use [ava](https://github.com/avajs/ava) and live in `crates/monty-js/__test__/`
- Tests are written in TypeScript
- Follow the existing test style in the `__test__/` directory




------------------------------------------
File: crates/monty-python/example.py
------------------------------------------

"""Example usage of the Monty Python bindings."""

import pydantic_monty

# Basic execution - simple expression
m = pydantic_monty.Monty('1 + 2 * 3')
print(f'Basic: {m.run()!r}')  # 7

# Using input variables
m = pydantic_monty.Monty('x + y', inputs=['x', 'y'])
print(f'Inputs: {m.run(inputs={"x": 10, "y": 20})}')  # 30

# Reusing the same parsed code with different values
print(f'Reuse: {m.run(inputs={"x": 100, "y": 200})}')  # 300

# With resource limits
limits = pydantic_monty.ResourceLimits(max_duration_secs=5.0, max_memory=1024 * 1024)
m = pydantic_monty.Monty('x * y * z', inputs=['x', 'y', 'z'])
print(f'With limits: {m.run(inputs={"x": 2, "y": 3, "z": 4}, limits=limits)}')  # 24

# External function callbacks
m = pydantic_monty.Monty('fetch("https://example.com")', external_functions=['fetch'])


def fetch(url: str) -> str:
    return f'Fetched: {url}'


print(f'External: {m.run(external_functions={"fetch": fetch})}')

# Print output is forwarded to Python stdout
m = pydantic_monty.Monty('print("Hello from Monty!")')
m.run()

# Exception handling
m = pydantic_monty.Monty('1 / 0')
try:
    m.run()
except ZeroDivisionError as e:
    print(f'Caught: {type(e).__name__}')




------------------------------------------
File: crates/monty-python/exercise.py
------------------------------------------

"""
Exercise script for PGO data collection.

Runs all test cases through Monty with type checking enabled,
exercising the full interpreter pipeline for profiling.
"""

import time
from pathlib import Path

import pydantic_monty


def main():
    test_cases = Path(__file__).parent.parent / 'monty' / 'test_cases'
    run, run_success, type_errors = 0, 0, 0
    start = time.perf_counter()

    for py_file in test_cases.glob('*.py'):
        code = py_file.read_text(encoding='utf-8')

        # Exercise parsing and type checking
        try:
            try:
                m = pydantic_monty.Monty(code, type_check=True)
            except pydantic_monty.MontyTypingError:
                # Many test cases have type errors
                m = pydantic_monty.Monty(code)
                type_errors += 1

            # Exercise execution
            run += 1
            m.run(print_callback=lambda _, __: None)
            run_success += 1
        except pydantic_monty.MontyError:
            # ignore syntax errors or errors while running the code
            pass
        except Exception as e:
            raise RuntimeError(f'Error running {py_file.name}: {e}') from e

    t = time.perf_counter() - start
    print(f'Executed {run} test cases in {t:.2f} seconds, {run_success} succeeded, {type_errors} had type errors')


if __name__ == '__main__':
    main()




------------------------------------------
File: crates/monty-python/pyproject.toml
------------------------------------------

[build-system]
requires = ["maturin>=1.9.4,<2.0"]
build-backend = "maturin"

[project]
# the module is named `pydantic_monty`
name = "pydantic-monty"
description = "Python bindings for the Monty sandboxed Python interpreter"
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
    "Development Status :: 3 - Alpha",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3 :: Only",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: 3.14",
    "Intended Audience :: Developers",
    "Intended Audience :: Information Technology",
    "Intended Audience :: System Administrators",
    "License :: OSI Approved :: MIT License",
    "Operating System :: Unix",
    "Operating System :: POSIX :: Linux",
    "Environment :: MacOS X",
    "Topic :: Software Development :: Libraries :: Python Modules",
    "Topic :: Internet",
    "Programming Language :: Python :: Implementation",
]
dynamic = ["license", "version"]

[project.urls]
Homepage = "https://github.com/pydantic/monty"
Source = "https://github.com/pydantic/monty"

[tool.maturin]
python-source = "python"
module-name = "pydantic_monty._monty"
features = ["pyo3/extension-module"]

[dependency-groups]
dev = [
    "anyio>=4.0",
    "black>=25.12.0",
    "dirty-equals>=0.11",
    "inline-snapshot>=0.31.1",
    "pytest>=9.0.2",
    "pytest-examples>=0.0.14",
    "pytest-pretty>=1.3.0",
]

[tool.pytest.ini_options]
anyio_mode = "auto"
xfail_strict = true
filterwarnings = ["error"]




------------------------------------------
File: crates/monty-python/python/pydantic_monty/__init__.py
------------------------------------------

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, Literal, TypedDict, TypeVar, cast

if TYPE_CHECKING:
    from collections.abc import Awaitable
    from types import EllipsisType

from ._monty import (
    Frame,
    Monty,
    MontyComplete,
    MontyError,
    MontyFutureSnapshot,
    MontyRuntimeError,
    MontySnapshot,
    MontySyntaxError,
    MontyTypingError,
    __version__,
)
from .os_access import AbstractFile, AbstractOS, CallbackFile, MemoryFile, OSAccess, OsFunction, StatResult

__all__ = (
    # this file
    'run_monty_async',
    'ExternalResult',
    'ResourceLimits',
    # _monty
    '__version__',
    'Monty',
    'MontyComplete',
    'MontySnapshot',
    'MontyFutureSnapshot',
    'MontyError',
    'MontySyntaxError',
    'MontyRuntimeError',
    'MontyTypingError',
    'Frame',
    # os_access
    'StatResult',
    'OsFunction',
    'AbstractOS',
    'AbstractFile',
    'MemoryFile',
    'CallbackFile',
    'OSAccess',
)
T = TypeVar('T')


async def run_monty_async(
    monty_runner: Monty,
    *,
    inputs: dict[str, Any] | None = None,
    external_functions: dict[str, Callable[..., Any]] | None = None,
    limits: ResourceLimits | None = None,
    print_callback: Callable[[Literal['stdout'], str], None] | None = None,
    os: AbstractOS | None = None,
) -> Any:
    """Run a Monty script with async external functions and optional OS access.

    This function provides a convenient way to run Monty code that uses both async
    external functions and filesystem operations via OSAccess.

    Args:
        monty_runner: The Monty runner to use.
        external_functions: A dictionary of external functions to use, can be sync or async.
        inputs: A dictionary of inputs to use.
        limits: The resource limits to use.
        print_callback: A callback to use for printing.
        os: Optional OS access handler for filesystem operations (e.g., OSAccess instance).

    Returns:
        The output of the Monty script.
    """
    import asyncio
    import inspect
    from concurrent.futures import ThreadPoolExecutor
    from functools import partial

    loop = asyncio.get_running_loop()
    external_functions = external_functions or {}
    tasks: dict[int, asyncio.Task[tuple[int, ExternalResult]]] = {}

    with ThreadPoolExecutor() as pool:

        async def run_in_pool(func: Callable[[], T]) -> T:
            return await loop.run_in_executor(pool, func)

        progress = await run_in_pool(
            partial(monty_runner.start, inputs=inputs, limits=limits, print_callback=print_callback)
        )

        try:
            while True:
                if isinstance(progress, MontyComplete):
                    return progress.output
                elif isinstance(progress, MontySnapshot):
                    # Handle OS function calls (e.g., Path.read_text, Path.exists)
                    if progress.is_os_function:
                        # When is_os_function is True, function_name is always an OsFunction
                        os_func_name = cast(OsFunction, progress.function_name)
                        if os is None:
                            e = NotImplementedError(
                                f'OS function {progress.function_name} called but no os handler provided'
                            )
                            progress = await run_in_pool(partial(progress.resume, exception=e))
                        else:
                            try:
                                result = os(os_func_name, progress.args, progress.kwargs)
                            except Exception as exc:
                                progress = await run_in_pool(partial(progress.resume, exception=exc))
                            else:
                                progress = await run_in_pool(partial(progress.resume, return_value=result))
                    # Handle external function calls
                    elif ext_function := external_functions.get(progress.function_name):
                        try:
                            result = ext_function(*progress.args, **progress.kwargs)
                        except Exception as exc:
                            progress = await run_in_pool(partial(progress.resume, exception=exc))
                        else:
                            if inspect.iscoroutine(result):
                                call_id = progress.call_id
                                tasks[call_id] = asyncio.create_task(_run_external_function(call_id, result))
                                progress = await run_in_pool(partial(progress.resume, future=...))
                            else:
                                progress = await run_in_pool(partial(progress.resume, return_value=result))
                    else:
                        e = KeyError(f'Function {progress.function_name} not found')
                        progress = await run_in_pool(partial(progress.resume, exception=e))
                else:
                    assert isinstance(progress, MontyFutureSnapshot), f'Unexpected progress type {progress!r}'

                    current_tasks: list[asyncio.Task[tuple[int, ExternalResult]]] = []
                    for call_id in progress.pending_call_ids:
                        if task := tasks.get(call_id):
                            current_tasks.append(task)

                    done, _ = await asyncio.wait(current_tasks, return_when=asyncio.FIRST_COMPLETED)

                    results: dict[int, ExternalResult] = {}
                    for task in done:
                        call_id, result = task.result()
                        results[call_id] = result
                        tasks.pop(call_id)

                    progress = await run_in_pool(partial(progress.resume, results))

        finally:
            for task in tasks.values():
                task.cancel()
            try:
                await asyncio.gather(*tasks.values())
            except asyncio.CancelledError:
                pass


async def _run_external_function(call_id: int, coro: Awaitable[Any]) -> tuple[int, ExternalResult]:
    try:
        result = await coro
    except Exception as e:
        return call_id, ExternalException(exception=e)
    else:
        return call_id, ExternalReturnValue(return_value=result)


class ResourceLimits(TypedDict, total=False):
    """
    Configuration for resource limits during code execution.

    All limits are optional. Omit a key to disable that limit.
    """

    max_allocations: int
    """Maximum number of heap allocations allowed."""

    max_duration_secs: float
    """Maximum execution time in seconds."""

    max_memory: int
    """Maximum heap memory in bytes."""

    gc_interval: int
    """Run garbage collection every N allocations."""

    max_recursion_depth: int
    """Maximum function call stack depth (default: 1000)."""


class ExternalReturnValue(TypedDict):
    return_value: Any


class ExternalException(TypedDict):
    exception: Exception


class ExternalFuture(TypedDict):
    future: EllipsisType


ExternalResult = ExternalReturnValue | ExternalException | ExternalFuture




------------------------------------------
File: crates/monty-python/python/pydantic_monty/os_access.py
------------------------------------------

from __future__ import annotations

from abc import ABC, abstractmethod
from pathlib import PurePosixPath
from typing import TYPE_CHECKING, Any, Callable, Literal, NamedTuple, Protocol, Sequence, TypeAlias, TypeGuard

if TYPE_CHECKING:
    # Self is 3.11+, hence this
    from typing import Self

__all__ = 'OsFunction', 'AbstractOS', 'AbstractFile', 'MemoryFile', 'CallbackFile', 'OSAccess', 'StatResult'

OsFunction = Literal[
    'Path.exists',
    'Path.is_file',
    'Path.is_dir',
    'Path.is_symlink',
    'Path.read_text',
    'Path.read_bytes',
    'Path.write_text',
    'Path.write_bytes',
    'Path.mkdir',
    'Path.unlink',
    'Path.rmdir',
    'Path.iterdir',
    'Path.stat',
    'Path.rename',
    'Path.resolve',
    'Path.absolute',
    'os.getenv',
    'os.environ',
]


class StatResult(NamedTuple):
    """Equivalent to os.stat_result."""

    @classmethod
    def file_stat(cls, size: int, mode: int = 0o644, mtime: float | None = None) -> Self:
        """Creates a stat_result namedtuple for a regular file.

        Use this when responding to Path.stat() OS calls.

        Args:
            size: File size in bytes
            mode: File permissions as octal (e.g., 0o644) or full mode with file type
            mtime: Modification time as Unix timestamp, defaults to Now.

        """
        import time

        # If only permission bits provided (no file type), add regular file type
        if mode < 0o1000:
            mode = mode | 0o100_000
        mtime = time.time() if mtime is None else mtime
        return cls(mode, 0, 0, 1, 0, 0, size, mtime, mtime, mtime)

    @classmethod
    def dir_stat(cls, mode: int = 0o755, mtime: float | None = None) -> Self:
        """Creates a stat_result namedtuple for a directory.

        Use this when responding to Path.stat() OS calls on directories.

        Args:
            mode: Directory permissions as octal (e.g., 0o755) or full mode with file type
            mtime: Modification time as Unix timestamp, defaults to Now.

        Returns:
            A namedtuple with stat_result fields
        """
        import time

        # If only permission bits provided (no file type), add directory type
        if mode < 0o1000:
            mode = mode | 0o040_000

        mtime = time.time() if mtime is None else mtime
        return cls(mode, 0, 0, 2, 0, 0, 4096, mtime, mtime, mtime)

    st_mode: int
    """protection bits"""

    st_ino: int
    """inode"""

    st_dev: int
    """device"""

    st_nlink: int
    """number of hard links"""

    st_uid: int
    """user ID of owner"""

    st_gid: int
    """group ID of owner"""

    st_size: int
    """total size, in bytes"""

    st_atime: float
    """time of last access"""

    st_mtime: float
    """time of last modification"""

    st_ctime: float
    """time of last change"""


class AbstractOS(ABC):
    """Abstract base class for implementing virtual filesystems and OS access.

    Subclass this and implement the abstract methods to provide a custom
    filesystem that Monty code can interact with via Path methods.

    Pass an instance as the `os` parameter to `Monty.run()`.
    """

    def __call__(self, function_name: OsFunction, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        """Dispatch a filesystem operation to the appropriate method.

        This is called by Monty when Monty code invokes Path methods.
        You typically don't need to override this method.

        Args:
            function_name: The Path method being called (e.g., 'Path.exists').
            args: The arguments passed to the method.
            kwargs: The keyword arguments passed to the method.

        Returns:
            The result of the filesystem operation.
        """
        kwargs = kwargs or {}
        match function_name:
            case 'Path.exists':
                return self.path_exists(*args)
            case 'Path.is_file':
                return self.path_is_file(*args)
            case 'Path.is_dir':
                return self.path_is_dir(*args)
            case 'Path.is_symlink':
                return self.path_is_symlink(*args)
            case 'Path.read_text':
                return self.path_read_text(*args)
            case 'Path.read_bytes':
                return self.path_read_bytes(*args)
            case 'Path.write_text':
                return self.path_write_text(*args)
            case 'Path.write_bytes':
                return self.path_write_bytes(*args)
            case 'Path.mkdir':
                assert len(kwargs) <= 2, f'Unexpected keyword arguments: {kwargs}'
                parents = kwargs.get('parents', False)
                exist_ok = kwargs.get('exist_ok', False)
                return self.path_mkdir(*args, parents=parents, exist_ok=exist_ok)
            case 'Path.unlink':
                return self.path_unlink(*args)
            case 'Path.rmdir':
                return self.path_rmdir(*args)
            case 'Path.iterdir':
                return self.path_iterdir(*args)
            case 'Path.stat':
                return self.path_stat(*args)
            case 'Path.rename':
                return self.path_rename(*args)
            case 'Path.resolve':
                return self.path_resolve(*args)
            case 'Path.absolute':
                return self.path_absolute(*args)
            case 'os.getenv':
                return self.getenv(*args)
            case 'os.environ':
                return self.get_environ()

    @abstractmethod
    def path_exists(self, path: PurePosixPath) -> bool:
        """Check if a path exists.

        Args:
            path: The path to check.

        Returns:
            True if the path exists, False otherwise.
        """
        raise NotImplementedError

    @abstractmethod
    def path_is_file(self, path: PurePosixPath) -> bool:
        """Check if a path is a regular file.

        Args:
            path: The path to check.

        Returns:
            True if the path is a regular file, False otherwise.
        """
        raise NotImplementedError

    @abstractmethod
    def path_is_dir(self, path: PurePosixPath) -> bool:
        """Check if a path is a directory.

        Args:
            path: The path to check.

        Returns:
            True if the path is a directory, False otherwise.
        """
        raise NotImplementedError

    @abstractmethod
    def path_is_symlink(self, path: PurePosixPath) -> bool:
        """Check if a path is a symbolic link.

        Args:
            path: The path to check.

        Returns:
            True if the path is a symbolic link, False otherwise.
        """
        raise NotImplementedError

    @abstractmethod
    def path_read_text(self, path: PurePosixPath) -> str:
        """Read the contents of a file as text.

        Args:
            path: The path to the file.

        Returns:
            The file contents as a string.

        Raises:
            FileNotFoundError: If the file does not exist.
            IsADirectoryError: If the path is a directory.
        """
        raise NotImplementedError

    @abstractmethod
    def path_read_bytes(self, path: PurePosixPath) -> bytes:
        """Read the contents of a file as bytes.

        Args:
            path: The path to the file.

        Returns:
            The file contents as bytes.

        Raises:
            FileNotFoundError: If the file does not exist.
            IsADirectoryError: If the path is a directory.
        """
        raise NotImplementedError

    @abstractmethod
    def path_write_text(self, path: PurePosixPath, data: str) -> int:
        """Write text data to a file.

        Args:
            path: The path to the file.
            data: The text content to write.

        Returns:
            The number of characters written.

        Raises:
            FileNotFoundError: If the parent directory does not exist.
            IsADirectoryError: If the path is a directory.
        """
        raise NotImplementedError

    @abstractmethod
    def path_write_bytes(self, path: PurePosixPath, data: bytes) -> int:
        """Write binary data to a file.

        Args:
            path: The path to the file.
            data: The binary content to write.

        Returns:
            The number of bytes written.

        Raises:
            FileNotFoundError: If the parent directory does not exist.
            IsADirectoryError: If the path is a directory.
        """
        raise NotImplementedError

    @abstractmethod
    def path_mkdir(self, path: PurePosixPath, parents: bool, exist_ok: bool) -> None:
        """Create a directory.

        Args:
            path: The path of the directory to create.
            parents: If True, create parent directories as needed.
            exist_ok: If True, don't raise an error if the directory exists.

        Raises:
            FileNotFoundError: If parents is False and parent directory doesn't exist.
            FileExistsError: If exist_ok is False and the directory already exists.
        """
        raise NotImplementedError

    @abstractmethod
    def path_unlink(self, path: PurePosixPath) -> None:
        """Remove a file.

        Args:
            path: The path to the file to remove.

        Raises:
            FileNotFoundError: If the file does not exist.
            IsADirectoryError: If the path is a directory.
        """
        raise NotImplementedError

    @abstractmethod
    def path_rmdir(self, path: PurePosixPath) -> None:
        """Remove an empty directory.

        Args:
            path: The path to the directory to remove.

        Raises:
            FileNotFoundError: If the directory does not exist.
            NotADirectoryError: If the path is not a directory.
            OSError: If the directory is not empty.
        """
        raise NotImplementedError

    @abstractmethod
    def path_iterdir(self, path: PurePosixPath) -> list[PurePosixPath]:
        """List the contents of a directory.

        Args:
            path: The path to the directory.

        Returns:
            A list of full paths (as PurePosixPath) for entries in the directory.

        Raises:
            FileNotFoundError: If the directory does not exist.
            NotADirectoryError: If the path is not a directory.
        """
        raise NotImplementedError

    @abstractmethod
    def path_stat(self, path: PurePosixPath) -> StatResult:
        """Get file status information.

        Use file_stat(), dir_stat(), or symlink_stat() helpers to create the return value.

        Args:
            path: The path to stat.

        Returns:
            A StatResult with file metadata.

        Raises:
            FileNotFoundError: If the path does not exist.
        """
        raise NotImplementedError

    @abstractmethod
    def path_rename(self, path: PurePosixPath, target: PurePosixPath) -> None:
        """Rename a file or directory.

        Args:
            path: The current path.
            target: The new path.

        Raises:
            FileNotFoundError: If the source path does not exist.
            FileExistsError: If the target already exists (platform-dependent).
        """
        raise NotImplementedError

    @abstractmethod
    def path_resolve(self, path: PurePosixPath) -> str:
        """Resolve a path to an absolute path, resolving any symlinks.

        Args:
            path: The path to resolve.

        Returns:
            The resolved absolute path with symlinks resolved.
        """
        raise NotImplementedError

    @abstractmethod
    def path_absolute(self, path: PurePosixPath) -> str:
        """Convert a path to an absolute path without resolving symlinks.

        Args:
            path: The path to convert.

        Returns:
            The absolute path.
        """
        raise NotImplementedError

    @abstractmethod
    def getenv(self, key: str, default: str | None = None) -> str | None:
        """Get an environment variable value.

        Args:
            key: The name of the environment variable.
            default: The value to return if the environment variable is not set.

        Returns:
            The value of the environment variable, or `default` if not set.
        """
        raise NotImplementedError

    @abstractmethod
    def get_environ(self) -> dict[str, str]:
        """Get the entire environment as a dictionary.

        Returns:
            A dictionary containing all environment variables.
        """
        raise NotImplementedError


class AbstractFile(Protocol):
    """Protocol defining the interface for files used with OSAccess.

    This protocol allows custom file implementations to be used with OSAccess.
    The built-in implementations are:

    - `MemoryFile`: Stores content in memory (recommended for sandboxed execution)
    - `CallbackFile`: Delegates to custom callbacks (use with caution - see its docstring)

    Security Note:
        Custom implementations of this protocol run in the host Python environment.
        The `read_content()` and `write_content()` methods can execute arbitrary code,
        including accessing the real filesystem. Only use implementations you trust.

        For sandboxed execution where Monty code should not access real files,
        use `MemoryFile` which stores all content in memory.

    Attributes:
        path: The virtual path of the file within the OSAccess filesystem.
        name: The filename (basename) extracted from path.
        permissions: Unix-style permission bits (e.g., 0o644).
        deleted: Whether the file has been marked as deleted.
    """

    path: PurePosixPath
    name: str
    permissions: int
    deleted: bool

    def read_content(self) -> str | bytes:
        """Read and return the file's content."""
        ...

    def write_content(self, content: str | bytes) -> None:
        """Write content to the file."""
        ...

    def delete(self) -> None:
        """Mark the file as deleted."""
        ...


Tree: TypeAlias = 'dict[str, AbstractFile | Tree]'


def _is_file(entry: None | AbstractFile | Tree) -> TypeGuard[AbstractFile]:
    return hasattr(entry, 'path')


def _is_dir(entry: None | AbstractFile | Tree) -> TypeGuard[Tree]:
    return isinstance(entry, dict)


class MemoryFile:
    """An in-memory virtual file for use with OSAccess.

    This is the recommended file type for sandboxed Monty execution. Content is
    stored entirely in Python memory with no access to the real filesystem.

    When Monty code reads from this file, it receives the stored content.
    When Monty code writes to this file, the content attribute is updated.

    Example::

        from pydantic_monty import Monty, OSAccess, MemoryFile

        fs = OSAccess(
            [
                MemoryFile('/config.json', '{"debug": true}'),
                MemoryFile('/data.bin', b'\\x00\\x01\\x02'),
            ]
        )

        result = Monty('''
            from pathlib import Path
            Path('/config.json').read_text()
        ''').run(os=fs)
        # result == '{"debug": true}'

    Attributes:
        path: The virtual path of the file within the OSAccess filesystem.
        name: The filename (basename) extracted from path.
        content: The file content (str for text, bytes for binary).
        permissions: Unix-style permission bits (default: 0o644).
        deleted: Whether the file has been marked as deleted.
    """

    path: PurePosixPath
    name: str
    content: str | bytes
    permissions: int = 0o644
    deleted: bool

    def __init__(self, path: str | PurePosixPath, content: str | bytes, *, permissions: int = 0o644) -> None:
        """Create an in-memory virtual file.

        Args:
            path: The virtual path for this file in the OSAccess filesystem.
            content: The initial file content (str for text, bytes for binary).
            permissions: Unix-style permission bits (default: 0o644).
        """
        self.path = PurePosixPath(path)
        self.name = self.path.name
        self.content = content
        self.permissions = permissions
        self.deleted = False

    def read_content(self) -> str | bytes:
        """Return the stored content."""
        return self.content

    def write_content(self, content: str | bytes) -> None:
        """Update the stored content."""
        self.content = content

    def delete(self) -> None:
        """Mark the file as deleted."""
        self.deleted = True

    def __repr__(self) -> str:
        repr_content = "'...'" if isinstance(self.content, str) else "b'...'"
        return f'MemoryFile(path={self.path}, content={repr_content}, permissions={self.permissions})'


_type_check_memory_file: AbstractFile = MemoryFile('test.txt', '')


class CallbackFile:
    """A virtual file backed by custom read/write callbacks.

    This class allows you to create files whose content is dynamically generated
    or persisted through custom logic. When Monty code reads or writes to this file,
    the provided callbacks are invoked.

    Security Warning:
        The callbacks execute in the host Python environment with FULL access to
        the real filesystem, network, and all system resources. A callback that
        accesses the real filesystem effectively breaks the Monty sandbox.

        Example of UNSAFE usage that breaks the sandbox::

            # DON'T DO THIS - allows Monty to read real files!
            CallbackFile(
                '/config.txt',
                read=lambda p: open('/etc/passwd').read(),
                write=lambda p, c: open('/tmp/out', 'w').write(c),
            )

        For sandboxed execution, use `MemoryFile` instead, which stores content
        purely in memory with no external access.

    Safe use cases for CallbackFile:
        - Returning dynamically computed content (e.g., current timestamp)
        - Logging writes without persisting them
        - Validating/transforming content before storage in memory
        - Integration testing with controlled external resources

    Attributes:
        path: The virtual path of the file within the OSAccess filesystem.
        name: The filename (basename) extracted from path.
        read: Callback invoked when the file is read. Receives the path and
            must return str or bytes.
        write: Callback invoked when the file is written. Receives the path
            and content (str or bytes).
        permissions: Unix-style permission bits (default: 0o644).
        deleted: Whether the file has been marked as deleted.
    """

    path: PurePosixPath
    name: str
    read: Callable[[PurePosixPath], str | bytes]
    write: Callable[[PurePosixPath, str | bytes], None]
    permissions: int = 0o644
    deleted: bool

    def __init__(
        self,
        path: str | PurePosixPath,
        read: Callable[[PurePosixPath], str | bytes],
        write: Callable[[PurePosixPath, str | bytes], None],
        *,
        permissions: int = 0o644,
    ) -> None:
        """Create a callback-backed virtual file.

        Args:
            path: The virtual path for this file in the OSAccess filesystem.
            read: Callback to generate content when the file is read.
            write: Callback to handle content when the file is written.
            permissions: Unix-style permission bits (default: 0o644).
        """
        self.path = PurePosixPath(path)
        self.name = self.path.name
        self.read = read
        self.write = write
        self.permissions = permissions
        self.deleted = False

    def read_content(self) -> str | bytes:
        """Read content by invoking the read callback."""
        return self.read(self.path)

    def write_content(self, content: str | bytes) -> None:
        """Write content by invoking the write callback."""
        self.write(self.path, content)

    def delete(self) -> None:
        """Mark the file as deleted."""
        self.deleted = True

    def __repr__(self) -> str:
        return f'CallbackFile(path={self.path}, read={self.read}, write={self.write}, permissions={self.permissions})'


_type_check_callback_file: AbstractFile = CallbackFile('test.txt', lambda _: '', lambda _, __: None)


class OSAccess(AbstractOS):
    """In-memory virtual filesystem for sandboxed Monty execution.

    OSAccess provides a complete virtual filesystem that Monty code can interact
    with via `pathlib.Path` methods. Files exist only in memory (when using
    `MemoryFile`) and cannot access the real filesystem.

    Security Model:
        When using `MemoryFile` objects, OSAccess is fully sandboxed:

        - Monty code can only access files explicitly registered with OSAccess
        - Path traversal (e.g., `../../etc/passwd`) cannot escape to real files
        - All file content is stored in Python memory, not on disk
        - Environment variables are isolated to the provided `environ` dict

        However, if `CallbackFile` is used, the callbacks run in the host
        environment and CAN access real resources. See `CallbackFile` docstring.

    Attributes:
        files: List of AbstractFile objects registered with this filesystem.
        environ: Dictionary of environment variables accessible via os.getenv().
    """

    files: list[AbstractFile]
    environ: dict[str, str]
    _tree: Tree

    def __init__(
        self,
        files: Sequence[AbstractFile] | None = None,
        environ: dict[str, str] | None = None,
        *,
        root_dir: str | PurePosixPath = '/',
    ):
        """Create a virtual filesystem with the given files.

        Args:
            files: Files to register in the virtual filesystem. Use `MemoryFile`
                for sandboxed in-memory files, or `CallbackFile` for custom logic
                (with security caveats - see its docstring).
            environ: Environment variables accessible to Monty code via os.getenv().
                Isolated from the real environment.
            root_dir: Base directory for normalizing relative file paths. Relative
                paths in files will be prefixed with this. Default is '/'.

        Raises:
            AssertionError: If root_dir is not an absolute path.
            ValueError: If a file path conflicts with another file (e.g., trying
                to create a file inside another file's path).
        """
        self.files = list(files) if files else []
        self.environ = environ or {}
        # Initialize tree with root directory - / is always present
        self._tree = {'/': {}}
        root_dir = PurePosixPath(root_dir)
        assert root_dir.is_absolute(), f'Root directory must be absolute, got {root_dir}'
        for file in self.files:
            if not file.path.is_absolute():
                file.path = root_dir / file.path

            subtree = self._tree
            *dir_parts, name = file.path.parts
            for part in dir_parts:
                entry = subtree.setdefault(part, {})
                if _is_dir(entry):
                    subtree = entry
                else:
                    raise ValueError(f'Cannot put file {file} within sub-directory of file {entry}')

            subtree[name] = file

    def __repr__(self) -> str:
        return f'OSAccess(files={self.files}, environ={self.environ})'

    def path_exists(self, path: PurePosixPath) -> bool:
        return self._get_entry(path) is not None

    def path_is_file(self, path: PurePosixPath) -> bool:
        return _is_file(self._get_entry(path))

    def path_is_dir(self, path: PurePosixPath) -> bool:
        return _is_dir(self._get_entry(path))

    def path_is_symlink(self, path: PurePosixPath) -> bool:
        return False

    def path_read_text(self, path: PurePosixPath) -> str:
        file = self._get_file(path)
        content = file.read_content()
        return content if isinstance(content, str) else content.decode()

    def path_read_bytes(self, path: PurePosixPath) -> bytes:
        file = self._get_file(path)
        content = file.read_content()
        return content if isinstance(content, bytes) else content.encode()

    def path_write_text(self, path: PurePosixPath, data: str) -> int:
        self._write_file(path, data)
        return len(data)

    def path_write_bytes(self, path: PurePosixPath, data: bytes) -> int:
        self._write_file(path, data)
        return len(data)

    def _write_file(self, path: PurePosixPath, data: bytes | str) -> None:
        entry = self._get_entry(path)
        if _is_file(entry):
            entry.write_content(data)
            return
        elif _is_dir(entry):
            raise IsADirectoryError(f'[Errno 21] Is a directory: {str(path)!r}')

        # write a new file if the parent directory exists
        parent_entry = self._parent_entry(path)
        if _is_dir(parent_entry):
            file_path = PurePosixPath(path)
            parent_entry[file_path.name] = new_file = MemoryFile(file_path, data)
            self.files.append(new_file)
        else:
            raise FileNotFoundError(f'[Errno 2] No such file or directory: {str(path)!r}')

    def path_mkdir(self, path: PurePosixPath, parents: bool, exist_ok: bool) -> None:
        entry = self._get_entry(path)
        if _is_file(entry):
            raise FileExistsError(f'[Errno 17] File exists: {str(path)!r}')
        elif _is_dir(entry):
            if exist_ok:
                return
            else:
                raise FileExistsError(f'[Errno 17] File exists: {str(path)!r}')

        parent_entry = self._parent_entry(path)
        if _is_dir(parent_entry):
            parent_entry[PurePosixPath(path).name] = {}
            return
        elif _is_file(parent_entry):
            raise NotADirectoryError(f'[Errno 20] Not a directory: {str(path)!r}')
        elif parents:
            subtree = self._tree
            for part in PurePosixPath(path).parts:
                entry = subtree.setdefault(part, {})
                if _is_dir(entry):
                    subtree = entry
                else:
                    raise NotADirectoryError(f'[Errno 20] Not a directory: {str(path)!r}')
        else:
            raise FileNotFoundError(f'[Errno 2] No such file or directory: {str(path)!r}')

    def path_unlink(self, path: PurePosixPath) -> None:
        file = self._get_file(path)
        file.delete()
        # remove from parent
        parent_dir = self._parent_entry(path)
        assert _is_dir(parent_dir), f'Expected parent of a file to always be a directory, got {parent_dir}'
        del parent_dir[file.name]

    def path_rmdir(self, path: PurePosixPath) -> None:
        dir = self._get_dir(path)
        if dir:
            raise OSError(f'[Errno 39] Directory not empty: {str(path)!r}')
        # remove from parent
        parent_dir = self._parent_entry(path)
        assert _is_dir(parent_dir), f'Expected parent of a file to always be a directory, got {parent_dir}'
        del parent_dir[PurePosixPath(path).name]

    def path_iterdir(self, path: PurePosixPath) -> list[PurePosixPath]:
        # Return full paths as PurePosixPath objects (will be converted to MontyObject::Path)
        dir_path = PurePosixPath(path)
        return [dir_path / name for name in self._get_dir(path).keys()]

    def path_stat(self, path: PurePosixPath) -> StatResult:
        entry = self._get_entry_exists(path)
        if _is_file(entry):
            content = entry.read_content()
            size = len(content) if isinstance(content, bytes) else len(content.encode())
            return StatResult.file_stat(size=size, mode=entry.permissions)
        else:
            return StatResult.dir_stat()

    def path_rename(self, path: PurePosixPath, target: PurePosixPath) -> None:
        src_entry = self._get_entry(path)
        if src_entry is None:
            raise FileNotFoundError(f'[Errno 2] No such file or directory: {str(path)!r} -> {str(target)!r}')

        parent_dir = self._parent_entry(path)
        assert _is_dir(parent_dir), f'Expected parent of a file to always be a directory, got {parent_dir}'

        target_parent = self._parent_entry(target)
        if not _is_dir(target_parent):
            raise FileNotFoundError(f'[Errno 2] No such file or directory: {str(path)!r} -> {str(target)!r}')
        target_entry = self._get_entry(target)

        if _is_file(src_entry):
            if _is_dir(target_entry):
                raise IsADirectoryError(f'[Errno 21] Is a directory: {str(path)!r} -> {str(target)!r}')
            if _is_file(target_entry):
                # need to mark the target as deleted as it'll be overwritten
                target_entry.delete()

            src_name = src_entry.path.name
            target_name = PurePosixPath(target).name
            # remove it from the old directory
            del parent_dir[src_name]
            # and put it in the new directory
            target_parent[target_name] = src_entry
        else:
            assert _is_dir(src_entry), 'src path must be a directory here'
            if _is_file(target_entry):
                raise NotADirectoryError(f'[Errno 20] Not a directory: {str(path)!r} -> {str(target)!r}')
            elif _is_dir(target_entry) and target_entry:
                raise OSError(f'[Errno 66] Directory not empty: {str(path)!r} -> {str(target)!r}')

            src_name = PurePosixPath(path).name
            target_name = PurePosixPath(target).name
            # remove it from the old directory
            del parent_dir[src_name]
            # and put it in the new directory
            target_parent[target_name] = src_entry

            # Update paths for all files in the renamed directory
            self._update_paths_recursive(src_entry, PurePosixPath(path), PurePosixPath(target))

    def path_resolve(self, path: PurePosixPath) -> str:
        # No symlinks in OSAccess, so resolve is same as absolute with normalization
        return self.path_absolute(path)

    def path_absolute(self, path: PurePosixPath) -> str:
        p = PurePosixPath(path)
        if p.is_absolute():
            return str(p)
        # In this virtual filesystem, we treat '/' as the working directory
        return str(PurePosixPath('/') / p)

    def getenv(self, key: str, default: str | None = None) -> str | None:
        return self.environ.get(key, default)

    def get_environ(self) -> dict[str, str]:
        return self.environ

    def _get_entry(self, path: PurePosixPath) -> Tree | AbstractFile | None:
        dir = self._tree

        *dir_parts, name = PurePosixPath(path).parts

        for part in dir_parts:
            entry = dir.get(part)
            if _is_dir(entry):
                dir = entry
            else:
                return None

        return dir.get(name)

    def _get_entry_exists(self, path: PurePosixPath) -> Tree | AbstractFile:
        entry = self._get_entry(path)
        if entry is None:
            raise FileNotFoundError(f'[Errno 2] No such file or directory: {str(path)!r}')
        else:
            return entry

    def _get_file(self, path: PurePosixPath) -> AbstractFile:
        entry = self._get_entry_exists(path)
        if _is_file(entry):
            return entry
        else:
            raise IsADirectoryError(f'[Errno 21] Is a directory: {str(path)!r}')

    def _get_dir(self, path: PurePosixPath) -> Tree:
        entry = self._get_entry_exists(path)
        if _is_dir(entry):
            return entry
        else:
            raise NotADirectoryError(f'[Errno 20] Not a directory: {str(path)!r}')

    def _parent_entry(self, path: PurePosixPath) -> Tree | AbstractFile | None:
        return self._get_entry(PurePosixPath(path).parent)

    def _update_paths_recursive(self, tree: Tree, old_prefix: PurePosixPath, new_prefix: PurePosixPath) -> None:
        """Update path attributes for all files in a tree after directory rename.

        When a directory is renamed, the internal tree structure is moved but
        AbstractFile objects still have their old paths. This method recursively
        updates all file paths by replacing old_prefix with new_prefix.
        """
        for entry in tree.values():
            if _is_file(entry):
                # Replace old prefix with new prefix in file path
                relative = entry.path.relative_to(old_prefix)
                entry.path = new_prefix / relative
            elif _is_dir(entry):
                self._update_paths_recursive(entry, old_prefix, new_prefix)




------------------------------------------
File: crates/monty-python/README.md
------------------------------------------

# pydantic-monty

Python bindings for the Monty sandboxed Python interpreter.

## Installation

```bash
pip install pydantic-monty
```

## Usage

### Basic Expression Evaluation

```python
import pydantic_monty

# Simple code with no inputs
m = pydantic_monty.Monty('1 + 2')
print(m.run())
#> 3
```

### Using Input Variables

```python
import pydantic_monty

# Create with code that uses input variables
m = pydantic_monty.Monty('x * y', inputs=['x', 'y'])

# Run multiple times with different inputs
print(m.run(inputs={'x': 2, 'y': 3}))
#> 6
print(m.run(inputs={'x': 10, 'y': 5}))
#> 50
```

### Resource Limits

```python
import pydantic_monty

m = pydantic_monty.Monty('x + y', inputs=['x', 'y'])

# With resource limits
limits = pydantic_monty.ResourceLimits(max_duration_secs=1.0)
result = m.run(inputs={'x': 1, 'y': 2}, limits=limits)
assert result == 3
```

### External Functions

```python
import pydantic_monty

# Code that calls an external function
m = pydantic_monty.Monty('double(x)', inputs=['x'], external_functions=['double'])

# Provide the external function implementation at runtime
result = m.run(inputs={'x': 5}, external_functions={'double': lambda x: x * 2})
print(result)
#> 10
```

### Iterative Execution with External Functions

Use `start()` and `resume()` to handle external function calls iteratively,
giving you control over each call:

```python
import pydantic_monty

code = """
data = fetch(url)
len(data)
"""

m = pydantic_monty.Monty(code, inputs=['url'], external_functions=['fetch'])

# Start execution - pauses when fetch() is called
result = m.start(inputs={'url': 'https://example.com'})

print(type(result))
#> <class 'pydantic_monty.MontySnapshot'>
print(result.function_name)  # fetch
#> fetch
print(result.args)
#> ('https://example.com',)

# Perform the actual fetch, then resume with the result
result = result.resume(return_value='hello world')

print(type(result))
#> <class 'pydantic_monty.MontyComplete'>
print(result.output)
#> 11
```

### Serialization

Both `Monty` and `MontySnapshot` can be serialized to bytes and restored later.
This allows caching parsed code or suspending execution across process boundaries:

```python
import pydantic_monty

# Serialize parsed code to avoid re-parsing
m = pydantic_monty.Monty('x + 1', inputs=['x'])
data = m.dump()

# Later, restore and run
m2 = pydantic_monty.Monty.load(data)
print(m2.run(inputs={'x': 41}))
#> 42
```

Execution state can also be serialized mid-flight:

```python
import pydantic_monty

m = pydantic_monty.Monty('fetch(url)', inputs=['url'], external_functions=['fetch'])
progress = m.start(inputs={'url': 'https://example.com'})

# Serialize the execution state
state = progress.dump()

# Later, restore and resume (e.g., in a different process)
progress2 = pydantic_monty.MontySnapshot.load(state)
result = progress2.resume(return_value='response data')
print(result.output)
#> response data
```




------------------------------------------
File: crates/monty-python/tests/test_async.py
------------------------------------------

import asyncio

import pytest
from dirty_equals import IsList
from inline_snapshot import snapshot

import pydantic_monty
from pydantic_monty import run_monty_async


def test_async():
    code = 'await foobar(1, 2)'
    m = pydantic_monty.Monty(code, external_functions=['foobar'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('foobar')
    assert progress.args == snapshot((1, 2))
    call_id = progress.call_id
    progress = progress.resume(future=...)
    assert isinstance(progress, pydantic_monty.MontyFutureSnapshot)
    assert progress.pending_call_ids == snapshot([call_id])
    progress = progress.resume({call_id: {'return_value': 3}})
    assert isinstance(progress, pydantic_monty.MontyComplete)
    assert progress.output == snapshot(3)


def test_asyncio_gather():
    code = """
import asyncio

await asyncio.gather(foo(1), bar(2))
"""
    m = pydantic_monty.Monty(code, external_functions=['foo', 'bar'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('foo')
    assert progress.args == snapshot((1,))
    foo_call_ids = progress.call_id

    progress = progress.resume(future=...)
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('bar')
    assert progress.args == snapshot((2,))
    bar_call_ids = progress.call_id
    progress = progress.resume(future=...)

    assert isinstance(progress, pydantic_monty.MontyFutureSnapshot)
    dump_progress = progress.dump()

    assert progress.pending_call_ids == IsList(foo_call_ids, bar_call_ids, check_order=False)
    progress = progress.resume({foo_call_ids: {'return_value': 3}, bar_call_ids: {'return_value': 4}})
    assert isinstance(progress, pydantic_monty.MontyComplete)
    assert progress.output == snapshot([3, 4])

    progress2 = pydantic_monty.MontyFutureSnapshot.load(dump_progress)
    assert progress2.pending_call_ids == IsList(foo_call_ids, bar_call_ids, check_order=False)
    progress = progress2.resume({bar_call_ids: {'return_value': 14}, foo_call_ids: {'return_value': 13}})
    assert isinstance(progress, pydantic_monty.MontyComplete)
    assert progress.output == snapshot([13, 14])

    progress3 = pydantic_monty.MontyFutureSnapshot.load(dump_progress)
    progress = progress3.resume({bar_call_ids: {'return_value': 14}, foo_call_ids: {'future': ...}})
    assert isinstance(progress, pydantic_monty.MontyFutureSnapshot)

    assert progress.pending_call_ids == [foo_call_ids]
    progress = progress.resume({foo_call_ids: {'return_value': 144}})
    assert isinstance(progress, pydantic_monty.MontyComplete)
    assert progress.output == snapshot([144, 14])


# === Tests for run_monty_async ===


async def test_run_monty_async_sync_function():
    """Test run_monty_async with a basic sync external function."""
    m = pydantic_monty.Monty('get_value()', external_functions=['get_value'])

    def get_value():
        return 42

    result = await run_monty_async(m, external_functions={'get_value': get_value})
    assert result == snapshot(42)


async def test_run_monty_async_async_function():
    """Test run_monty_async with a basic async external function."""
    m = pydantic_monty.Monty('await fetch_data()', external_functions=['fetch_data'])

    async def fetch_data():
        await asyncio.sleep(0.001)
        return 'async result'

    result = await run_monty_async(m, external_functions={'fetch_data': fetch_data})
    assert result == snapshot('async result')


async def test_run_monty_async_function_not_found():
    """Test that missing external function raises wrapped error."""
    m = pydantic_monty.Monty('missing_func()', external_functions=['missing_func'])

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        await run_monty_async(m, external_functions={})
    inner = exc_info.value.exception()
    assert isinstance(inner, KeyError)
    assert inner.args[0] == snapshot("'Function missing_func not found'")


async def test_run_monty_async_sync_exception():
    """Test that sync function exceptions propagate correctly."""
    m = pydantic_monty.Monty('fail()', external_functions=['fail'])

    def fail():
        raise ValueError('sync error')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        await run_monty_async(m, external_functions={'fail': fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('sync error')


async def test_run_monty_async_async_exception():
    """Test that async function exceptions propagate correctly."""
    m = pydantic_monty.Monty('await async_fail()', external_functions=['async_fail'])

    async def async_fail():
        await asyncio.sleep(0.001)
        raise RuntimeError('async error')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        await run_monty_async(m, external_functions={'async_fail': async_fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, RuntimeError)
    assert inner.args[0] == snapshot('async error')


async def test_run_monty_async_exception_caught():
    """Test that exceptions caught in try/except don't propagate."""
    code = """
try:
    fail()
except ValueError:
    caught = True
caught
"""
    m = pydantic_monty.Monty(code, external_functions=['fail'])

    def fail():
        raise ValueError('caught error')

    result = await run_monty_async(m, external_functions={'fail': fail})
    assert result == snapshot(True)


async def test_run_monty_async_multiple_async_functions():
    """Test asyncio.gather with multiple async functions."""
    code = """
import asyncio
await asyncio.gather(fetch_a(), fetch_b())
"""
    m = pydantic_monty.Monty(code, external_functions=['fetch_a', 'fetch_b'])

    async def fetch_a():
        await asyncio.sleep(0.01)
        return 'a'

    async def fetch_b():
        await asyncio.sleep(0.005)
        return 'b'

    result = await run_monty_async(m, external_functions={'fetch_a': fetch_a, 'fetch_b': fetch_b})
    assert result == snapshot(['a', 'b'])


async def test_run_monty_async_mixed_sync_async():
    """Test mix of sync and async external functions."""
    code = """
sync_val = sync_func()
async_val = await async_func()
sync_val + async_val
"""
    m = pydantic_monty.Monty(code, external_functions=['sync_func', 'async_func'])

    def sync_func():
        return 10

    async def async_func():
        await asyncio.sleep(0.001)
        return 5

    result = await run_monty_async(m, external_functions={'sync_func': sync_func, 'async_func': async_func})
    assert result == snapshot(15)


async def test_run_monty_async_with_inputs():
    """Test run_monty_async with inputs parameter."""
    m = pydantic_monty.Monty('process(x, y)', inputs=['x', 'y'], external_functions=['process'])

    def process(a: int, b: int) -> int:
        return a * b

    result = await run_monty_async(m, inputs={'x': 6, 'y': 7}, external_functions={'process': process})
    assert result == snapshot(42)


async def test_run_monty_async_with_print_callback():
    """Test run_monty_async with print_callback parameter."""
    output: list[tuple[str, str]] = []

    def callback(stream: str, text: str) -> None:
        output.append((stream, text))

    m = pydantic_monty.Monty('print("hello from async")')
    result = await run_monty_async(m, print_callback=callback)
    assert result is None
    assert output == snapshot([('stdout', 'hello from async'), ('stdout', '\n')])


async def test_run_monty_async_function_returning_none():
    """Test async function that returns None."""
    m = pydantic_monty.Monty('do_nothing()', external_functions=['do_nothing'])

    def do_nothing():
        return None

    result = await run_monty_async(m, external_functions={'do_nothing': do_nothing})
    assert result is None


async def test_run_monty_async_no_external_calls():
    """Test run_monty_async when code has no external calls."""
    m = pydantic_monty.Monty('1 + 2 + 3')
    result = await run_monty_async(m)
    assert result == snapshot(6)


# === Tests for run_monty_async with os parameter ===


async def test_run_monty_async_with_os():
    """run_monty_async can use OSAccess for file operations."""
    from pydantic_monty import MemoryFile, OSAccess

    fs = OSAccess([MemoryFile('/test.txt', content='hello world')])

    m = pydantic_monty.Monty(
        """
from pathlib import Path
Path('/test.txt').read_text()
        """,
        external_functions=[],
    )

    result = await run_monty_async(m, os=fs)
    assert result == snapshot('hello world')


async def test_run_monty_async_os_with_external_functions():
    """run_monty_async can combine OSAccess with external functions."""
    from pydantic_monty import MemoryFile, OSAccess

    fs = OSAccess([MemoryFile('/data.txt', content='test data')])

    async def process(text: str) -> str:
        return text.upper()

    m = pydantic_monty.Monty(
        """
from pathlib import Path
content = Path('/data.txt').read_text()
await process(content)
        """,
        external_functions=['process'],
    )

    result = await run_monty_async(
        m,
        external_functions={'process': process},
        os=fs,
    )
    assert result == snapshot('TEST DATA')


async def test_run_monty_async_os_file_not_found():
    """run_monty_async propagates OS errors correctly."""
    from pydantic_monty import OSAccess

    fs = OSAccess()

    m = pydantic_monty.Monty(
        """
from pathlib import Path
Path('/missing.txt').read_text()
        """,
    )

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        await run_monty_async(m, os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing.txt'")


async def test_run_monty_async_os_not_provided():
    """run_monty_async raises error when OS function called without os handler."""
    m = pydantic_monty.Monty(
        """
from pathlib import Path
Path('/test.txt').exists()
        """,
    )

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        await run_monty_async(m)
    inner = exc_info.value.exception()
    assert isinstance(inner, RuntimeError)
    assert 'OS function' in inner.args[0]
    assert 'no os handler provided' in inner.args[0]


async def test_run_monty_async_os_write_and_read():
    """run_monty_async supports both reading and writing files."""
    from pydantic_monty import MemoryFile, OSAccess

    fs = OSAccess([MemoryFile('/file.txt', content='original')])

    m = pydantic_monty.Monty(
        """
from pathlib import Path
p = Path('/file.txt')
p.write_text('updated')
p.read_text()
        """,
    )

    result = await run_monty_async(m, os=fs)
    assert result == snapshot('updated')




------------------------------------------
File: crates/monty-python/tests/test_basic.py
------------------------------------------

from inline_snapshot import snapshot

import pydantic_monty


def test_simple_expression():
    m = pydantic_monty.Monty('1 + 2')
    assert m.run() == snapshot(3)


def test_arithmetic():
    m = pydantic_monty.Monty('10 * 5 - 3')
    assert m.run() == snapshot(47)


def test_string_concatenation():
    m = pydantic_monty.Monty('"hello" + " " + "world"')
    assert m.run() == snapshot('hello world')


def test_multiple_runs_same_instance():
    m = pydantic_monty.Monty('x * 2', inputs=['x'])
    assert m.run(inputs={'x': 5}) == snapshot(10)
    assert m.run(inputs={'x': 10}) == snapshot(20)
    assert m.run(inputs={'x': -3}) == snapshot(-6)


def test_repr_no_inputs():
    m = pydantic_monty.Monty('1 + 1')
    assert repr(m) == snapshot("Monty(<1 line of code>, script_name='main.py')")


def test_repr_with_inputs():
    m = pydantic_monty.Monty('x', inputs=['x', 'y'])
    assert repr(m) == snapshot('Monty(<1 line of code>, script_name=\'main.py\', inputs=["x", "y"])')


def test_repr_with_external_functions():
    m = pydantic_monty.Monty('foo()', external_functions=['foo'])
    assert repr(m) == snapshot('Monty(<1 line of code>, script_name=\'main.py\', external_functions=["foo"])')


def test_repr_with_inputs_and_external_functions():
    m = pydantic_monty.Monty('foo(x)', inputs=['x'], external_functions=['foo'])
    assert repr(m) == snapshot(
        'Monty(<1 line of code>, script_name=\'main.py\', inputs=["x"], external_functions=["foo"])'
    )


def test_multiline_code():
    code = """
x = 1
y = 2
x + y
"""
    m = pydantic_monty.Monty(code)
    assert m.run() == snapshot(3)


def test_function_definition_and_call():
    code = """
def add(a, b):
    return a + b

add(3, 4)
"""
    m = pydantic_monty.Monty(code)
    assert m.run() == snapshot(7)




------------------------------------------
File: crates/monty-python/tests/test_dataclasses.py
------------------------------------------

from dataclasses import (
    FrozenInstanceError,
    asdict,
    astuple,
    dataclass,
    fields,
    is_dataclass,
)
from typing import NoReturn

import pytest
from inline_snapshot import snapshot

import pydantic_monty


@dataclass
class Person:
    name: str
    age: int


def test_dataclass_input():
    """Dataclass instances are converted and returned as MontyDataclass."""

    m = pydantic_monty.Monty('x', inputs=['x'])
    m.register_dataclass(Person)
    result = m.run(inputs={'x': Person(name='Alice', age=30)})
    assert result.name == snapshot('Alice')
    assert result.age == snapshot(30)
    assert is_dataclass(result)
    assert isinstance(result, Person)
    assert asdict(result) == snapshot({'name': 'Alice', 'age': 30})
    assert repr(result) == snapshot("Person(name='Alice', age=30)")


def test_dataclass_unknown():
    """Dataclass instances are converted and returned as MontyDataclass."""

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': Person(name='Alice', age=30)})
    assert result.name == snapshot('Alice')
    assert result.age == snapshot(30)
    assert is_dataclass(result)
    assert not isinstance(result, Person)
    assert asdict(result) == snapshot({'name': 'Alice', 'age': 30})  # pyright: ignore[reportArgumentType]
    assert repr(result) == snapshot("<Unknown Dataclass Person(name='Alice', age=30)>")


@dataclass(frozen=True)
class Point:
    x: int
    y: int


def test_dataclass_frozen():
    """Frozen dataclasses are converted like regular dataclasses."""

    m = pydantic_monty.Monty('p', inputs=['p'], dataclass_registry=[Point])
    result = m.run(inputs={'p': Point(x=10, y=20)})
    assert isinstance(result, Point)
    assert result.x == snapshot(10)
    assert result.y == snapshot(20)
    assert repr(result) == snapshot('Point(x=10, y=20)')


@dataclass
class Address:
    city: str
    zip_code: str


@dataclass
class PersonAddress:
    name: str
    address: Address


def test_dataclass_nested():
    """Nested dataclasses are recursively converted."""

    m = pydantic_monty.Monty('x', inputs=['x'])
    m.register_dataclass(Address)
    m.register_dataclass(PersonAddress)
    result = m.run(inputs={'x': PersonAddress(name='Bob', address=Address(city='NYC', zip_code='10001'))})
    assert isinstance(result, PersonAddress)
    assert result.name == snapshot('Bob')
    assert isinstance(result.address, Address)
    assert result.address.city == snapshot('NYC')
    assert result.address.zip_code == snapshot('10001')


def test_dataclass_nested_unknown():
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': PersonAddress(name='Bob', address=Address(city='NYC', zip_code='10001'))})
    assert not isinstance(result, PersonAddress)
    assert result.name == snapshot('Bob')
    assert not isinstance(result.address, Address)
    assert result.address.city == snapshot('NYC')
    assert result.address.zip_code == snapshot('10001')


def test_dataclass_with_list_field():
    """Dataclasses with list fields are properly converted."""

    @dataclass
    class Container:
        items: list[int]

    m = pydantic_monty.Monty('x', inputs=['x'])
    m.register_dataclass(Container)
    result = m.run(inputs={'x': Container(items=[1, 2, 3])})
    assert result.items == snapshot([1, 2, 3])


def test_dataclass_with_dict_field():
    """Dataclasses with dict fields are properly converted."""

    @dataclass
    class Config:
        settings: dict[str, int]

    m = pydantic_monty.Monty('x', inputs=['x'])
    m.register_dataclass(Config)
    result = m.run(inputs={'x': Config(settings={'a': 1, 'b': 2})})
    assert result.settings == snapshot({'a': 1, 'b': 2})


def test_dataclass_empty():
    """Empty dataclass (no fields) has empty repr."""

    @dataclass
    class Empty:
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    m.register_dataclass(Empty)
    result = m.run(inputs={'x': Empty()})
    assert repr(result) == snapshot('test_dataclass_empty.<locals>.Empty()')


def test_dataclass_type_raises():
    """Dataclass type (not instance) should raise TypeError."""

    @dataclass
    class MyClass:
        value: int

    m = pydantic_monty.Monty('x', inputs=['x'])
    m.register_dataclass(MyClass)
    with pytest.raises(TypeError, match='Cannot convert type to Monty value'):
        m.run(inputs={'x': MyClass})


# === Field access ===


def test_dataclass_field_access():
    """Access individual fields of a dataclass."""

    @dataclass
    class Person:
        name: str
        age: int

    m = pydantic_monty.Monty('x.name', inputs=['x'])
    assert m.run(inputs={'x': Person(name='Alice', age=30)}) == snapshot('Alice')

    m = pydantic_monty.Monty('x.age', inputs=['x'])
    assert m.run(inputs={'x': Person(name='Alice', age=30)}) == snapshot(30)


def test_dataclass_field_access_nested():
    """Access fields of nested dataclasses."""

    m = pydantic_monty.Monty('x.address.city', inputs=['x'])
    result = m.run(inputs={'x': PersonAddress(name='Bob', address=Address(city='NYC', zip_code='10001'))})
    assert result == snapshot('NYC')


def test_dataclass_field_in_expression():
    """Use dataclass fields in expressions."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p.x + p.y', inputs=['p'])
    assert m.run(inputs={'p': Point(x=10, y=20)}) == snapshot(30)


def test_dataclass_field_access_missing():
    """Accessing a non-existent field raises AttributeError."""

    @dataclass
    class Person:
        name: str

    m = pydantic_monty.Monty('x.age', inputs=['x'])
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(inputs={'x': Person(name='Alice')})
    assert isinstance(exc_info.value.exception(), AttributeError)


# === Repr ===


def test_dataclass_repr():
    """Repr of dataclass shows ClassName(field=value, ...) format."""

    @dataclass
    class Person:
        name: str
        age: int

    m = pydantic_monty.Monty('repr(x)', inputs=['x'])
    assert m.run(inputs={'x': Person(name='Alice', age=30)}) == snapshot("Person(name='Alice', age=30)")


def test_dataclass_repr_frozen():
    """Repr of frozen dataclass shows same format."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('repr(p)', inputs=['p'])
    assert m.run(inputs={'p': Point(x=10, y=20)}) == snapshot('Point(x=10, y=20)')


def test_dataclass_repr_nested():
    """Repr of nested dataclass shows nested repr."""

    @dataclass
    class Inner:
        value: int

    @dataclass
    class Outer:
        inner: Inner

    m = pydantic_monty.Monty('repr(x)', inputs=['x'])
    assert m.run(inputs={'x': Outer(inner=Inner(value=42))}) == snapshot('Outer(inner=Inner(value=42))')


def test_dataclass_repr_empty():
    """Repr of empty dataclass shows ClassName()."""

    @dataclass
    class Empty:
        pass

    m = pydantic_monty.Monty('repr(x)', inputs=['x'])
    m.register_dataclass(Empty)
    assert m.run(inputs={'x': Empty()}) == snapshot('Empty()')


# === Setattr ===


def test_dataclass_setattr_mutable_unknown():
    """Setting attributes on mutable dataclass works."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    # Modify existing field
    result.x = 100
    assert result.x == snapshot(100)
    assert repr(result) == snapshot('<Unknown Dataclass Point(x=100, y=20)>')

    # Add new attribute (not in repr since not a declared field)
    result.z = 30
    assert result.z == snapshot(30)
    assert repr(result) == snapshot('<Unknown Dataclass Point(x=100, y=20)>')


def test_dataclass_setattr_frozen():
    """Setting attributes on frozen dataclass raises FrozenInstanceError."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    # FrozenInstanceError is raised (which is a subclass of AttributeError)
    with pytest.raises(FrozenInstanceError, match="cannot assign to field 'x'"):
        result.x = 100

    with pytest.raises(FrozenInstanceError, match="cannot assign to field 'z'"):
        result.z = 30


def test_frozen_instance_error_is_attribute_error():
    """FrozenInstanceError can be caught as AttributeError."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    # Can catch with AttributeError (parent class)
    with pytest.raises(AttributeError):
        result.x = 100

    # Verify it's actually FrozenInstanceError
    try:
        result.y = 200
    except AttributeError as e:
        assert isinstance(e, FrozenInstanceError)


def test_frozen_instance_error_message():
    """FrozenInstanceError has correct message format."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    with pytest.raises(FrozenInstanceError) as exc_info:
        result.x = 100
    assert exc_info.value.args[0] == snapshot("cannot assign to field 'x'")


def test_frozen_instance_error_from_monty_code():
    """FrozenInstanceError raised by Monty code is properly converted."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    # Monty code that tries to modify a frozen dataclass
    code = """
p.x = 100
"""
    m = pydantic_monty.Monty(code, inputs=['p'])

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(inputs={'p': Point(x=10, y=20)})
    inner = exc_info.value.exception()
    assert isinstance(inner, FrozenInstanceError)
    assert inner.args[0] == snapshot("cannot assign to field 'x'")


def test_frozen_instance_error_from_monty_caught_as_attribute_error():
    """FrozenInstanceError from Monty can be caught as AttributeError."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    code = 'p.x = 100'
    m = pydantic_monty.Monty(code, inputs=['p'])

    # Wrapped in MontyRuntimeError, but inner exception is FrozenInstanceError
    # which is a subclass of AttributeError
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(inputs={'p': Point(x=10, y=20)})
    inner = exc_info.value.exception()
    assert isinstance(inner, AttributeError)
    assert isinstance(inner, FrozenInstanceError)


def test_frozen_instance_error_from_external_function():
    """FrozenInstanceError from external function is properly converted."""
    code = """
try:
    fail()
except FrozenInstanceError:
    caught = 'frozen'
except AttributeError:
    caught = 'attr'
caught
"""
    m = pydantic_monty.Monty(code, external_functions=['fail'])

    def fail() -> NoReturn:
        raise FrozenInstanceError('cannot assign to field')

    # Monty should catch it as FrozenInstanceError specifically
    result = m.run(external_functions={'fail': fail})
    assert result == snapshot('frozen')


def test_frozen_instance_error_from_external_function_propagates():
    """FrozenInstanceError from external function propagates to Python."""
    m = pydantic_monty.Monty('fail()', external_functions=['fail'])

    def fail() -> NoReturn:
        raise FrozenInstanceError('test frozen error')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'fail': fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, FrozenInstanceError)
    assert inner.args[0] == snapshot('test frozen error')


# === Equality ===


def test_dataclass_equality_same():
    """Equal dataclasses compare equal."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('(a, b)', inputs=['a', 'b'])
    a, b = m.run(inputs={'a': Point(x=10, y=20), 'b': Point(x=10, y=20)})
    assert a == b


def test_dataclass_equality_different_values():
    """Dataclasses with different values compare not equal."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('(a, b)', inputs=['a', 'b'])
    a, b = m.run(inputs={'a': Point(x=10, y=20), 'b': Point(x=10, y=30)})
    assert a != b


def test_dataclass_equality_different_types():
    """Dataclasses of different types compare not equal."""

    @dataclass
    class Point:
        x: int
        y: int

    @dataclass
    class Vector:
        x: int
        y: int

    m = pydantic_monty.Monty('(a, b)', inputs=['a', 'b'])
    a, b = m.run(inputs={'a': Point(x=10, y=20), 'b': Vector(x=10, y=20)})
    assert a != b


def test_dataclass_equality_with_other_type():
    """Dataclass compared to non-dataclass returns False."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})
    assert result != {'x': 10, 'y': 20}
    assert result != (10, 20)
    assert result != 'Point(x=10, y=20)'


# === Hashing ===


def test_dataclass_hash_frozen():
    """Frozen dataclasses are hashable."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    h = hash(result)
    assert isinstance(h, int)
    # Hash is consistent
    assert hash(result) == h


def test_dataclass_hash_frozen_equal_values():
    """Equal frozen dataclasses have equal hashes."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('(a, b)', inputs=['a', 'b'])
    a, b = m.run(inputs={'a': Point(x=10, y=20), 'b': Point(x=10, y=20)})

    assert hash(a) == hash(b)


def test_dataclass_hash_mutable_raises():
    """Mutable dataclasses are not hashable."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    with pytest.raises(TypeError, match="unhashable type: 'UnknownDataclass'"):
        hash(result)


def test_dataclass_hash_in_set():
    """Frozen dataclasses can be used in sets."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('(a, b, c)', inputs=['a', 'b', 'c'])
    a, b, c = m.run(
        inputs={
            'a': Point(x=10, y=20),
            'b': Point(x=10, y=20),  # duplicate
            'c': Point(x=30, y=40),
        }
    )

    s = {a, b, c}
    assert len(s) == snapshot(2)


def test_dataclass_hash_as_dict_key():
    """Frozen dataclasses can be used as dict keys."""

    @dataclass(frozen=True)
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('(a, b)', inputs=['a', 'b'])
    a, b = m.run(inputs={'a': Point(x=10, y=20), 'b': Point(x=10, y=20)})

    d = {a: 'first'}
    assert d[b] == snapshot('first')


# === dataclasses module compatibility ===


def test_dataclass_is_dataclass():
    """is_dataclass() returns True for returned dataclasses."""

    @dataclass
    class Person:
        name: str
        age: int

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': Person(name='Alice', age=30)})
    assert is_dataclass(result) is True


def test_dataclass_fields():
    """fields() returns Field objects for returned dataclasses."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    fs = fields(result)
    assert len(fs) == snapshot(2)
    assert fs[0].name == snapshot('x')
    assert fs[1].name == snapshot('y')
    # Type is inferred from value
    assert fs[0].type is int
    assert fs[1].type is int


def test_dataclass_fields_string():
    """fields() returns correct type for string fields."""

    @dataclass
    class Person:
        name: str

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Person(name='Alice')})

    fs = fields(result)
    assert fs[0].name == snapshot('name')
    assert fs[0].type is str


def test_dataclass_asdict():
    """asdict() converts returned dataclass to dict."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    d = asdict(result)
    assert d == snapshot({'x': 10, 'y': 20})


def test_dataclass_asdict_nested():
    """asdict() recursively converts nested dataclasses."""

    @dataclass
    class Inner:
        value: int

    @dataclass
    class Outer:
        inner: Inner

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': Outer(inner=Inner(value=42))})

    d = asdict(result)
    assert d == snapshot({'inner': {'value': 42}})


def test_dataclass_astuple():
    """astuple() converts returned dataclass to tuple."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    t = astuple(result)
    assert t == snapshot((10, 20))


def test_dataclass_dataclass_fields_attr():
    """__dataclass_fields__ attribute is accessible."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    df = result.__dataclass_fields__
    assert 'x' in df
    assert 'y' in df
    assert df['x'].name == snapshot('x')
    assert df['y'].name == snapshot('y')


def test_dataclass_params_frozen():
    """__dataclass_params__.frozen reflects frozen status."""

    @dataclass(frozen=True)
    class FrozenPoint:
        x: int
        y: int

    @dataclass
    class MutablePoint:
        x: int
        y: int

    m = pydantic_monty.Monty('(f, m)', inputs=['f', 'm'])
    frozen, mutable = m.run(inputs={'f': FrozenPoint(x=1, y=2), 'm': MutablePoint(x=3, y=4)})

    assert frozen.__dataclass_params__.frozen is True
    assert mutable.__dataclass_params__.frozen is False


def test_dataclass_params_attributes():
    """__dataclass_params__ has expected attributes."""

    @dataclass
    class Point:
        x: int
        y: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Point(x=10, y=20)})

    params = result.__dataclass_params__
    assert params.init is True
    assert params.repr is True
    assert params.eq is True
    assert params.order is False
    assert params.frozen is False


def test_repeat_dataclass_name():
    """Two classes with the same name are distinguished because we use id, not name."""

    def create_point():
        @dataclass
        class Point:
            x: int
            y: int

        return Point

    point_cls2 = create_point()
    m = pydantic_monty.Monty('a, b', inputs=['a', 'b'], dataclass_registry=[Point, point_cls2])
    a, b = m.run(inputs={'a': Point(x=10, y=20), 'b': point_cls2(x=30, y=40)})
    assert isinstance(a, Point)
    assert isinstance(b, point_cls2)




------------------------------------------
File: crates/monty-python/tests/test_exceptions.py
------------------------------------------

import pytest
from inline_snapshot import snapshot

import pydantic_monty

# === MontyRuntimeError tests ===


def test_zero_division_error():
    m = pydantic_monty.Monty('1 / 0')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    # Check that it's also a MontyError
    assert isinstance(exc_info.value, pydantic_monty.MontyError)
    # Check the inner exception
    inner = exc_info.value.exception()
    assert isinstance(inner, ZeroDivisionError)


def test_value_error():
    m = pydantic_monty.Monty("raise ValueError('bad value')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert str(inner) == snapshot('bad value')


def test_type_error():
    m = pydantic_monty.Monty("'string' + 1")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, TypeError)


def test_index_error():
    m = pydantic_monty.Monty('[1, 2, 3][10]')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, IndexError)


def test_key_error():
    m = pydantic_monty.Monty("{'a': 1}['b']")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, KeyError)


def test_attribute_error():
    m = pydantic_monty.Monty("raise AttributeError('no such attr')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, AttributeError)
    assert str(inner) == snapshot('no such attr')


def test_name_error():
    m = pydantic_monty.Monty('undefined_variable')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, NameError)


def test_assertion_error():
    m = pydantic_monty.Monty('assert False')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, AssertionError)


def test_assertion_error_with_message():
    m = pydantic_monty.Monty("assert False, 'custom message'")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, AssertionError)
    assert str(inner) == snapshot('custom message')


def test_runtime_error():
    m = pydantic_monty.Monty("raise RuntimeError('runtime error')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, RuntimeError)
    assert str(inner) == snapshot('runtime error')


def test_not_implemented_error():
    m = pydantic_monty.Monty("raise NotImplementedError('not implemented')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, NotImplementedError)
    assert str(inner) == snapshot('not implemented')


# === MontySyntaxError tests ===


def test_syntax_error_on_init():
    with pytest.raises(pydantic_monty.MontySyntaxError) as exc_info:
        pydantic_monty.Monty('def')
    # Check that it's also a MontyError
    assert isinstance(exc_info.value, pydantic_monty.MontyError)
    # Check the inner exception
    inner = exc_info.value.exception()
    assert isinstance(inner, SyntaxError)


def test_syntax_error_unclosed_paren():
    with pytest.raises(pydantic_monty.MontySyntaxError) as exc_info:
        pydantic_monty.Monty('print(1')
    inner = exc_info.value.exception()
    assert isinstance(inner, SyntaxError)


def test_syntax_error_invalid_syntax():
    with pytest.raises(pydantic_monty.MontySyntaxError) as exc_info:
        pydantic_monty.Monty('x = = 1')
    inner = exc_info.value.exception()
    assert isinstance(inner, SyntaxError)


# === Catching with base class ===


def test_catch_with_base_class():
    m = pydantic_monty.Monty('1 / 0')
    with pytest.raises(pydantic_monty.MontyError):
        m.run()


def test_catch_syntax_error_with_base_class():
    with pytest.raises(pydantic_monty.MontyError):
        pydantic_monty.Monty('def')


# === Exception handling within Monty ===


def test_raise_caught_exception():
    code = """
try:
    1 / 0
except ZeroDivisionError as e:
    result = 'caught'
result
"""
    m = pydantic_monty.Monty(code)
    assert m.run() == snapshot('caught')


def test_exception_in_function():
    code = """
def fail():
    raise ValueError('from function')

fail()
"""
    m = pydantic_monty.Monty(code)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert str(inner) == snapshot('from function')


# === Display and str methods ===


def test_display_traceback():
    m = pydantic_monty.Monty('1 / 0')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    display = exc_info.value.display()
    assert 'Traceback (most recent call last):' in display
    assert 'ZeroDivisionError' in display


def test_display_type_msg():
    m = pydantic_monty.Monty("raise ValueError('test message')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    display = exc_info.value.display('type-msg')
    assert display == snapshot('ValueError: test message')


def test_runtime_display():
    m = pydantic_monty.Monty("raise ValueError('test message')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    assert exc_info.value.display('msg') == snapshot('test message')
    assert exc_info.value.display('type-msg') == snapshot('ValueError: test message')
    assert exc_info.value.display() == snapshot("""\
Traceback (most recent call last):
  File "main.py", line 1, in <module>
    raise ValueError('test message')
ValueError: test message\
""")


def test_str_returns_msg():
    m = pydantic_monty.Monty("raise ValueError('test message')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    assert str(exc_info.value) == snapshot('ValueError: test message')


def test_syntax_error_display():
    with pytest.raises(pydantic_monty.MontySyntaxError) as exc_info:
        pydantic_monty.Monty('def')
    assert exc_info.value.display() == snapshot('Expected an identifier at byte range 3..3')
    assert exc_info.value.display('type-msg') == snapshot('SyntaxError: Expected an identifier at byte range 3..3')


def test_syntax_error_str():
    with pytest.raises(pydantic_monty.MontySyntaxError) as exc_info:
        pydantic_monty.Monty('def')
    # str() returns just the message
    assert 'SyntaxError' not in str(exc_info.value)


# === Traceback tests ===


def test_traceback_frames():
    code = """\
def inner():
    raise ValueError('error')

def outer():
    inner()

outer()
"""
    m = pydantic_monty.Monty(code)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    frames = exc_info.value.traceback()
    assert isinstance(frames, list)
    assert len(frames) >= 2  # At least module level, outer(), and inner()

    assert exc_info.value.display() == snapshot("""\
Traceback (most recent call last):
  File "main.py", line 7, in <module>
    outer()
    ~~~~~~~
  File "main.py", line 5, in outer
    inner()
    ~~~~~~~
  File "main.py", line 2, in inner
    raise ValueError('error')
ValueError: error\
""")

    assert [f.dict() for f in frames] == snapshot(
        [
            {
                'filename': 'main.py',
                'line': 7,
                'column': 1,
                'end_line': 7,
                'end_column': 8,
                'function_name': '<module>',
                'source_line': 'outer()',
            },
            {
                'filename': 'main.py',
                'line': 5,
                'column': 5,
                'end_line': 5,
                'end_column': 12,
                'function_name': 'outer',
                'source_line': '    inner()',
            },
            {
                'filename': 'main.py',
                'line': 2,
                'column': 11,
                'end_line': 2,
                'end_column': 30,
                'function_name': 'inner',
                'source_line': "    raise ValueError('error')",
            },
        ]
    )


def test_frame_properties():
    code = """
def foo():
    raise ValueError('test')

foo()
"""
    m = pydantic_monty.Monty(code)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    frames = exc_info.value.traceback()

    assert [f.dict() for f in frames] == snapshot(
        [
            {
                'filename': 'main.py',
                'line': 5,
                'column': 1,
                'end_line': 5,
                'end_column': 6,
                'function_name': '<module>',
                'source_line': 'foo()',
            },
            {
                'filename': 'main.py',
                'line': 3,
                'column': 11,
                'end_line': 3,
                'end_column': 29,
                'function_name': 'foo',
                'source_line': "    raise ValueError('test')",
            },
        ]
    )


# === Repr tests ===


def test_runtime_error_repr():
    m = pydantic_monty.Monty("raise ValueError('test')")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    assert repr(exc_info.value) == snapshot('MontyRuntimeError(ValueError: test)')


def test_syntax_error_repr():
    with pytest.raises(pydantic_monty.MontySyntaxError) as exc_info:
        pydantic_monty.Monty('def')
    assert repr(exc_info.value) == snapshot('MontySyntaxError(Expected an identifier at byte range 3..3)')


def test_frame_repr():
    code = """
def foo():
    raise ValueError('test')

foo()
"""
    m = pydantic_monty.Monty(code)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    frames = exc_info.value.traceback()
    frame = frames[0]
    assert repr(frame) == snapshot("Frame(filename='main.py', line=5, column=1, function_name='<module>')")




------------------------------------------
File: crates/monty-python/tests/test_external.py
------------------------------------------

from typing import Any

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_external_function_no_args():
    m = pydantic_monty.Monty('noop()', external_functions=['noop'])

    def noop(*args: Any, **kwargs: Any) -> str:
        assert args == snapshot(())
        assert kwargs == snapshot({})
        return 'called'

    assert m.run(external_functions={'noop': noop}) == snapshot('called')


def test_external_function_positional_args():
    m = pydantic_monty.Monty('func(1, 2, 3)', external_functions=['func'])

    def func(*args: Any, **kwargs: Any) -> str:
        assert args == snapshot((1, 2, 3))
        assert kwargs == snapshot({})
        return 'ok'

    assert m.run(external_functions={'func': func}) == snapshot('ok')


def test_external_function_kwargs_only():
    m = pydantic_monty.Monty('func(a=1, b="two")', external_functions=['func'])

    def func(*args: Any, **kwargs: Any) -> str:
        assert args == snapshot(())
        assert kwargs == snapshot({'a': 1, 'b': 'two'})
        return 'ok'

    assert m.run(external_functions={'func': func}) == snapshot('ok')


def test_external_function_mixed_args_kwargs():
    m = pydantic_monty.Monty('func(1, 2, x="hello", y=True)', external_functions=['func'])

    def func(*args: Any, **kwargs: Any) -> str:
        assert args == snapshot((1, 2))
        assert kwargs == snapshot({'x': 'hello', 'y': True})
        return 'ok'

    assert m.run(external_functions={'func': func}) == snapshot('ok')


def test_external_function_complex_types():
    m = pydantic_monty.Monty('func([1, 2], {"key": "value"})', external_functions=['func'])

    def func(*args: Any, **kwargs: Any) -> str:
        assert args == snapshot(([1, 2], {'key': 'value'}))
        assert kwargs == snapshot({})
        return 'ok'

    assert m.run(external_functions={'func': func}) == snapshot('ok')


def test_external_function_returns_none():
    m = pydantic_monty.Monty('do_nothing()', external_functions=['do_nothing'])

    def do_nothing(*args: Any, **kwargs: Any) -> None:
        assert args == snapshot(())
        assert kwargs == snapshot({})

    assert m.run(external_functions={'do_nothing': do_nothing}) is None


def test_external_function_returns_complex_type():
    m = pydantic_monty.Monty('get_data()', external_functions=['get_data'])

    def get_data(*args: Any, **kwargs: Any) -> dict[str, Any]:
        return {'a': [1, 2, 3], 'b': {'nested': True}}

    result = m.run(external_functions={'get_data': get_data})
    assert result == snapshot({'a': [1, 2, 3], 'b': {'nested': True}})


def test_multiple_external_functions():
    m = pydantic_monty.Monty('add(1, 2) + mul(3, 4)', external_functions=['add', 'mul'])

    def add(*args: Any, **kwargs: Any) -> int:
        assert args == snapshot((1, 2))
        assert kwargs == snapshot({})
        return args[0] + args[1]

    def mul(*args: Any, **kwargs: Any) -> int:
        assert args == snapshot((3, 4))
        assert kwargs == snapshot({})
        return args[0] * args[1]

    result = m.run(external_functions={'add': add, 'mul': mul})
    assert result == snapshot(15)  # 3 + 12


def test_external_function_called_multiple_times():
    m = pydantic_monty.Monty('counter() + counter() + counter()', external_functions=['counter'])

    call_count = 0

    def counter(*args: Any, **kwargs: Any) -> int:
        nonlocal call_count
        assert args == snapshot(())
        assert kwargs == snapshot({})
        call_count += 1
        return call_count

    result = m.run(external_functions={'counter': counter})
    assert result == snapshot(6)  # 1 + 2 + 3
    assert call_count == snapshot(3)


def test_external_function_with_input():
    m = pydantic_monty.Monty('process(x)', inputs=['x'], external_functions=['process'])

    def process(*args: Any, **kwargs: Any) -> int:
        assert args == snapshot((5,))
        assert kwargs == snapshot({})
        return args[0] * 10

    assert m.run(inputs={'x': 5}, external_functions={'process': process}) == snapshot(50)


def test_external_function_not_provided_raises():
    m = pydantic_monty.Monty('missing()', external_functions=['missing'])

    with pytest.raises(RuntimeError, match='no external_functions provided'):
        m.run()


def test_undeclared_function_raises_name_error():
    m = pydantic_monty.Monty('unknown_func()')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    inner = exc_info.value.exception()
    assert type(inner) is NameError
    assert str(inner) == snapshot("name 'unknown_func' is not defined")


def test_external_function_raises_exception():
    """Test that exceptions from external functions propagate to the caller."""
    m = pydantic_monty.Monty('fail()', external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> None:
        raise ValueError('intentional error')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'fail': fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('intentional error')


def test_external_function_wrong_name_raises():
    """Test that calling a missing external function raises KeyError."""
    m = pydantic_monty.Monty('foo()', external_functions=['foo'])

    def bar(*args: Any, **kwargs: Any) -> int:
        return 1

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'bar': bar})
    inner = exc_info.value.exception()
    assert isinstance(inner, KeyError)
    # KeyError wraps the message in quotes
    assert inner.args[0] == snapshot('"External function \'foo\' not found"')


def test_external_function_exception_caught_by_try_except():
    """Test that exceptions from external functions can be caught by try/except."""
    code = """
try:
    fail()
except ValueError:
    caught = True
caught
"""
    m = pydantic_monty.Monty(code, external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> None:
        raise ValueError('caught error')

    result = m.run(external_functions={'fail': fail})
    assert result == snapshot(True)


def test_external_function_exception_type_preserved():
    """Test that various exception types are correctly preserved."""
    m = pydantic_monty.Monty('fail()', external_functions=['fail'])

    def fail_type_error(*args: Any, **kwargs: Any) -> None:
        raise TypeError('type error message')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'fail': fail_type_error})
    inner = exc_info.value.exception()
    assert isinstance(inner, TypeError)
    assert inner.args[0] == snapshot('type error message')


@pytest.mark.parametrize(
    'exception_class,exception_name',
    [
        # ArithmeticError hierarchy
        (ZeroDivisionError, 'ZeroDivisionError'),
        (OverflowError, 'OverflowError'),
        (ArithmeticError, 'ArithmeticError'),
        # RuntimeError hierarchy
        (NotImplementedError, 'NotImplementedError'),
        (RecursionError, 'RecursionError'),
        (RuntimeError, 'RuntimeError'),
        # LookupError hierarchy
        (KeyError, 'KeyError'),
        (IndexError, 'IndexError'),
        (LookupError, 'LookupError'),
        # Other exceptions
        (ValueError, 'ValueError'),
        (TypeError, 'TypeError'),
        (AttributeError, 'AttributeError'),
        (NameError, 'NameError'),
        (AssertionError, 'AssertionError'),
    ],
)
def test_external_function_exception_hierarchy(exception_class: type[BaseException], exception_name: str):
    """Test that exception types in hierarchies are correctly preserved."""
    # Test that exception propagates with correct type
    m = pydantic_monty.Monty('fail()', external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> None:
        raise exception_class('test message')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'fail': fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, exception_class)


@pytest.mark.parametrize(
    'exception_class,parent_class,expected_result',
    [
        # ArithmeticError hierarchy
        (ZeroDivisionError, ArithmeticError, 'child'),
        (OverflowError, ArithmeticError, 'child'),
        # RuntimeError hierarchy
        (NotImplementedError, RuntimeError, 'child'),
        (RecursionError, RuntimeError, 'child'),
        # LookupError hierarchy
        (KeyError, LookupError, 'child'),
        (IndexError, LookupError, 'child'),
    ],
)
def test_external_function_exception_caught_by_parent(
    exception_class: type[BaseException], parent_class: type[BaseException], expected_result: str
):
    """Test that child exceptions can be caught by parent except handlers."""
    code = f"""
try:
    fail()
except {parent_class.__name__}:
    caught = 'parent'
except {exception_class.__name__}:
    caught = 'child'
caught
"""
    m = pydantic_monty.Monty(code, external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> None:
        raise exception_class('test')

    # Child exception should be caught by parent handler (which comes first)
    result = m.run(external_functions={'fail': fail})
    assert result == 'parent'


@pytest.mark.parametrize(
    'exception_class,expected_result',
    [
        (ZeroDivisionError, 'ZeroDivisionError'),
        (OverflowError, 'OverflowError'),
        (NotImplementedError, 'NotImplementedError'),
        (RecursionError, 'RecursionError'),
        (KeyError, 'KeyError'),
        (IndexError, 'IndexError'),
    ],
)
def test_external_function_exception_caught_specifically(exception_class: type[BaseException], expected_result: str):
    """Test that child exceptions can be caught by their specific handler."""
    code = f"""
try:
    fail()
except {exception_class.__name__}:
    caught = '{expected_result}'
caught
"""
    m = pydantic_monty.Monty(code, external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> None:
        raise exception_class('test')

    result = m.run(external_functions={'fail': fail})
    assert result == expected_result


def test_external_function_exception_in_expression():
    """Test exception from external function in an expression context."""
    m = pydantic_monty.Monty('1 + fail() + 2', external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> int:
        raise RuntimeError('mid-expression error')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'fail': fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, RuntimeError)
    assert inner.args[0] == snapshot('mid-expression error')


def test_external_function_exception_after_successful_call():
    """Test exception handling after a successful external call."""
    code = """
a = success()
b = fail()
a + b
"""
    m = pydantic_monty.Monty(code, external_functions=['success', 'fail'])

    def success(*args: Any, **kwargs: Any) -> int:
        return 10

    def fail(*args: Any, **kwargs: Any) -> int:
        raise ValueError('second call fails')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'success': success, 'fail': fail})
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('second call fails')


def test_external_function_exception_with_finally():
    """Test that finally block runs when external function raises."""
    code = """
finally_ran = False
try:
    fail()
except ValueError:
    pass
finally:
    finally_ran = True
finally_ran
"""
    m = pydantic_monty.Monty(code, external_functions=['fail'])

    def fail(*args: Any, **kwargs: Any) -> None:
        raise ValueError('error')

    result = m.run(external_functions={'fail': fail})
    assert result == snapshot(True)




------------------------------------------
File: crates/monty-python/tests/test_inputs.py
------------------------------------------

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_single_input():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': 42}) == snapshot(42)


def test_multiple_inputs():
    m = pydantic_monty.Monty('x + y + z', inputs=['x', 'y', 'z'])
    assert m.run(inputs={'x': 1, 'y': 2, 'z': 3}) == snapshot(6)


def test_input_used_in_expression():
    m = pydantic_monty.Monty('x * 2 + y', inputs=['x', 'y'])
    assert m.run(inputs={'x': 5, 'y': 3}) == snapshot(13)


def test_input_string():
    m = pydantic_monty.Monty('greeting + " " + name', inputs=['greeting', 'name'])
    assert m.run(inputs={'greeting': 'Hello', 'name': 'World'}) == snapshot('Hello World')


def test_input_list():
    m = pydantic_monty.Monty('data[0] + data[1]', inputs=['data'])
    assert m.run(inputs={'data': [10, 20]}) == snapshot(30)


def test_input_dict():
    m = pydantic_monty.Monty('config["a"] * config["b"]', inputs=['config'])
    assert m.run(inputs={'config': {'a': 3, 'b': 4}}) == snapshot(12)


def test_missing_input_raises():
    m = pydantic_monty.Monty('x + y', inputs=['x', 'y'])
    with pytest.raises(KeyError, match="Missing required input: 'y'"):
        m.run(inputs={'x': 1})


def test_all_inputs_missing_raises():
    m = pydantic_monty.Monty('x', inputs=['x'])
    with pytest.raises(TypeError, match='Missing required inputs'):
        m.run()


def test_no_inputs_declared_but_provided_raises():
    m = pydantic_monty.Monty('1 + 1')
    with pytest.raises(TypeError, match='No input variables declared but inputs dict was provided'):
        m.run(inputs={'x': 1})
        with pytest.raises(TypeError, match='No input variables declared but inputs dict was provided'):
            m.run(inputs={})


def test_inputs_order_independent():
    m = pydantic_monty.Monty('a - b', inputs=['a', 'b'])
    # Dict order shouldn't matter
    assert m.run(inputs={'b': 3, 'a': 10}) == snapshot(7)


def test_function_param_shadows_input():
    """Function parameter should shadow script input with the same name."""
    code = """
def foo(x):
    return x + 1

foo(x * 2)
"""
    m = pydantic_monty.Monty(code, inputs=['x'])
    # x=5, so foo(x * 2) = foo(10), and inside foo, x is 10 (not 5), so returns 11
    assert m.run(inputs={'x': 5}) == snapshot(11)


def test_function_param_shadows_input_multiple_params():
    """Multiple function parameters should all shadow their corresponding inputs."""
    code = """
def add(x, y):
    return x + y

add(x * 10, y * 100)
"""
    m = pydantic_monty.Monty(code, inputs=['x', 'y'])
    # x=2, y=3, so add(20, 300) should return 320
    assert m.run(inputs={'x': 2, 'y': 3}) == snapshot(320)


def test_input_accessible_outside_shadowing_function():
    """Script input should still be accessible outside the function that shadows it."""
    code = """
def double(x):
    return x * 2

result = double(10) + x
result
"""
    m = pydantic_monty.Monty(code, inputs=['x'])
    # double(10) = 20, x (input) = 5, so result = 25
    assert m.run(inputs={'x': 5}) == snapshot(25)


def test_function_param_shadows_input_with_default():
    """Function parameter with default should shadow script input when called with arg."""
    code = """
def foo(x=100):
    return x + 1

foo(x * 2)
"""
    m = pydantic_monty.Monty(code, inputs=['x'])
    # x=5, foo(10), inside foo x=10 (not 5 or 100), returns 11
    assert m.run(inputs={'x': 5}) == snapshot(11)


def test_function_uses_input_directly():
    """Function that doesn't shadow should still access the input."""
    code = """
def foo(y):
    return x + y

foo(10)
"""
    m = pydantic_monty.Monty(code, inputs=['x'])
    # x=5 (input), foo(10) with y=10, returns x + y = 5 + 10 = 15
    assert m.run(inputs={'x': 5}) == snapshot(15)




------------------------------------------
File: crates/monty-python/tests/test_limits.py
------------------------------------------

import multiprocessing
import os
import signal
import threading
import time
from types import FrameType

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_resource_limits_custom():
    limits = pydantic_monty.ResourceLimits(
        max_allocations=100,
        max_duration_secs=5.0,
        max_memory=1024,
        gc_interval=10,
        max_recursion_depth=500,
    )
    assert limits.get('max_allocations') == snapshot(100)
    assert limits.get('max_duration_secs') == snapshot(5.0)
    assert limits.get('max_memory') == snapshot(1024)
    assert limits.get('gc_interval') == snapshot(10)
    assert limits.get('max_recursion_depth') == snapshot(500)


def test_resource_limits_repr():
    limits = pydantic_monty.ResourceLimits(max_duration_secs=1.0)
    assert repr(limits) == snapshot("{'max_duration_secs': 1.0}")


def test_run_with_limits():
    m = pydantic_monty.Monty('1 + 1')
    limits = pydantic_monty.ResourceLimits(max_duration_secs=5.0)
    assert m.run(limits=limits) == snapshot(2)


def test_recursion_limit():
    code = """
def recurse(n):
    if n <= 0:
        return 0
    return 1 + recurse(n - 1)

recurse(10)
"""
    m = pydantic_monty.Monty(code)
    limits = pydantic_monty.ResourceLimits(max_recursion_depth=5)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(limits=limits)
    assert isinstance(exc_info.value.exception(), RecursionError)


def test_recursion_limit_ok():
    code = """
def recurse(n):
    if n <= 0:
        return 0
    return 1 + recurse(n - 1)

recurse(5)
"""
    m = pydantic_monty.Monty(code)
    limits = pydantic_monty.ResourceLimits(max_recursion_depth=100)
    assert m.run(limits=limits) == snapshot(5)


def test_allocation_limit():
    # Note: allocation counting may not trigger on all operations
    # Use a more aggressive allocation pattern
    code = """
result = []
for i in range(10000):
    result.append([i])  # Each append creates a new list
len(result)
"""
    m = pydantic_monty.Monty(code)
    limits = pydantic_monty.ResourceLimits(max_allocations=5)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(limits=limits)
    assert isinstance(exc_info.value.exception(), MemoryError)


def test_memory_limit():
    code = """
result = []
for i in range(1000):
    result.append('x' * 100)
len(result)
"""
    m = pydantic_monty.Monty(code)
    limits = pydantic_monty.ResourceLimits(max_memory=100)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(limits=limits)
    assert isinstance(exc_info.value.exception(), MemoryError)


def test_limits_with_inputs():
    m = pydantic_monty.Monty('x * 2', inputs=['x'])
    limits = pydantic_monty.ResourceLimits(max_duration_secs=5.0)
    assert m.run(inputs={'x': 21}, limits=limits) == snapshot(42)


def test_limits_wrong_type_raises_error():
    m = pydantic_monty.Monty('1 + 1')
    with pytest.raises(TypeError):
        m.run(limits={'max_allocations': 'not an int'})  # pyright: ignore[reportArgumentType]


def test_limits_none_value_allowed():
    m = pydantic_monty.Monty('1 + 1')
    # None is valid to explicitly disable a limit
    assert m.run(limits={'max_allocations': None}) == snapshot(2)  # pyright: ignore[reportArgumentType]


def test_signal_alarm_custom_error():
    """Test that custom signal handlers work during execution.

    The idea here is we run another thread which sends a signal to the current process after a delay
    then set up a signal handler to catch that signal and raise a custom exception.

    So while monty is running, we have to run the code to catch the signal, and propagate that exception.
    """
    code = """
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

fib(35)
"""
    m = pydantic_monty.Monty(code)

    def send_signal():
        time.sleep(0.1)
        os.kill(os.getpid(), signal.SIGINT)

    def raise_potato(signum: int, frame: FrameType | None) -> None:
        raise ValueError('potato')

    thread = threading.Thread(target=send_signal)
    thread.start()
    old_handler = signal.signal(signal.SIGINT, raise_potato)
    try:
        with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
            m.run()
        inner = exc_info.value.exception()
        assert isinstance(inner, ValueError)
        assert inner.args[0] == snapshot('potato')
    finally:
        thread.join()
        signal.signal(signal.SIGINT, old_handler)


def _send_sigint_after_delay(pid: int, delay: float) -> None:
    """Helper function to send SIGINT to a process after a delay."""
    time.sleep(delay)
    os.kill(pid, signal.SIGINT)


def test_keyboard_interrupt():
    """Test that KeyboardInterrupt is raised when SIGINT is sent during execution."""
    code = """
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

fib(35)
"""
    m = pydantic_monty.Monty(code)

    # Send SIGINT after a short delay using a separate process
    proc = multiprocessing.Process(target=_send_sigint_after_delay, args=(os.getpid(), 0.05))
    proc.start()
    try:
        raised_keyboard_interrupt = False
        try:
            m.run()
        except pydantic_monty.MontyRuntimeError as e:
            if isinstance(e.exception(), KeyboardInterrupt):
                raised_keyboard_interrupt = True

        assert raised_keyboard_interrupt, 'Expected KeyboardInterrupt to be raised'
    finally:
        proc.join()


def test_pow_memory_limit():
    """Large pow should fail when memory limit is set."""
    m = pydantic_monty.Monty('2 ** 10000000')
    limits = pydantic_monty.ResourceLimits(max_memory=1_000_000)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(limits=limits)
    assert isinstance(exc_info.value.exception(), MemoryError)


def test_lshift_memory_limit():
    """Large left shift should fail when memory limit is set."""
    m = pydantic_monty.Monty('1 << 10000000')
    limits = pydantic_monty.ResourceLimits(max_memory=1_000_000)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(limits=limits)
    assert isinstance(exc_info.value.exception(), MemoryError)


def test_mult_memory_limit():
    """Large multiplication should fail when memory limit is set."""
    # First create a large number, then try to square it
    code = """
big = 2 ** 4000000
result = big * big
"""
    m = pydantic_monty.Monty(code)
    limits = pydantic_monty.ResourceLimits(max_memory=1_000_000)
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(limits=limits)
    assert isinstance(exc_info.value.exception(), MemoryError)


def test_small_operations_within_limit():
    """Smaller operations should succeed even with limits."""
    m = pydantic_monty.Monty('2 ** 1000')
    limits = pydantic_monty.ResourceLimits(max_memory=1_000_000)
    result = m.run(limits=limits)
    assert result > 0




------------------------------------------
File: crates/monty-python/tests/test_os_access_compat.py
------------------------------------------

"""OSAccess compatibility tests.

These tests verify that OSAccess (Monty's virtual filesystem) behaves identically
to CPython's real filesystem operations. Each test runs twice - once with Monty
using OSAccess/MemoryFile and once with CPython using a real temp directory.

This ensures that code written for real filesystems works correctly in the
sandboxed Monty environment.
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any, TypeAlias

import pytest

from pydantic_monty import MemoryFile, Monty, OSAccess

# Type alias for nested tree structure (file content or nested dict).
# Using Any for the recursive dict value since Python's type system doesn't
# handle recursive types well without TypedDict or Protocol.
TreeDict: TypeAlias = 'dict[str, str | bytes | TreeDict]'


class CodeRunner(ABC):
    """Abstract interface for running Python code against a filesystem.

    Implementations provide either a virtual filesystem (Monty+OSAccess) or
    a real filesystem (CPython+temp directory) for compatibility testing.
    """

    @abstractmethod
    def write_file(self, path: str, content: str | bytes) -> None:
        """Add a file to the test filesystem setup.

        Args:
            path: Relative path for the file (e.g., 'test/file.txt')
            content: File content as string or bytes
        """

    @abstractmethod
    def run_code(self, code: str) -> Any:
        """Run Python code and return the result.

        The code can use Path('relative/path') and it will be resolved to the
        appropriate root (OSAccess root or temp directory).

        Args:
            code: Python code to execute

        Returns:
            The result of the last expression in the code

        Raises:
            Exception: If the code raises an exception
        """

    @abstractmethod
    def tree(self) -> TreeDict:
        """Return a dict tree of files and their contents.

        Returns:
            Nested dict where keys are file/dir names and values are:
            - str/bytes for file contents
            - dict for subdirectories
        """

    @abstractmethod
    def set_environ(self, environ: dict[str, str]) -> None:
        """Set environment variables for the test.

        Args:
            environ: Dictionary of environment variable names to values
        """


class MontyRunner(CodeRunner):
    """CodeRunner implementation using Monty with OSAccess virtual filesystem."""

    def __init__(self) -> None:
        self._files: list[MemoryFile] = []
        self._environ: dict[str, str] = {}
        self._os_access: OSAccess | None = None

    def write_file(self, path: str, content: str | bytes) -> None:
        # Use relative paths - OSAccess now supports them
        self._files.append(MemoryFile(path, content=content))
        # Reset OSAccess so it gets rebuilt with new files
        self._os_access = None

    def set_environ(self, environ: dict[str, str]) -> None:
        self._environ = environ
        # Reset OSAccess so it gets rebuilt with new environ
        self._os_access = None

    def _get_os_access(self) -> OSAccess:
        if self._os_access is None:
            self._os_access = OSAccess(self._files, environ=self._environ)
        return self._os_access

    def run_code(self, code: str) -> Any:
        # Prepend imports - OSAccess now handles relative paths
        wrapped_code = f'from pathlib import Path\nimport os\n{code}'
        m = Monty(wrapped_code)
        return m.run(os=self._get_os_access())

    def tree(self) -> TreeDict:
        result: TreeDict = {}

        def add_to_tree(tree: TreeDict, parts: list[str], content: str | bytes) -> None:
            if len(parts) == 1:
                tree[parts[0]] = content
            else:
                if parts[0] not in tree:
                    tree[parts[0]] = {}
                sub: Any = tree[parts[0]]
                if isinstance(sub, dict):
                    add_to_tree(sub, parts[1:], content)  # type: ignore[arg-type]

        # Build tree from all files
        for file in self._files:
            if file.deleted:
                continue
            path_parts = list(file.path.parts)
            content = file.read_content()
            add_to_tree(result, path_parts, content)

        return result


class CPythonRunner(CodeRunner):
    """CodeRunner implementation using CPython with a real temp directory."""

    def __init__(self, tmp_path: Path) -> None:
        self._root = tmp_path
        self._environ: dict[str, str] = {}

    def write_file(self, path: str, content: str | bytes) -> None:
        full_path = self._root / path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        if isinstance(content, bytes):
            full_path.write_bytes(content)
        else:
            full_path.write_text(content)

    def set_environ(self, environ: dict[str, str]) -> None:
        self._environ = environ

    def run_code(self, code: str) -> Any:
        import ast
        import types

        # Map absolute paths (starting with /) to the temp directory
        # This matches OSAccess behavior which normalizes relative paths to /
        root = self._root

        def rooted_path(p: str | Path) -> Path:
            path = Path(p)
            if path.is_absolute():
                # Absolute path - strip leading / and map to root
                return root / str(path).lstrip('/')
            else:
                # Relative path - prepend / then map to root
                return root / p

        # Create a mock os module with our environ
        mock_os = types.SimpleNamespace()
        mock_os.environ = self._environ

        def getenv(key: str, default: str | None = None) -> str | None:
            return self._environ.get(key, default)

        mock_os.getenv = getenv

        namespace: dict[str, Any] = {'Path': rooted_path, 'os': mock_os}
        exec(code, namespace)

        # Find the last expression result
        tree = ast.parse(code)
        if tree.body and isinstance(tree.body[-1], ast.Expr):
            last_expr = ast.Expression(tree.body[-1].value)
            compiled = compile(last_expr, '<string>', 'eval')
            return eval(compiled, namespace)
        return None

    def tree(self) -> TreeDict:
        def build_tree(path: Path) -> TreeDict:
            result: TreeDict = {}
            for item in sorted(path.iterdir()):
                if item.is_dir():
                    subtree = build_tree(item)
                    result[item.name] = subtree
                else:
                    # Try to read as text, fall back to bytes
                    try:
                        result[item.name] = item.read_text()
                    except UnicodeDecodeError:
                        result[item.name] = item.read_bytes()
            return result

        if not self._root.exists():
            return {}
        return build_tree(self._root)


@pytest.fixture(params=['monty', 'cpython'])
def runner(request: pytest.FixtureRequest, tmp_path: Path) -> CodeRunner:
    """Fixture that provides both Monty and CPython runners for comparison testing."""
    if request.param == 'monty':
        return MontyRunner()
    else:
        return CPythonRunner(tmp_path)


# =============================================================================
# Path Existence Tests
# =============================================================================


def test_path_exists_file(runner: CodeRunner) -> None:
    """Path.exists() returns True for existing files."""
    runner.write_file('test/file.txt', 'hello')
    result = runner.run_code("Path('/test/file.txt').exists()")
    assert result is True


def test_path_exists_directory(runner: CodeRunner) -> None:
    """Path.exists() returns True for directories."""
    runner.write_file('test/subdir/file.txt', 'hello')
    result = runner.run_code("Path('/test/subdir').exists()")
    assert result is True


def test_path_exists_missing(runner: CodeRunner) -> None:
    """Path.exists() returns False for non-existent paths."""
    result = runner.run_code("Path('/missing/file.txt').exists()")
    assert result is False


def test_path_is_file(runner: CodeRunner) -> None:
    """Path.is_file() returns True for files, False for directories."""
    runner.write_file('test/file.txt', 'hello')
    assert runner.run_code("Path('/test/file.txt').is_file()") is True
    assert runner.run_code("Path('/test').is_file()") is False


def test_path_is_dir(runner: CodeRunner) -> None:
    """Path.is_dir() returns True for directories, False for files."""
    runner.write_file('test/file.txt', 'hello')
    assert runner.run_code("Path('/test').is_dir()") is True
    assert runner.run_code("Path('/test/file.txt').is_dir()") is False


# =============================================================================
# Reading Files
# =============================================================================


def test_read_text(runner: CodeRunner) -> None:
    """Path.read_text() returns file content as string."""
    runner.write_file('data/hello.txt', 'hello world')
    result = runner.run_code("Path('/data/hello.txt').read_text()")
    assert result == 'hello world'


def test_read_bytes(runner: CodeRunner) -> None:
    """Path.read_bytes() returns file content as bytes."""
    runner.write_file('data/binary.bin', b'\x00\x01\x02\x03')
    result = runner.run_code("Path('/data/binary.bin').read_bytes()")
    assert result == b'\x00\x01\x02\x03'


def test_read_text_unicode(runner: CodeRunner) -> None:
    """Path.read_text() handles unicode content."""
    runner.write_file('unicode.txt', 'hello \u2603 world')
    result = runner.run_code("Path('/unicode.txt').read_text()")
    assert result == 'hello \u2603 world'


# =============================================================================
# Tree Verification
# =============================================================================


def test_tree_simple(runner: CodeRunner) -> None:
    """tree() returns correct structure for simple files."""
    runner.write_file('a.txt', 'content a')
    runner.write_file('b.txt', 'content b')
    assert runner.tree() == {'a.txt': 'content a', 'b.txt': 'content b'}


def test_tree_nested(runner: CodeRunner) -> None:
    """tree() returns correct structure for nested directories."""
    runner.write_file('dir/subdir/file.txt', 'nested content')
    assert runner.tree() == {'dir': {'subdir': {'file.txt': 'nested content'}}}


def test_tree_mixed(runner: CodeRunner) -> None:
    """tree() handles mixed files and directories."""
    runner.write_file('root.txt', 'root')
    runner.write_file('dir/file.txt', 'in dir')
    expected = {'root.txt': 'root', 'dir': {'file.txt': 'in dir'}}
    assert runner.tree() == expected


# =============================================================================
# Stat Operations
# =============================================================================


def test_stat_size(runner: CodeRunner) -> None:
    """Path.stat().st_size returns correct file size."""
    runner.write_file('sized.txt', 'hello')
    result = runner.run_code("Path('/sized.txt').stat().st_size")
    assert result == 5


def test_stat_size_unicode(runner: CodeRunner) -> None:
    """Path.stat().st_size returns byte size for unicode content."""
    # Unicode snowman is 3 bytes in UTF-8
    runner.write_file('unicode.txt', '\u2603')
    result = runner.run_code("Path('/unicode.txt').stat().st_size")
    assert result == 3


# =============================================================================
# Directory Listing
# =============================================================================


def test_iterdir(runner: CodeRunner) -> None:
    """Path.iterdir() lists directory contents.

    Note: Monty returns filenames as strings while CPython returns Path objects
    with full paths. We normalize by getting .name (or using the string directly
    for Monty). Sorting is done in Python due to Monty limitations.
    """
    runner.write_file('dir/a.txt', 'a')
    runner.write_file('dir/b.txt', 'b')
    runner.write_file('dir/subdir/c.txt', 'c')
    # Get filenames - Monty returns strings, CPython returns Paths with full path
    # Use list() to collect, then sort in Python
    result = runner.run_code("list(Path('/dir').iterdir())")
    # Normalize: Monty gives strings, CPython gives Paths
    if isinstance(result[0], str):
        names = result  # Monty: already filenames
    else:
        names = [p.name for p in result]  # CPython: extract name from Path
    assert sorted(names) == ['a.txt', 'b.txt', 'subdir']


# =============================================================================
# Error Cases - FileNotFoundError
# =============================================================================


def test_read_text_file_not_found(runner: CodeRunner) -> None:
    """Path.read_text() raises FileNotFoundError for missing files."""
    result = runner.run_code("""
result = None
try:
    Path('/missing.txt').read_text()
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_read_bytes_file_not_found(runner: CodeRunner) -> None:
    """Path.read_bytes() raises FileNotFoundError for missing files."""
    result = runner.run_code("""
result = None
try:
    Path('/missing.bin').read_bytes()
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_stat_file_not_found(runner: CodeRunner) -> None:
    """Path.stat() raises FileNotFoundError for missing files."""
    result = runner.run_code("""
result = None
try:
    Path('/missing.txt').stat()
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_iterdir_not_found(runner: CodeRunner) -> None:
    """Path.iterdir() raises FileNotFoundError for missing directories."""
    result = runner.run_code("""
result = None
try:
    list(Path('/missing_dir').iterdir())
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


# =============================================================================
# Error Cases - IsADirectoryError
# =============================================================================


def test_read_text_is_directory(runner: CodeRunner) -> None:
    """Path.read_text() raises IsADirectoryError when path is a directory."""
    runner.write_file('mydir/file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/mydir').read_text()
except IsADirectoryError as e:
    result = type(e).__name__
result
""")
    assert result == 'IsADirectoryError'


def test_read_bytes_is_directory(runner: CodeRunner) -> None:
    """Path.read_bytes() raises IsADirectoryError when path is a directory."""
    runner.write_file('mydir/file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/mydir').read_bytes()
except IsADirectoryError as e:
    result = type(e).__name__
result
""")
    assert result == 'IsADirectoryError'


# =============================================================================
# Error Cases - NotADirectoryError
# =============================================================================


def test_iterdir_not_a_directory(runner: CodeRunner) -> None:
    """Path.iterdir() raises NotADirectoryError when path is a file."""
    runner.write_file('file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    list(Path('/file.txt').iterdir())
except NotADirectoryError as e:
    result = type(e).__name__
result
""")
    assert result == 'NotADirectoryError'


# =============================================================================
# Error Cases - FileExistsError
# =============================================================================


def test_mkdir_file_exists(runner: CodeRunner) -> None:
    """Path.mkdir() raises FileExistsError when directory already exists."""
    runner.write_file('existing_dir/file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/existing_dir').mkdir()
except FileExistsError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileExistsError'


def test_mkdir_file_at_path(runner: CodeRunner) -> None:
    """Path.mkdir() raises FileExistsError when a file exists at the path."""
    runner.write_file('somefile.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/somefile.txt').mkdir()
except FileExistsError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileExistsError'


def test_mkdir_exist_ok_no_error(runner: CodeRunner) -> None:
    """Path.mkdir(exist_ok=True) doesn't raise when directory exists."""
    runner.write_file('existing_dir/file.txt', 'content')
    result = runner.run_code("""
Path('/existing_dir').mkdir(exist_ok=True)
'no error'
""")
    assert result == 'no error'


# =============================================================================
# Error Cases - mkdir parent not found
# =============================================================================


def test_mkdir_parent_not_found(runner: CodeRunner) -> None:
    """Path.mkdir() raises FileNotFoundError when parent doesn't exist."""
    result = runner.run_code("""
result = None
try:
    Path('/no/parent/here').mkdir()
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_mkdir_parents_creates_all(runner: CodeRunner) -> None:
    """Path.mkdir(parents=True) creates all parent directories."""
    result = runner.run_code("""
Path('/a/b/c/d').mkdir(parents=True)
Path('/a/b/c/d').is_dir()
""")
    assert result is True


# =============================================================================
# Error Cases - unlink
# =============================================================================


def test_unlink_file_not_found(runner: CodeRunner) -> None:
    """Path.unlink() raises FileNotFoundError for missing files."""
    result = runner.run_code("""
result = None
try:
    Path('/missing.txt').unlink()
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_unlink_is_directory(runner: CodeRunner) -> None:
    """Path.unlink() raises an error when path is a directory.

    Note: On macOS, CPython raises PermissionError for unlink() on directories,
    while Linux raises IsADirectoryError. OSAccess consistently raises IsADirectoryError.
    """
    runner.write_file('mydir/file.txt', 'content')
    # Use OSError as catch-all since PermissionError and IsADirectoryError are subclasses
    result = runner.run_code("""
result = None
try:
    Path('/mydir').unlink()
except OSError as e:
    result = type(e).__name__
result
""")
    # OSAccess raises IsADirectoryError, CPython on macOS raises PermissionError
    assert result in ('IsADirectoryError', 'PermissionError')


# =============================================================================
# Error Cases - rmdir
# =============================================================================


def test_rmdir_not_found(runner: CodeRunner) -> None:
    """Path.rmdir() raises FileNotFoundError for missing directories."""
    result = runner.run_code("""
result = None
try:
    Path('/missing_dir').rmdir()
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_rmdir_not_a_directory(runner: CodeRunner) -> None:
    """Path.rmdir() raises NotADirectoryError when path is a file."""
    runner.write_file('file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/file.txt').rmdir()
except NotADirectoryError as e:
    result = type(e).__name__
result
""")
    assert result == 'NotADirectoryError'


def test_rmdir_not_empty(runner: CodeRunner) -> None:
    """Path.rmdir() raises OSError when directory is not empty."""
    runner.write_file('nonempty/file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/nonempty').rmdir()
except OSError as e:
    result = type(e).__name__
result
""")
    assert result == 'OSError'


# =============================================================================
# Error Cases - rename
# =============================================================================


def test_rename_source_not_found(runner: CodeRunner) -> None:
    """Path.rename() raises FileNotFoundError when source doesn't exist."""
    result = runner.run_code("""
result = None
try:
    Path('/missing.txt').rename(Path('/new.txt'))
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


# =============================================================================
# Write Operations
# =============================================================================


def test_write_text_new_file(runner: CodeRunner) -> None:
    """Path.write_text() creates a new file and returns character count."""
    result = runner.run_code("""
count = Path('/new_file.txt').write_text('hello world')
(count, Path('/new_file.txt').read_text())
""")
    assert result == (11, 'hello world')


def test_write_text_overwrite(runner: CodeRunner) -> None:
    """Path.write_text() overwrites existing files."""
    runner.write_file('existing.txt', 'old content')
    result = runner.run_code("""
Path('/existing.txt').write_text('new content')
Path('/existing.txt').read_text()
""")
    assert result == 'new content'


def test_write_bytes_new_file(runner: CodeRunner) -> None:
    """Path.write_bytes() creates a new file and returns byte count."""
    result = runner.run_code("""
count = Path('/new_binary.bin').write_bytes(b'\\x00\\x01\\x02')
(count, Path('/new_binary.bin').read_bytes())
""")
    assert result == (3, b'\x00\x01\x02')


def test_write_text_parent_not_found(runner: CodeRunner) -> None:
    """Path.write_text() raises FileNotFoundError when parent doesn't exist."""
    result = runner.run_code("""
result = None
try:
    Path('/no/parent/file.txt').write_text('content')
except FileNotFoundError as e:
    result = type(e).__name__
result
""")
    assert result == 'FileNotFoundError'


def test_write_text_to_directory(runner: CodeRunner) -> None:
    """Path.write_text() raises IsADirectoryError when writing to a directory."""
    runner.write_file('mydir/file.txt', 'content')
    result = runner.run_code("""
result = None
try:
    Path('/mydir').write_text('content')
except IsADirectoryError as e:
    result = type(e).__name__
result
""")
    assert result == 'IsADirectoryError'


# =============================================================================
# Environment Variable Tests
# =============================================================================


def test_environ_key_access(runner: CodeRunner) -> None:
    """os.environ['KEY'] returns the value for existing keys."""
    runner.set_environ({'MY_VAR': 'my_value'})
    result = runner.run_code("os.environ['MY_VAR']")
    assert result == 'my_value'


def test_environ_get_method(runner: CodeRunner) -> None:
    """os.environ.get() returns the value for existing keys."""
    runner.set_environ({'MY_VAR': 'my_value'})
    result = runner.run_code("os.environ.get('MY_VAR')")
    assert result == 'my_value'


def test_environ_get_missing_with_default(runner: CodeRunner) -> None:
    """os.environ.get() returns default for missing keys."""
    runner.set_environ({})
    result = runner.run_code("os.environ.get('MISSING', 'fallback')")
    assert result == 'fallback'


def test_environ_missing_key_raises_keyerror(runner: CodeRunner) -> None:
    """os.environ['MISSING'] raises KeyError with consistent message."""
    runner.set_environ({})
    result = runner.run_code("""
result = None
try:
    os.environ['NONEXISTENT_KEY']
except KeyError as e:
    result = str(e)
result
""")
    # Both Monty and CPython should produce the same KeyError message format
    assert result == "'NONEXISTENT_KEY'"




------------------------------------------
File: crates/monty-python/tests/test_os_access_raw.py
------------------------------------------

"""Tests for AbstractFileSystem implementation.

These tests verify that AbstractFileSystem can be subclassed to provide
a virtual filesystem that Monty code can interact with via Path methods.
"""

from pathlib import PurePosixPath

import pytest
from inline_snapshot import snapshot

import pydantic_monty
from pydantic_monty import AbstractOS, StatResult


class TestOS(AbstractOS):
    """A simple in-memory filesystem for testing."""

    __test__ = False

    def __init__(self) -> None:
        self.files: dict[str, bytes] = {}
        self.directories: set[str] = {'/'}

    def _ensure_parent_exists(self, path: str) -> None:
        """Ensure all parent directories exist."""
        parts = path.rstrip('/').split('/')
        for i in range(1, len(parts)):
            parent = '/'.join(parts[:i]) or '/'
            self.directories.add(parent)

    def path_exists(self, path: PurePosixPath) -> bool:
        p = str(path)
        return p in self.files or p in self.directories

    def path_is_file(self, path: PurePosixPath) -> bool:
        return str(path) in self.files

    def path_is_dir(self, path: PurePosixPath) -> bool:
        return str(path) in self.directories

    def path_is_symlink(self, path: PurePosixPath) -> bool:
        return False  # No symlink support in this simple implementation

    def path_read_text(self, path: PurePosixPath) -> str:
        p = str(path)
        if p not in self.files:
            raise FileNotFoundError(f'No such file: {p}')
        return self.files[p].decode('utf-8')

    def path_read_bytes(self, path: PurePosixPath) -> bytes:
        p = str(path)
        if p not in self.files:
            raise FileNotFoundError(f'No such file: {p}')
        return self.files[p]

    def path_write_text(self, path: PurePosixPath, data: str) -> int:
        p = str(path)
        self._ensure_parent_exists(p)
        self.files[p] = data.encode('utf-8')
        return len(data)

    def path_write_bytes(self, path: PurePosixPath, data: bytes) -> int:
        p = str(path)
        self._ensure_parent_exists(p)
        self.files[p] = data
        return len(data)

    def path_mkdir(self, path: PurePosixPath, parents: bool, exist_ok: bool) -> None:
        p = str(path)
        if p in self.directories:
            if not exist_ok:
                raise FileExistsError(f'Directory exists: {p}')
            return
        if parents:
            self._ensure_parent_exists(p)
        self.directories.add(p)

    def path_unlink(self, path: PurePosixPath) -> None:
        p = str(path)
        if p not in self.files:
            raise FileNotFoundError(f'No such file: {p}')
        del self.files[p]

    def path_rmdir(self, path: PurePosixPath) -> None:
        p = str(path)
        if p not in self.directories:
            raise FileNotFoundError(f'No such directory: {p}')
        # Check if directory is empty
        for f in self.files:
            if f.startswith(p + '/'):
                raise OSError(f'Directory not empty: {p}')
        for d in self.directories:
            if d != p and d.startswith(p + '/'):
                raise OSError(f'Directory not empty: {p}')
        self.directories.remove(p)

    def path_iterdir(self, path: PurePosixPath) -> list[PurePosixPath]:
        p = str(path)
        if p not in self.directories:
            raise FileNotFoundError(f'No such directory: {p}')
        result: list[PurePosixPath] = []
        prefix = p.rstrip('/') + '/'
        seen: set[str] = set()
        for f in self.files:
            if f.startswith(prefix):
                # Get immediate child name
                rest = f[len(prefix) :]
                child = rest.split('/')[0]
                if child and child not in seen:
                    seen.add(child)
                    result.append(PurePosixPath(prefix + child))
        for d in self.directories:
            if d.startswith(prefix) and d != p:
                rest = d[len(prefix) :]
                child = rest.split('/')[0]
                if child and child not in seen:
                    seen.add(child)
                    result.append(PurePosixPath(prefix + child))
        return sorted(result)

    def path_stat(self, path: PurePosixPath) -> StatResult:
        p = str(path)
        if p in self.files:
            return StatResult.file_stat(len(self.files[p]), 0o644, 0.0)
        elif p in self.directories:
            return StatResult.dir_stat(0o755, 0.0)
        else:
            raise FileNotFoundError(f'No such file or directory: {p}')

    def path_rename(self, path: PurePosixPath, target: PurePosixPath) -> None:
        p = str(path)
        t = str(target)
        if p in self.files:
            self._ensure_parent_exists(t)
            self.files[t] = self.files.pop(p)
        elif p in self.directories:
            self._ensure_parent_exists(t)
            self.directories.remove(p)
            self.directories.add(t)
            # Move all files under this directory
            prefix = p.rstrip('/') + '/'
            to_move = [(f, t + f[len(p) :]) for f in self.files if f.startswith(prefix)]
            for old, new in to_move:
                self.files[new] = self.files.pop(old)
        else:
            raise FileNotFoundError(f'No such file or directory: {p}')

    def path_resolve(self, path: PurePosixPath) -> str:
        # Simple implementation: just normalize the path
        p = str(path)
        parts: list[str] = []
        for part in p.split('/'):
            if part == '..':
                if parts:
                    parts.pop()
            elif part and part != '.':
                parts.append(part)
        return '/' + '/'.join(parts)

    def path_absolute(self, path: PurePosixPath) -> str:
        p = str(path)
        if p.startswith('/'):
            return p
        return '/' + p

    def getenv(self, key: str, default: str | None = None) -> str | None:
        # Simple virtual environment for testing
        env = {
            'TEST_VAR': 'test_value',
            'HOME': '/test/home',
        }
        return env.get(key, default)

    def get_environ(self) -> dict[str, str]:
        return {
            'TEST_VAR': 'test_value',
            'HOME': '/test/home',
        }


# =============================================================================
# Basic AbstractFileSystem tests
# =============================================================================


def test_abstract_filesystem_exists():
    """AbstractFileSystem.path_exists() works with os."""
    fs = TestOS()
    fs.files['/test.txt'] = b'hello'

    m = pydantic_monty.Monty('from pathlib import Path; Path("/test.txt").exists()')
    result = m.run(os=fs)

    assert result is True


def test_abstract_filesystem_exists_missing():
    """AbstractFileSystem.path_exists() returns False for missing files."""
    fs = TestOS()

    m = pydantic_monty.Monty('from pathlib import Path; Path("/missing.txt").exists()')
    result = m.run(os=fs)

    assert result is False


def test_abstract_filesystem_is_file():
    """AbstractFileSystem.path_is_file() distinguishes files from directories."""
    fs = TestOS()
    fs.files['/file.txt'] = b'content'
    fs.directories.add('/mydir')

    code = """
from pathlib import Path
(Path('/file.txt').is_file(), Path('/mydir').is_file())
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot((True, False))


def test_abstract_filesystem_is_dir():
    """AbstractFileSystem.path_is_dir() distinguishes directories from files."""
    fs = TestOS()
    fs.files['/file.txt'] = b'content'
    fs.directories.add('/mydir')

    code = """
from pathlib import Path
(Path('/file.txt').is_dir(), Path('/mydir').is_dir())
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot((False, True))


def test_abstract_filesystem_read_text():
    """AbstractFileSystem.path_read_text() returns file contents."""
    fs = TestOS()
    fs.files['/hello.txt'] = b'Hello, World!'

    m = pydantic_monty.Monty('from pathlib import Path; Path("/hello.txt").read_text()')
    result = m.run(os=fs)

    assert result == snapshot('Hello, World!')


def test_abstract_filesystem_read_text_missing():
    """AbstractFileSystem.path_read_text() raises FileNotFoundError for missing files."""
    fs = TestOS()

    m = pydantic_monty.Monty('from pathlib import Path; Path("/missing.txt").read_text()')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(os=fs)
    assert str(exc_info.value) == snapshot('FileNotFoundError: No such file: /missing.txt')
    assert isinstance(exc_info.value.exception(), FileNotFoundError)


def test_abstract_filesystem_read_bytes():
    """AbstractFileSystem.path_read_bytes() returns raw bytes."""
    fs = TestOS()
    fs.files['/data.bin'] = b'\x00\x01\x02\x03'

    m = pydantic_monty.Monty('from pathlib import Path; Path("/data.bin").read_bytes()')
    result = m.run(os=fs)

    assert result == snapshot(b'\x00\x01\x02\x03')


# =============================================================================
# stat() tests
# =============================================================================


def test_abstract_filesystem_stat_file():
    """AbstractFileSystem.path_stat() returns stat result for files."""
    fs = TestOS()
    fs.files['/file.txt'] = b'hello world'

    code = """
from pathlib import Path
s = Path('/file.txt').stat()
(s.st_size, s.st_mode)
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot((11, 0o100644))


def test_abstract_filesystem_stat_directory():
    """AbstractFileSystem.path_stat() returns stat result for directories."""
    fs = TestOS()
    fs.directories.add('/mydir')

    code = """
from pathlib import Path
s = Path('/mydir').stat()
s.st_mode
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot(0o040755)


def test_abstract_filesystem_stat_missing():
    """AbstractFileSystem.path_stat() raises FileNotFoundError for missing paths."""
    fs = TestOS()

    m = pydantic_monty.Monty('from pathlib import Path\nPath("/missing").stat()')
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(os=fs)

    assert str(exc_info.value) == snapshot('FileNotFoundError: No such file or directory: /missing')
    assert exc_info.value.display() == snapshot("""\
Traceback (most recent call last):
  File "main.py", line 2, in <module>
    Path("/missing").stat()
    ~~~~~~~~~~~~~~~~~~~~~~~
FileNotFoundError: No such file or directory: /missing\
""")


# =============================================================================
# iterdir() tests
# =============================================================================


def test_abstract_filesystem_iterdir():
    """AbstractFileSystem.path_iterdir() lists directory contents."""
    fs = TestOS()
    fs.directories.add('/mydir')
    fs.files['/mydir/a.txt'] = b'a'
    fs.files['/mydir/b.txt'] = b'b'
    fs.directories.add('/mydir/subdir')

    code = """
from pathlib import Path
list(Path('/mydir').iterdir())
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    # Result is a list of Path objects with child names joined to parent
    assert len(result) == 3
    names = sorted(str(p) for p in result)
    assert names == snapshot(['/mydir/a.txt', '/mydir/b.txt', '/mydir/subdir'])


def test_abstract_filesystem_iterdir_empty():
    """AbstractFileSystem.path_iterdir() returns empty list for empty directory."""
    fs = TestOS()
    fs.directories.add('/empty')

    code = """
from pathlib import Path
list(Path('/empty').iterdir())
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot([])


# =============================================================================
# resolve() and absolute() tests
# =============================================================================


def test_abstract_filesystem_resolve():
    """AbstractFileSystem.path_resolve() normalizes paths."""
    fs = TestOS()

    code = """
from pathlib import Path
str(Path('/foo/bar/../baz').resolve())
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot('/foo/baz')


def test_abstract_filesystem_absolute():
    """AbstractFileSystem.path_absolute() returns absolute path."""
    fs = TestOS()

    code = """
from pathlib import Path
str(Path('/already/absolute').absolute())
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot('/already/absolute')


def test_abstract_filesystem_getenv():
    """AbstractFileSystem.getenv() returns environment variable value."""
    fs = TestOS()

    code = """
import os
os.getenv('TEST_VAR')
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot('test_value')


def test_abstract_filesystem_getenv_missing():
    """AbstractFileSystem.getenv() returns None for missing variable."""
    fs = TestOS()

    code = """
import os
os.getenv('NONEXISTENT')
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result is None


def test_abstract_filesystem_getenv_default():
    """AbstractFileSystem.getenv() returns default for missing variable."""
    fs = TestOS()

    code = """
import os
os.getenv('NONEXISTENT', 'my_default')
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=fs)

    assert result == snapshot('my_default')


# =============================================================================
# file_stat / dir_stat helper tests
# =============================================================================


def test_file_stat_helper():
    """file_stat() creates a proper stat result."""
    stat = StatResult.file_stat(1024, 0o644, 1700000000.0)

    # Check it has the expected structure (10 fields)
    assert len(stat) == snapshot(10)
    # Index access: st_mode=0, st_size=6, st_mtime=8
    assert stat[0] == snapshot(0o100644)  # st_mode - file_stat adds file type bits
    assert stat[6] == snapshot(1024)  # st_size
    assert stat[8] == snapshot(1700000000.0)  # st_mtime


def test_dir_stat_helper():
    """dir_stat() creates a proper stat result for directories."""
    stat = StatResult.dir_stat(0o755, 1700000000.0)

    assert len(stat) == snapshot(10)
    # Index access: st_mode=0, st_size=6, st_mtime=8
    assert stat[0] == snapshot(0o040755)  # st_mode - dir_stat adds directory type bits
    assert stat[6] == snapshot(4096)  # st_size - directories have fixed size
    assert stat[8] == snapshot(1700000000.0)  # st_mtime


def test_path_monty_to_py():
    m = pydantic_monty.Monty('from pathlib import Path; Path("/foo/bar/thing.txt")')
    result = m.run()
    assert result == PurePosixPath('/foo/bar/thing.txt')
    assert type(result) is PurePosixPath


def test_path_py_to_monty():
    p = PurePosixPath('/foo/bar/thing.txt')
    m = pydantic_monty.Monty('f"type={type(p)} {p=}"', inputs=['p'])
    result = m.run(inputs={'p': p})
    assert result == snapshot("type=<class 'PosixPath'> p=PosixPath('/foo/bar/thing.txt')")




------------------------------------------
File: crates/monty-python/tests/test_os_access.py
------------------------------------------

"""Tests for OSAccess class functionality.

These tests verify the OSAccess class behavior - the high-level virtual filesystem
that can be passed to Monty.run(os=...). Most tests run Python code through Monty
to verify behavior as it would be used in practice.

For tests of the AbstractOS interface via custom subclasses, see test_os_access_raw.py.
"""

from pathlib import PurePosixPath
from typing import Any

import pytest
from inline_snapshot import snapshot

from pydantic_monty import CallbackFile, MemoryFile, Monty, MontyRuntimeError, OSAccess

# Alias for brevity in tests
P = PurePosixPath

# =============================================================================
# OSAccess Initialization & Validation
# =============================================================================


def test_non_absolute_path():
    """OSAccess rejects files with relative paths."""
    osa = OSAccess([MemoryFile('relative/path.txt', content='test')])
    assert osa.files[0].path.as_posix() == '/relative/path.txt'

    osa = OSAccess([MemoryFile('relative/path.txt', content='test')], root_dir='/foo/bar')
    assert osa.files[0].path.as_posix() == '/foo/bar/relative/path.txt'


def test_file_nested_within_file_rejected():
    """OSAccess rejects files nested within another file's path."""
    with pytest.raises(ValueError) as exc_info:
        OSAccess(
            [
                MemoryFile('/test/file.txt', content='outer'),
                MemoryFile('/test/file.txt/nested.txt', content='inner'),
            ]
        )
    assert str(exc_info.value) == snapshot(
        "Cannot put file MemoryFile(path=/test/file.txt/nested.txt, content='...', permissions=420) "
        "within sub-directory of file MemoryFile(path=/test/file.txt, content='...', permissions=420)"
    )


def test_empty_initialization():
    """OSAccess can be initialized with no files."""
    fs = OSAccess()
    result = Monty('from pathlib import Path; Path("/any/path").exists()').run(os=fs)
    assert result is False


def test_environ_parameter():
    """OSAccess accepts environ parameter for environment variables."""
    fs = OSAccess(environ={'MY_VAR': 'my_value'})
    result = Monty("import os; os.getenv('MY_VAR')").run(os=fs)
    assert result == snapshot('my_value')


# =============================================================================
# Path Existence Checks (via Monty)
# =============================================================================


def test_path_exists_file():
    """path_exists returns True for existing files."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/file.txt").exists()').run(os=fs)
    assert result is True


def test_path_exists_directory():
    """path_exists returns True for directories created by file paths."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/subdir").exists()').run(os=fs)
    assert result is True


def test_path_exists_nested():
    """path_exists handles deeply nested paths."""
    fs = OSAccess([MemoryFile('/a/b/c/d/file.txt', content='deep')])
    code = """
from pathlib import Path
(Path('/a').exists(), Path('/a/b').exists(), Path('/a/b/c').exists(), Path('/a/b/c/d').exists())
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot((True, True, True, True))


def test_path_exists_missing():
    """path_exists returns False for non-existent paths."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/other/path").exists()').run(os=fs)
    assert result is False


def test_path_is_file_for_file():
    """path_is_file returns True for files."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/file.txt").is_file()').run(os=fs)
    assert result is True


def test_path_is_file_for_directory():
    """path_is_file returns False for directories."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/subdir").is_file()').run(os=fs)
    assert result is False


def test_path_is_file_missing():
    """path_is_file returns False for non-existent paths."""
    fs = OSAccess()
    result = Monty('from pathlib import Path; Path("/missing").is_file()').run(os=fs)
    assert result is False


def test_path_is_dir_for_directory():
    """path_is_dir returns True for directories."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/subdir").is_dir()').run(os=fs)
    assert result is True


def test_path_is_dir_for_file():
    """path_is_dir returns False for files."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/file.txt").is_dir()').run(os=fs)
    assert result is False


def test_path_is_dir_missing():
    """path_is_dir returns False for non-existent paths."""
    fs = OSAccess()
    result = Monty('from pathlib import Path; Path("/missing").is_dir()').run(os=fs)
    assert result is False


def test_path_is_symlink_always_false():
    """path_is_symlink always returns False (no symlink support)."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    code = """
from pathlib import Path
(Path('/test/file.txt').is_symlink(), Path('/test').is_symlink(), Path('/missing').is_symlink())
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot((False, False, False))


# =============================================================================
# Reading Files (via Monty)
# =============================================================================


def test_read_text_string_content():
    """path_read_text returns string content directly."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello world')])
    result = Monty('from pathlib import Path; Path("/test/file.txt").read_text()').run(os=fs)
    assert result == snapshot('hello world')


def test_read_text_bytes_content_decoded():
    """path_read_text decodes bytes content as UTF-8."""
    fs = OSAccess([MemoryFile('/test/file.txt', content=b'bytes content')])
    result = Monty('from pathlib import Path; Path("/test/file.txt").read_text()').run(os=fs)
    assert result == snapshot('bytes content')


def test_read_bytes_bytes_content():
    """path_read_bytes returns bytes content directly."""
    fs = OSAccess([MemoryFile('/test/file.bin', content=b'\x00\x01\x02\x03')])
    result = Monty('from pathlib import Path; Path("/test/file.bin").read_bytes()').run(os=fs)
    assert result == snapshot(b'\x00\x01\x02\x03')


def test_read_bytes_string_content_encoded():
    """path_read_bytes encodes string content as UTF-8."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    result = Monty('from pathlib import Path; Path("/test/file.txt").read_bytes()').run(os=fs)
    assert result == snapshot(b'hello')


def test_read_text_file_not_found():
    """path_read_text raises FileNotFoundError for missing files."""
    fs = OSAccess()
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty('from pathlib import Path; Path("/missing.txt").read_text()').run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing.txt'")


def test_read_bytes_file_not_found():
    """path_read_bytes raises FileNotFoundError for missing files."""
    fs = OSAccess()
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty('from pathlib import Path; Path("/missing.bin").read_bytes()').run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing.bin'")


def test_read_text_is_a_directory():
    """path_read_text raises error for directories."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty('from pathlib import Path; Path("/test/subdir").read_text()').run(os=fs)
    # Monty reports this as OSError, not IsADirectoryError
    assert str(exc_info.value) == snapshot("IsADirectoryError: [Errno 21] Is a directory: '/test/subdir'")


def test_read_bytes_is_a_directory():
    """path_read_bytes raises error for directories."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty('from pathlib import Path; Path("/test/subdir").read_bytes()').run(os=fs)
    # Monty reports this as OSError, not IsADirectoryError
    assert str(exc_info.value) == snapshot("IsADirectoryError: [Errno 21] Is a directory: '/test/subdir'")


# =============================================================================
# Writing Files (via Monty)
# =============================================================================


def test_write_text_via_monty():
    """Path.write_text() creates a new file via Monty."""
    fs = OSAccess([MemoryFile('/test/existing.txt', content='existing')])

    code = """
from pathlib import Path
Path('/test/new.txt').write_text('new content')
"""
    result = Monty(code).run(os=fs)
    # write_text returns the number of bytes written
    assert result == snapshot(11)

    # Verify file was created
    assert fs.path_exists(P('/test/new.txt')) is True
    assert fs.path_read_text(P('/test/new.txt')) == 'new content'


def test_write_text_overwrite_via_monty():
    """Path.write_text() overwrites existing file via Monty."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='original')])

    code = """
from pathlib import Path
Path('/test/file.txt').write_text('updated')
"""
    Monty(code).run(os=fs)
    assert fs.path_read_text(P('/test/file.txt')) == 'updated'


def test_write_bytes_via_monty():
    """Path.write_bytes() creates a new file via Monty."""
    fs = OSAccess([MemoryFile('/test/existing.txt', content='existing')])

    code = """
from pathlib import Path
Path('/test/new.bin').write_bytes(b'binary data')
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(11)
    assert fs.path_read_bytes(P('/test/new.bin')) == b'binary data'


def test_write_text_parent_not_exists_via_monty():
    """Path.write_text() raises FileNotFoundError when parent doesn't exist via Monty."""
    fs = OSAccess()
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/no/parent/file.txt').write_text('test')").run(os=fs)
    assert str(exc_info.value) == snapshot(
        "FileNotFoundError: [Errno 2] No such file or directory: '/no/parent/file.txt'"
    )


def test_write_text_to_directory_via_monty():
    """Path.write_text() raises IsADirectoryError when writing to a directory via Monty."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/test/subdir').write_text('test')").run(os=fs)
    assert str(exc_info.value) == snapshot("IsADirectoryError: [Errno 21] Is a directory: '/test/subdir'")


# =============================================================================
# Writing Files (via direct API)
# =============================================================================


def test_write_text_new_file_direct():
    """path_write_text creates a new file via direct API."""
    fs = OSAccess([MemoryFile('/test/existing.txt', content='existing')])

    # Write a new file
    fs.path_write_text(P('/test/new.txt'), 'new content')

    # Verify it was created
    assert fs.path_exists(P('/test/new.txt')) is True
    assert fs.path_read_text(P('/test/new.txt')) == 'new content'


def test_write_text_overwrite_existing_direct():
    """path_write_text overwrites existing file content via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='original')])

    fs.path_write_text(P('/test/file.txt'), 'updated')
    assert fs.path_read_text(P('/test/file.txt')) == 'updated'


def test_write_bytes_new_file_direct():
    """path_write_bytes creates a new file via direct API."""
    fs = OSAccess([MemoryFile('/test/existing.txt', content='existing')])

    fs.path_write_bytes(P('/test/new.bin'), b'binary data')
    assert fs.path_read_bytes(P('/test/new.bin')) == b'binary data'


def test_write_bytes_overwrite_existing_direct():
    """path_write_bytes overwrites existing file content via direct API."""
    fs = OSAccess([MemoryFile('/test/file.bin', content=b'original')])

    fs.path_write_bytes(P('/test/file.bin'), b'updated')
    assert fs.path_read_bytes(P('/test/file.bin')) == b'updated'


def test_write_text_parent_not_exists_direct():
    """path_write_text raises FileNotFoundError when parent doesn't exist via direct API."""
    fs = OSAccess()
    with pytest.raises(FileNotFoundError) as exc_info:
        fs.path_write_text(P('/no/parent/file.txt'), 'test')
    assert str(exc_info.value) == snapshot("[Errno 2] No such file or directory: '/no/parent/file.txt'")


def test_write_text_to_directory_direct():
    """path_write_text raises IsADirectoryError when writing to a directory via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    with pytest.raises(IsADirectoryError) as exc_info:
        fs.path_write_text(P('/test/subdir'), 'test')
    assert str(exc_info.value) == snapshot("[Errno 21] Is a directory: '/test/subdir'")


# =============================================================================
# Directory Operations - mkdir (via Monty)
# =============================================================================


def test_mkdir_basic_via_monty():
    """Path.mkdir() creates a directory via Monty."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    code = """
from pathlib import Path
Path('/test/newdir').mkdir()
"""
    Monty(code).run(os=fs)
    assert fs.path_is_dir(P('/test/newdir')) is True


def test_mkdir_with_parents_via_monty():
    """Path.mkdir(parents=True) creates parent directories via Monty."""
    fs = OSAccess()

    code = """
from pathlib import Path
Path('/a/b/c/d').mkdir(parents=True)
"""
    Monty(code).run(os=fs)
    assert fs.path_is_dir(P('/a')) is True
    assert fs.path_is_dir(P('/a/b')) is True
    assert fs.path_is_dir(P('/a/b/c')) is True
    assert fs.path_is_dir(P('/a/b/c/d')) is True


def test_mkdir_exist_ok_true_via_monty():
    """Path.mkdir(exist_ok=True) doesn't raise for existing directory via Monty."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    code = """
from pathlib import Path
Path('/test/subdir').mkdir(exist_ok=True)
"""
    # Should not raise
    Monty(code).run(os=fs)
    assert fs.path_is_dir(P('/test/subdir')) is True


def test_mkdir_exist_ok_false_via_monty():
    """Path.mkdir() raises OSError (FileExistsError) for existing directory via Monty."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/test/subdir').mkdir()").run(os=fs)
    # Monty maps FileExistsError to OSError
    assert str(exc_info.value) == snapshot("FileExistsError: [Errno 17] File exists: '/test/subdir'")


def test_mkdir_parent_not_exists_via_monty():
    """Path.mkdir() raises FileNotFoundError when parent doesn't exist via Monty."""
    fs = OSAccess()

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/no/parent/dir').mkdir()").run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/no/parent/dir'")


# =============================================================================
# Directory Operations - mkdir (via direct API)
# =============================================================================


def test_mkdir_basic_direct():
    """path_mkdir creates a directory via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    fs.path_mkdir(P('/test/newdir'), parents=False, exist_ok=False)
    assert fs.path_is_dir(P('/test/newdir')) is True


def test_mkdir_with_parents_direct():
    """path_mkdir with parents=True creates parent directories via direct API."""
    fs = OSAccess()

    fs.path_mkdir(P('/a/b/c/d'), parents=True, exist_ok=False)
    assert fs.path_is_dir(P('/a')) is True
    assert fs.path_is_dir(P('/a/b')) is True
    assert fs.path_is_dir(P('/a/b/c')) is True
    assert fs.path_is_dir(P('/a/b/c/d')) is True


def test_mkdir_exist_ok_true_direct():
    """path_mkdir with exist_ok=True doesn't raise for existing directory via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    # Should not raise
    fs.path_mkdir(P('/test/subdir'), parents=False, exist_ok=True)
    assert fs.path_is_dir(P('/test/subdir')) is True


def test_mkdir_exist_ok_false_direct():
    """path_mkdir with exist_ok=False raises for existing directory via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    with pytest.raises(FileExistsError) as exc_info:
        fs.path_mkdir(P('/test/subdir'), parents=False, exist_ok=False)
    assert str(exc_info.value) == snapshot("[Errno 17] File exists: '/test/subdir'")


def test_mkdir_file_exists_direct():
    """path_mkdir raises FileExistsError when a file exists at the path via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    with pytest.raises(FileExistsError) as exc_info:
        fs.path_mkdir(P('/test/file.txt'), parents=False, exist_ok=False)
    assert str(exc_info.value) == snapshot("[Errno 17] File exists: '/test/file.txt'")


def test_mkdir_parent_not_exists_direct():
    """path_mkdir without parents raises FileNotFoundError when parent doesn't exist via direct API."""
    fs = OSAccess()

    with pytest.raises(FileNotFoundError) as exc_info:
        fs.path_mkdir(P('/no/parent/dir'), parents=False, exist_ok=False)
    assert str(exc_info.value) == snapshot("[Errno 2] No such file or directory: '/no/parent/dir'")


def test_mkdir_parent_is_file_direct():
    """path_mkdir raises NotADirectoryError when parent is a file via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    with pytest.raises(NotADirectoryError) as exc_info:
        fs.path_mkdir(P('/test/file.txt/subdir'), parents=True, exist_ok=False)
    assert str(exc_info.value) == snapshot("[Errno 20] Not a directory: '/test/file.txt/subdir'")


# =============================================================================
# Directory Operations - rmdir (via Monty)
# =============================================================================


def test_rmdir_empty_directory_via_monty():
    """Path.rmdir() removes an empty directory via Monty."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    fs.path_mkdir(P('/test/newdir'), parents=False, exist_ok=False)

    code = """
from pathlib import Path
Path('/test/newdir').rmdir()
"""
    Monty(code).run(os=fs)
    assert fs.path_exists(P('/test/newdir')) is False


def test_rmdir_non_empty_directory_via_monty():
    """Path.rmdir() raises OSError for non-empty directory via Monty."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/test/subdir').rmdir()").run(os=fs)
    assert str(exc_info.value) == snapshot("OSError: [Errno 39] Directory not empty: '/test/subdir'")


def test_rmdir_not_found_via_monty():
    """Path.rmdir() raises FileNotFoundError for non-existent path via Monty."""
    fs = OSAccess()

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/missing').rmdir()").run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing'")


def test_rmdir_file_not_directory_via_monty():
    """Path.rmdir() raises NotADirectoryError for files via Monty."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/test/file.txt').rmdir()").run(os=fs)
    assert str(exc_info.value) == snapshot("NotADirectoryError: [Errno 20] Not a directory: '/test/file.txt'")


# =============================================================================
# Directory Operations - rmdir (via direct API)
# =============================================================================


def test_rmdir_empty_directory_direct():
    """path_rmdir removes an empty directory via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    fs.path_mkdir(P('/test/newdir'), parents=False, exist_ok=False)
    fs.path_rmdir(P('/test/newdir'))
    assert fs.path_exists(P('/test/newdir')) is False


def test_rmdir_non_empty_directory_direct():
    """path_rmdir raises OSError for non-empty directory via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    with pytest.raises(OSError) as exc_info:
        fs.path_rmdir(P('/test/subdir'))
    assert str(exc_info.value) == snapshot("[Errno 39] Directory not empty: '/test/subdir'")


def test_rmdir_file_not_directory_direct():
    """path_rmdir raises NotADirectoryError for files via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    with pytest.raises(NotADirectoryError) as exc_info:
        fs.path_rmdir(P('/test/file.txt'))
    assert str(exc_info.value) == snapshot("[Errno 20] Not a directory: '/test/file.txt'")


def test_rmdir_not_found_direct():
    """path_rmdir raises FileNotFoundError for non-existent path via direct API."""
    fs = OSAccess()

    with pytest.raises(FileNotFoundError) as exc_info:
        fs.path_rmdir(P('/missing'))
    assert str(exc_info.value) == snapshot("[Errno 2] No such file or directory: '/missing'")


# =============================================================================
# Directory Operations - iterdir (via Monty)
# =============================================================================


def test_iterdir_list_contents():
    """path_iterdir lists directory contents."""
    fs = OSAccess(
        [
            MemoryFile('/test/a.txt', content='a'),
            MemoryFile('/test/b.txt', content='b'),
            MemoryFile('/test/subdir/c.txt', content='c'),
        ]
    )
    code = """
from pathlib import Path
[str(p) for p in Path('/test').iterdir()]
"""
    result = Monty(code).run(os=fs)
    # Result may be in any order, so sort in Python
    assert sorted(result) == snapshot(['/test/a.txt', '/test/b.txt', '/test/subdir'])


def test_iterdir_empty_directory_direct():
    """path_iterdir returns empty list for empty directory via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    fs.path_mkdir(P('/test/empty'), parents=False, exist_ok=False)

    result = fs.path_iterdir(P('/test/empty'))
    assert result == snapshot([])


def test_iterdir_not_a_directory_direct():
    """path_iterdir raises NotADirectoryError for files via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    with pytest.raises(NotADirectoryError) as exc_info:
        fs.path_iterdir(P('/test/file.txt'))
    assert str(exc_info.value) == snapshot("[Errno 20] Not a directory: '/test/file.txt'")


def test_iterdir_not_found():
    """path_iterdir raises FileNotFoundError for non-existent path."""
    fs = OSAccess()
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; list(Path('/missing').iterdir())").run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing'")


# =============================================================================
# File Operations - unlink (via Monty)
# =============================================================================


def test_unlink_file_via_monty():
    """Path.unlink() removes a file via Monty."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    code = """
from pathlib import Path
Path('/test/file.txt').unlink()
"""
    Monty(code).run(os=fs)
    assert fs.path_exists(P('/test/file.txt')) is False


def test_unlink_file_not_found_via_monty():
    """Path.unlink() raises FileNotFoundError for non-existent files via Monty."""
    fs = OSAccess()

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/missing.txt').unlink()").run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing.txt'")


def test_unlink_is_directory_via_monty():
    """Path.unlink() raises IsADirectoryError for directories via Monty."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/test/subdir').unlink()").run(os=fs)
    assert str(exc_info.value) == snapshot("IsADirectoryError: [Errno 21] Is a directory: '/test/subdir'")


# =============================================================================
# File Operations - unlink (via direct API)
# =============================================================================


def test_unlink_file_direct():
    """path_unlink removes a file via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])

    fs.path_unlink(P('/test/file.txt'))
    assert fs.path_exists(P('/test/file.txt')) is False


def test_unlink_file_not_found_direct():
    """path_unlink raises FileNotFoundError for non-existent files via direct API."""
    fs = OSAccess()

    with pytest.raises(FileNotFoundError) as exc_info:
        fs.path_unlink(P('/missing.txt'))
    assert str(exc_info.value) == snapshot("[Errno 2] No such file or directory: '/missing.txt'")


def test_unlink_is_directory_direct():
    """path_unlink raises IsADirectoryError for directories via direct API."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])

    with pytest.raises(IsADirectoryError) as exc_info:
        fs.path_unlink(P('/test/subdir'))
    assert str(exc_info.value) == snapshot("[Errno 21] Is a directory: '/test/subdir'")


# =============================================================================
# Stat Operations (via Monty)
# =============================================================================


def test_stat_file():
    """path_stat returns stat result for files with size and mode."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello world')])
    code = """
from pathlib import Path
s = Path('/test/file.txt').stat()
(s.st_size, s.st_mode & 0o777)
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot((11, 0o644))


def test_stat_file_custom_permissions():
    """path_stat returns custom file permissions."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello', permissions=0o755)])
    code = """
from pathlib import Path
s = Path('/test/file.txt').stat()
s.st_mode & 0o777
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(0o755)


def test_stat_directory():
    """path_stat returns stat result for directories."""
    fs = OSAccess([MemoryFile('/test/subdir/file.txt', content='hello')])
    code = """
from pathlib import Path
s = Path('/test/subdir').stat()
s.st_mode
"""
    result = Monty(code).run(os=fs)
    # Directory mode bits: 0o040000 (directory) | 0o755 (default perms) = 0o040755
    assert result == snapshot(0o040755)


def test_stat_file_not_found():
    """path_stat raises FileNotFoundError for non-existent paths."""
    fs = OSAccess()
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/missing').stat()").run(os=fs)
    assert str(exc_info.value) == snapshot("FileNotFoundError: [Errno 2] No such file or directory: '/missing'")


def test_stat_bytes_content_size():
    """path_stat calculates size correctly for bytes content."""
    fs = OSAccess([MemoryFile('/test/file.bin', content=b'\x00\x01\x02\x03\x04')])
    code = """
from pathlib import Path
Path('/test/file.bin').stat().st_size
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(5)


def test_stat_unicode_size():
    """path_stat calculates size as encoded UTF-8 bytes for string content."""
    # Unicode snowman is 3 bytes in UTF-8
    fs = OSAccess([MemoryFile('/test/file.txt', content='☃')])
    code = """
from pathlib import Path
Path('/test/file.txt').stat().st_size
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(3)


# =============================================================================
# Rename Operations (via Monty)
# =============================================================================


def test_rename_file_via_monty():
    """Path.rename() renames a file via Monty."""
    fs = OSAccess([MemoryFile('/test/old.txt', content='content')])

    code = """
from pathlib import Path
Path('/test/old.txt').rename(Path('/test/new.txt'))
"""
    Monty(code).run(os=fs)

    assert fs.path_exists(P('/test/old.txt')) is False
    assert fs.path_exists(P('/test/new.txt')) is True
    assert fs.path_read_text(P('/test/new.txt')) == 'content'


def test_rename_source_not_found_via_monty():
    """Path.rename() raises FileNotFoundError when source doesn't exist via Monty."""
    fs = OSAccess()

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/missing.txt').rename(Path('/new.txt'))").run(os=fs)
    assert str(exc_info.value) == snapshot(
        "FileNotFoundError: [Errno 2] No such file or directory: '/missing.txt' -> '/new.txt'"
    )


def test_rename_target_parent_not_found_via_monty():
    """Path.rename() raises FileNotFoundError when target parent doesn't exist via Monty."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='content')])

    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("from pathlib import Path; Path('/test/file.txt').rename(Path('/no/parent/file.txt'))").run(os=fs)
    assert str(exc_info.value) == snapshot(
        "FileNotFoundError: [Errno 2] No such file or directory: '/test/file.txt' -> '/no/parent/file.txt'"
    )


# =============================================================================
# Rename Operations (via direct API)
# =============================================================================


def test_rename_file_direct():
    """path_rename renames a file via direct API."""
    fs = OSAccess([MemoryFile('/test/old.txt', content='content')])

    fs.path_rename(P('/test/old.txt'), P('/test/new.txt'))

    assert fs.path_exists(P('/test/old.txt')) is False
    assert fs.path_exists(P('/test/new.txt')) is True
    assert fs.path_read_text(P('/test/new.txt')) == 'content'


def test_rename_source_not_found_direct():
    """path_rename raises FileNotFoundError when source doesn't exist via direct API."""
    fs = OSAccess()

    with pytest.raises(FileNotFoundError) as exc_info:
        fs.path_rename(P('/missing.txt'), P('/new.txt'))
    assert str(exc_info.value) == snapshot("[Errno 2] No such file or directory: '/missing.txt' -> '/new.txt'")


def test_rename_target_parent_not_found_direct():
    """path_rename raises FileNotFoundError when target parent doesn't exist via direct API."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='content')])

    with pytest.raises(FileNotFoundError) as exc_info:
        fs.path_rename(P('/test/file.txt'), P('/no/parent/file.txt'))
    assert str(exc_info.value) == snapshot(
        "[Errno 2] No such file or directory: '/test/file.txt' -> '/no/parent/file.txt'"
    )


def test_rename_directory_direct():
    """path_rename renames a directory via direct API."""
    fs = OSAccess([MemoryFile('/test/olddir/file.txt', content='content')])
    fs.path_mkdir(P('/test/newdir'), parents=False, exist_ok=False)

    fs.path_rename(P('/test/newdir'), P('/test/renamed'))
    assert fs.path_is_dir(P('/test/renamed')) is True


def test_rename_directory_non_empty_target_direct():
    """path_rename raises OSError when renaming directory to non-empty target via direct API."""
    fs = OSAccess(
        [
            MemoryFile('/test/src/a.txt', content='a'),
            MemoryFile('/test/dst/b.txt', content='b'),
        ]
    )

    with pytest.raises(OSError) as exc_info:
        fs.path_rename(P('/test/src'), P('/test/dst'))
    assert str(exc_info.value) == snapshot("[Errno 66] Directory not empty: '/test/src' -> '/test/dst'")


def test_rename_directory_updates_file_paths_direct():
    """path_rename updates paths of all files within renamed directory."""
    file1 = MemoryFile('/old/dir/file1.txt', content='one')
    file2 = MemoryFile('/old/dir/subdir/file2.txt', content='two')
    fs = OSAccess([file1, file2])

    # Create target parent and rename the directory
    fs.path_mkdir(P('/new'), parents=False, exist_ok=False)
    fs.path_rename(P('/old/dir'), P('/new/location'))

    # Verify files are accessible at new paths
    assert fs.path_read_text(P('/new/location/file1.txt')) == 'one'
    assert fs.path_read_text(P('/new/location/subdir/file2.txt')) == 'two'

    # Verify the AbstractFile objects have updated paths
    assert file1.path.as_posix() == '/new/location/file1.txt'
    assert file2.path.as_posix() == '/new/location/subdir/file2.txt'

    # Verify old paths no longer exist
    assert fs.path_exists(P('/old/dir')) is False
    assert fs.path_exists(P('/old/dir/file1.txt')) is False


# =============================================================================
# Path Resolution (via Monty)
# =============================================================================


def test_path_resolve_absolute():
    """path_resolve returns absolute path."""
    fs = OSAccess([MemoryFile('/test/file.txt', content='hello')])
    code = """
from pathlib import Path
str(Path('/test/file.txt').resolve())
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot('/test/file.txt')


def test_path_absolute_already_absolute():
    """path_absolute returns same path for already absolute path."""
    fs = OSAccess()
    code = """
from pathlib import Path
str(Path('/already/absolute').absolute())
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot('/already/absolute')


def test_path_absolute_relative():
    """path_absolute converts relative path to absolute."""
    fs = OSAccess()
    code = """
from pathlib import Path
str(Path('relative/path').absolute())
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot('/relative/path')


def test_path_resolve_same_as_absolute():
    """path_resolve behaves same as absolute (no symlinks in OSAccess)."""
    fs = OSAccess()
    code = """
from pathlib import Path
str(Path('relative').resolve()) == str(Path('relative').absolute())
"""
    result = Monty(code).run(os=fs)
    assert result is True


# =============================================================================
# Environment Variables (via Monty)
# =============================================================================


def test_getenv_existing_key():
    """getenv returns value for existing key."""
    fs = OSAccess(environ={'MY_VAR': 'my_value'})
    result = Monty("import os; os.getenv('MY_VAR')").run(os=fs)
    assert result == snapshot('my_value')


def test_getenv_missing_key():
    """getenv returns None for missing key."""
    fs = OSAccess(environ={'OTHER': 'value'})
    result = Monty("import os; os.getenv('MISSING')").run(os=fs)
    assert result is None


def test_getenv_missing_with_default():
    """getenv returns default for missing key when default provided."""
    fs = OSAccess(environ={})
    result = Monty("import os; os.getenv('MISSING', 'default_value')").run(os=fs)
    assert result == snapshot('default_value')


def test_getenv_multiple_vars():
    """getenv handles multiple environment variables."""
    fs = OSAccess(environ={'VAR1': 'value1', 'VAR2': 'value2', 'VAR3': 'value3'})
    code = """
import os
(os.getenv('VAR1'), os.getenv('VAR2'), os.getenv('VAR3'))
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(('value1', 'value2', 'value3'))


def test_get_environ_returns_dict():
    """os.environ returns the full environ dict."""
    fs = OSAccess(environ={'HOME': '/home/user', 'USER': 'testuser'})
    result = Monty('import os; os.environ').run(os=fs)
    assert result == snapshot({'HOME': '/home/user', 'USER': 'testuser'})


def test_get_environ_key_access():
    """os.environ['KEY'] returns the value."""
    fs = OSAccess(environ={'MY_VAR': 'my_value'})
    result = Monty("import os; os.environ['MY_VAR']").run(os=fs)
    assert result == snapshot('my_value')


def test_get_environ_key_missing_raises():
    """os.environ['MISSING'] raises KeyError."""
    fs = OSAccess(environ={})
    with pytest.raises(MontyRuntimeError) as exc_info:
        Monty("import os; os.environ['MISSING']").run(os=fs)
    assert str(exc_info.value) == snapshot('KeyError: MISSING')


def test_get_environ_get_method():
    """os.environ.get() works correctly."""
    fs = OSAccess(environ={'HOME': '/home/user'})
    result = Monty("import os; os.environ.get('HOME')").run(os=fs)
    assert result == snapshot('/home/user')


def test_get_environ_get_missing_with_default():
    """os.environ.get() returns default for missing key."""
    fs = OSAccess(environ={})
    result = Monty("import os; os.environ.get('MISSING', 'fallback')").run(os=fs)
    assert result == snapshot('fallback')


def test_get_environ_len():
    """len(os.environ) returns the number of env vars."""
    fs = OSAccess(environ={'A': '1', 'B': '2', 'C': '3'})
    result = Monty('import os; len(os.environ)').run(os=fs)
    assert result == snapshot(3)


def test_get_environ_contains():
    """'KEY' in os.environ tests membership."""
    fs = OSAccess(environ={'PRESENT': 'value'})
    code = """
import os
('PRESENT' in os.environ, 'ABSENT' in os.environ)
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot((True, False))


def test_get_environ_keys():
    """os.environ.keys() returns the keys."""
    fs = OSAccess(environ={'X': '1', 'Y': '2'})
    result = Monty('import os; list(os.environ.keys())').run(os=fs)
    assert set(result) == snapshot({'X', 'Y'})


def test_get_environ_values():
    """os.environ.values() returns the values."""
    fs = OSAccess(environ={'X': 'a', 'Y': 'b'})
    result = Monty('import os; list(os.environ.values())').run(os=fs)
    assert set(result) == snapshot({'a', 'b'})


def test_get_environ_items():
    """os.environ.items() returns key-value pairs."""
    fs = OSAccess(environ={'X': '1', 'Y': '2'})
    result = Monty('import os; list(os.environ.items())').run(os=fs)
    assert set(result) == snapshot({('X', '1'), ('Y', '2')})


def test_get_environ_empty():
    """os.environ returns empty dict when no environ provided."""
    fs = OSAccess()
    result = Monty('import os; os.environ').run(os=fs)
    assert result == snapshot({})


# =============================================================================
# MemoryFile Behavior
# =============================================================================


def test_memory_file_string_content():
    """MemoryFile stores and returns string content."""
    file = MemoryFile('/test/file.txt', content='hello')
    assert file.read_content() == snapshot('hello')
    assert file.path.as_posix() == snapshot('/test/file.txt')
    assert file.name == snapshot('file.txt')


def test_memory_file_bytes_content():
    """MemoryFile stores and returns bytes content."""
    file = MemoryFile('/test/file.bin', content=b'\x00\x01\x02')
    assert file.read_content() == snapshot(b'\x00\x01\x02')


def test_memory_file_custom_permissions():
    """MemoryFile accepts custom permissions."""
    file = MemoryFile('/test/exec.sh', content='#!/bin/bash', permissions=0o755)
    assert file.permissions == snapshot(0o755)


def test_memory_file_write_and_read():
    """MemoryFile supports writing and re-reading content."""
    file = MemoryFile('/test/file.txt', content='original')
    file.write_content('updated')
    assert file.read_content() == snapshot('updated')


def test_memory_file_delete():
    """MemoryFile can be marked as deleted."""
    file = MemoryFile('/test/file.txt', content='content')
    assert file.deleted is False
    file.delete()
    assert file.deleted is True


def test_memory_file_repr():
    """MemoryFile has useful repr for debugging."""
    file = MemoryFile('/test/file.txt', content='content')
    assert repr(file) == snapshot("MemoryFile(path=/test/file.txt, content='...', permissions=420)")


def test_memory_file_bytes_repr():
    """MemoryFile repr shows b'...' for bytes content."""
    file = MemoryFile('/test/file.bin', content=b'\x00')
    assert repr(file) == snapshot("MemoryFile(path=/test/file.bin, content=b'...', permissions=420)")


# =============================================================================
# CallbackFile Behavior
# =============================================================================


def test_callback_file_read():
    """CallbackFile calls read callback."""
    read_calls: list[PurePosixPath] = []

    def read_fn(path: PurePosixPath) -> str:
        read_calls.append(path)
        return f'content from {path}'

    def write_fn(path: PurePosixPath, content: str | bytes) -> None:
        pass

    file = CallbackFile('/test/file.txt', read=read_fn, write=write_fn)
    fs = OSAccess([file])

    result = Monty('from pathlib import Path; Path("/test/file.txt").read_text()').run(os=fs)
    assert result == snapshot('content from /test/file.txt')
    assert len(read_calls) == 1


def test_callback_file_write_direct():
    """CallbackFile calls write callback via direct API."""
    written: list[tuple[PurePosixPath, Any]] = []

    def read_fn(path: PurePosixPath) -> str:
        return ''

    def write_fn(path: PurePosixPath, content: str | bytes) -> None:
        written.append((path, content))

    file = CallbackFile('/test/file.txt', read=read_fn, write=write_fn)
    fs = OSAccess([file])

    # Use direct API since write_text not implemented in Monty
    fs.path_write_text(P('/test/file.txt'), 'new content')
    assert len(written) == 1
    assert written[0][1] == snapshot('new content')


def test_callback_file_custom_permissions():
    """CallbackFile accepts custom permissions."""
    file = CallbackFile(
        '/test/file.txt',
        read=lambda _: '',
        write=lambda _p, _c: None,
        permissions=0o700,
    )
    assert file.permissions == snapshot(0o700)


def test_callback_file_repr():
    """CallbackFile has useful repr for debugging."""
    file = CallbackFile('/test/file.txt', read=lambda _: '', write=lambda _, __: None)
    assert 'CallbackFile(path=/test/file.txt' in repr(file)


# =============================================================================
# Custom AbstractFile Implementation
# =============================================================================


class CustomFile:
    """Minimal custom AbstractFile implementation."""

    def __init__(self, path: str, content: str) -> None:
        self.path = PurePosixPath(path)
        self.name = self.path.name
        self.permissions = 0o644
        self.deleted = False
        self.content = content

    def read_content(self) -> str:
        return self.content

    def write_content(self, content: str | bytes) -> None:
        self.content = content if isinstance(content, str) else content.decode()

    def delete(self) -> None:
        self.deleted = True


def test_custom_abstract_file():
    """Custom AbstractFile implementation works with OSAccess."""
    custom = CustomFile('/test/custom.txt', 'custom content')
    fs = OSAccess([custom])

    result = Monty('from pathlib import Path; Path("/test/custom.txt").read_text()').run(os=fs)
    assert result == snapshot('custom content')


def test_custom_abstract_file_mixed_with_memory_file():
    """Custom AbstractFile can be mixed with MemoryFile."""
    custom = CustomFile('/test/custom.txt', 'from custom')
    memory = MemoryFile('/test/memory.txt', content='from memory')
    fs = OSAccess([custom, memory])

    code = """
from pathlib import Path
(Path('/test/custom.txt').read_text(), Path('/test/memory.txt').read_text())
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(('from custom', 'from memory'))


# =============================================================================
# Direct API Test (without Monty)
# =============================================================================


def test_os_access_direct_api():
    """OSAccess methods can be called directly without Monty."""
    fs = OSAccess(
        [
            MemoryFile('/test/file.txt', content='hello'),
            MemoryFile('/test/subdir/nested.txt', content='nested'),
        ]
    )

    # Test path_exists
    assert fs.path_exists(P('/test/file.txt')) is True
    assert fs.path_exists(P('/missing')) is False

    # Test path_is_file / path_is_dir
    assert fs.path_is_file(P('/test/file.txt')) is True
    assert fs.path_is_dir(P('/test/file.txt')) is False
    assert fs.path_is_dir(P('/test/subdir')) is True
    assert fs.path_is_file(P('/test/subdir')) is False

    # Test path_read_text / path_read_bytes
    assert fs.path_read_text(P('/test/file.txt')) == 'hello'
    assert fs.path_read_bytes(P('/test/file.txt')) == b'hello'

    # Test path_stat
    stat = fs.path_stat(P('/test/file.txt'))
    assert stat.st_size == 5

    # Test path_iterdir
    contents = fs.path_iterdir(P('/test'))
    assert sorted(contents) == snapshot([PurePosixPath('/test/file.txt'), PurePosixPath('/test/subdir')])

    # Test path_absolute
    assert fs.path_absolute(P('relative')) == '/relative'
    assert fs.path_absolute(P('/absolute')) == '/absolute'


# =============================================================================
# Edge Cases
# =============================================================================


def test_root_directory():
    """Root directory '/' is handled correctly."""
    fs = OSAccess([MemoryFile('/file.txt', content='root file')])
    code = """
from pathlib import Path
(Path('/').is_dir(), sorted([str(p) for p in Path('/').iterdir()]))
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot((True, ['/file.txt']))


def test_empty_file():
    """Empty file content is handled correctly."""
    fs = OSAccess([MemoryFile('/empty.txt', content='')])
    code = """
from pathlib import Path
(Path('/empty.txt').read_text(), Path('/empty.txt').stat().st_size)
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot(('', 0))


def test_large_nested_path():
    """Deeply nested paths are handled correctly."""
    fs = OSAccess([MemoryFile('/a/b/c/d/e/f/g/h/i/j/file.txt', content='deep')])
    code = """
from pathlib import Path
Path('/a/b/c/d/e/f/g/h/i/j/file.txt').read_text()
"""
    result = Monty(code).run(os=fs)
    assert result == snapshot('deep')


def test_special_characters_in_content():
    """Special characters in file content are handled correctly."""
    content = 'line1\nline2\ttab\r\nwindows'
    fs = OSAccess([MemoryFile('/special.txt', content=content)])
    result = Monty('from pathlib import Path; Path("/special.txt").read_text()').run(os=fs)
    assert result == snapshot('line1\nline2\ttab\r\nwindows')




------------------------------------------
File: crates/monty-python/tests/test_os_calls.py
------------------------------------------

"""Tests for OS function calls (Path methods) via the start/resume API.

These tests verify that Path filesystem methods correctly yield OS calls
with the right function name and arguments, and that return values from
the host are properly converted and used by Monty code.
"""

from pathlib import PurePosixPath
from typing import Any

import pytest
from inline_snapshot import snapshot

import pydantic_monty
from pydantic_monty import StatResult

# =============================================================================
# Basic OS call yielding
# =============================================================================


def test_path_exists_yields_oscall():
    """Path.exists() yields an OS call with correct function and path."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/test.txt").exists()')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.exists')
    assert result.args == snapshot((PurePosixPath('/tmp/test.txt'),))
    assert result.kwargs == snapshot({})


def test_path_stat_yields_oscall():
    """Path.stat() yields an OS call."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/etc/passwd").stat()')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.stat')
    assert result.args == snapshot((PurePosixPath('/etc/passwd'),))


def test_path_read_text_yields_oscall():
    """Path.read_text() yields an OS call."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/hello.txt").read_text()')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.read_text')
    assert result.args == snapshot((PurePosixPath('/tmp/hello.txt'),))


# =============================================================================
# Path construction and concatenation
# =============================================================================


def test_path_concatenation():
    """Path concatenation with / operator produces correct path string."""
    code = """
from pathlib import Path
base = Path('/home')
full = base / 'user' / 'documents' / 'file.txt'
full.exists()
"""
    m = pydantic_monty.Monty(code)
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.args == snapshot((PurePosixPath('/home/user/documents/file.txt'),))


# =============================================================================
# Resume with return values
# =============================================================================


def test_exists_resume():
    """Resuming exists() with bool returns it to Monty code."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/test.txt").exists()')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=True)

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output is True


def test_read_text_resume():
    """Resuming read_text() with string content returns it to Monty code."""
    code = """
from pathlib import Path
content = Path('/tmp/hello.txt').read_text()
'Content: ' + content
"""
    m = pydantic_monty.Monty(code)
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value='Hello, World!')

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot('Content: Hello, World!')


# =============================================================================
# stat() result round-trip (Python -> Monty -> Python)
# =============================================================================


def test_stat_resume_and_use_in_monty():
    """Resuming stat() with file_stat() allows Monty to access fields."""
    code = """
from pathlib import Path
info = Path('/tmp/file.txt').stat()
(info.st_mode, info.st_size, info[6])
"""
    m = pydantic_monty.Monty(code)
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    assert snapshot_result.function_name == snapshot('Path.stat')

    # Resume with a file_stat result - Monty accesses multiple fields
    result = snapshot_result.resume(return_value=StatResult.file_stat(1024, 0o100_644, 1234567890.0))

    assert isinstance(result, pydantic_monty.MontyComplete)
    # st_mode=0o100_644, st_size=1024, info[6]=st_size=1024
    assert result.output == snapshot((0o100_644, 1024, 1024))


def test_stat_result_returned_from_monty():
    """stat_result returned from Monty is accessible in Python."""
    code = """
from pathlib import Path
Path('/tmp/file.txt').stat()
"""
    m = pydantic_monty.Monty(code)
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=StatResult.file_stat(2048, 0o100_755, 1700000000.0))

    assert isinstance(result, pydantic_monty.MontyComplete)
    stat_result = result.output

    # Access attributes on the returned namedtuple
    assert stat_result.st_mode == snapshot(0o100_755)
    assert stat_result.st_size == snapshot(2048)
    assert stat_result.st_mtime == snapshot(1700000000.0)

    # Index access works too
    assert stat_result[0] == snapshot(0o100_755)  # st_mode
    assert stat_result[6] == snapshot(2048)  # st_size


def test_stat_result():
    """stat_result repr shows field names and values."""
    code = """
from pathlib import Path
Path('/tmp/file.txt').stat()
"""
    m = pydantic_monty.Monty(code)
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=StatResult.file_stat(512, 0o644, 0.0))

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert repr(result.output) == snapshot(
        'StatResult(st_mode=33188, st_ino=0, st_dev=0, st_nlink=1, st_uid=0, st_gid=0, st_size=512, st_atime=0.0, st_mtime=0.0, st_ctime=0.0)'
    )
    # Should be a tuple subclass
    assert len(result.output) == 10
    assert isinstance(result.output, tuple)


# =============================================================================
# Multiple OS calls in sequence
# =============================================================================


def test_multiple_path_calls():
    """Multiple Path method calls yield multiple OS calls in sequence."""
    code = """
from pathlib import Path
p = Path('/tmp/test.txt')
exists = p.exists()
is_file = p.is_file()
(exists, is_file)
"""
    m = pydantic_monty.Monty(code)

    # First call: exists()
    result = m.start()
    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.function_name == snapshot('Path.exists')

    # Resume exists() with True
    result = result.resume(return_value=True)
    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.function_name == snapshot('Path.is_file')

    # Resume is_file() with True
    result = result.resume(return_value=True)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot((True, True))


def test_conditional_path_calls():
    """Path calls inside conditionals work correctly."""
    code = """
from pathlib import Path
p = Path('/tmp/test.txt')
if p.exists():
    content = p.read_text()
else:
    content = 'not found'
content
"""
    m = pydantic_monty.Monty(code)

    # First call: exists()
    result = m.start()
    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.function_name == snapshot('Path.exists')

    # Resume exists() with True - should trigger read_text()
    result = result.resume(return_value=True)
    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.function_name == snapshot('Path.read_text')

    # Resume read_text() with content
    result = result.resume(return_value='file contents')
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot('file contents')


# =============================================================================
# OS call vs external function distinction
# =============================================================================


def test_os_call_vs_external_function():
    """OS calls have is_os_function=True, external functions have is_os_function=False."""
    # OS call
    m1 = pydantic_monty.Monty('from pathlib import Path; Path("/tmp").exists()')
    result1 = m1.start()
    assert isinstance(result1, pydantic_monty.MontySnapshot)
    assert result1.is_os_function is True

    # External function
    m2 = pydantic_monty.Monty('my_func()', external_functions=['my_func'])
    result2 = m2.start()
    assert isinstance(result2, pydantic_monty.MontySnapshot)
    assert result2.is_os_function is False


# =============================================================================
# os in run() method
# =============================================================================


def test_os_basic():
    """os receives function name and args, return value is used."""
    calls: list[Any] = []

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> bool:
        calls.append((function_name, args))
        return True

    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/test.txt").exists()')
    result = m.run(os=os_handler)

    assert result is True
    assert calls == snapshot([('Path.exists', (PurePosixPath('/tmp/test.txt'),))])


def test_os_stat():
    """os can return stat_result for Path.stat()."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'Path.stat':
            return StatResult.file_stat(1024, 0o644, 1700000000.0)
        return None

    code = """
from pathlib import Path
info = Path('/tmp/file.txt').stat()
(info.st_mode, info.st_size)
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=os_handler)

    assert result == snapshot((0o100_644, 1024))


def test_os_multiple_calls():
    """os is called for each OS operation."""
    calls: list[Any] = []

    def os_handler(
        function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None
    ) -> bool | str | None:
        calls.append(function_name)
        match function_name:
            case 'Path.exists':
                return True
            case 'Path.read_text':
                return 'file contents'
            case _:
                return None

    code = """
from pathlib import Path
p = Path('/tmp/test.txt')
if p.exists():
    result = p.read_text()
else:
    result = 'not found'
result
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=os_handler)

    assert result == snapshot('file contents')
    assert calls == snapshot(['Path.exists', 'Path.read_text'])


def test_os_not_provided_error():
    """Error is raised when OS call is made without os."""
    import pytest

    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp").exists()')
    # When no external functions and no os, run() takes the fast path
    # and OS calls raise NotImplementedError inside Monty
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run()
    assert str(exc_info.value) == snapshot(
        "NotImplementedError: OS function 'Path.exists' not implemented with standard execution"
    )


def test_os_not_provided_error_ext_func():
    """Error is raised when OS call is made without os."""
    import pytest

    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp").exists()', external_functions=['x'])
    # When no external functions and no os, run() takes the fast path
    # and OS calls raise NotImplementedError inside Monty
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(external_functions={'x': int})
    assert str(exc_info.value) == snapshot("NotImplementedError: OS function 'Path.exists' not implemented")


def test_not_callable():
    """Raise NotImplementedError inside inside monty if so os"""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/test.txt").exists()')

    with pytest.raises(TypeError, match="TypeError: 'int' object is not callable"):
        m.run(os=123)  # type: ignore


# =============================================================================
# os.getenv() tests
# =============================================================================


def test_os_getenv_yields_oscall():
    """os.getenv() yields an OS call with correct function and args."""
    m = pydantic_monty.Monty('import os; os.getenv("HOME")')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('os.getenv')
    assert result.args == snapshot(('HOME', None))


def test_os_getenv_with_default_yields_oscall():
    """os.getenv() with default yields an OS call with both args."""
    m = pydantic_monty.Monty('import os; os.getenv("MISSING", "fallback")')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('os.getenv')
    assert result.args == snapshot(('MISSING', 'fallback'))


def test_os_getenv_callback():
    """os.getenv() with os works correctly."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> str | None:
        if function_name == 'os.getenv':
            key, default = args
            env = {'HOME': '/home/user', 'USER': 'testuser'}
            return env.get(key, default)
        return None

    m = pydantic_monty.Monty('import os; os.getenv("HOME")')
    result = m.run(os=os_handler)
    assert result == snapshot('/home/user')


def test_os_getenv_callback_missing():
    """os.getenv() returns None for missing env var when no default."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> str | None:
        if function_name == 'os.getenv':
            key, default = args
            env: dict[str, str] = {}
            return env.get(key, default)
        return None

    m = pydantic_monty.Monty('import os; os.getenv("NONEXISTENT")')
    result = m.run(os=os_handler)
    assert result is None


def test_os_getenv_callback_with_default():
    """os.getenv() uses default when env var is missing."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> str | None:
        if function_name == 'os.getenv':
            key, default = args
            env: dict[str, str] = {}
            return env.get(key, default)
        return None

    m = pydantic_monty.Monty('import os; os.getenv("NONEXISTENT", "default_value")')
    result = m.run(os=os_handler)
    assert result == snapshot('default_value')


# =============================================================================
# os.environ tests
# =============================================================================


def test_os_environ_yields_oscall():
    """os.environ yields an OS call with correct function name."""
    m = pydantic_monty.Monty('import os; os.environ')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('os.environ')
    assert result.args == snapshot(())


def test_os_environ_key_access():
    """os.environ['KEY'] works correctly after getting environ dict."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {'HOME': '/home/user', 'USER': 'testuser'}
        return None

    m = pydantic_monty.Monty("import os; os.environ['HOME']")
    result = m.run(os=os_handler)
    assert result == snapshot('/home/user')


def test_os_environ_key_missing_raises():
    """os.environ['MISSING'] raises KeyError."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {}
        return None

    m = pydantic_monty.Monty("import os; os.environ['MISSING']")
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(os=os_handler)
    assert str(exc_info.value) == snapshot('KeyError: MISSING')


def test_os_environ_get_method():
    """os.environ.get() works correctly."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {'HOME': '/home/user'}
        return None

    m = pydantic_monty.Monty("import os; os.environ.get('HOME')")
    result = m.run(os=os_handler)
    assert result == snapshot('/home/user')


def test_os_environ_get_with_default():
    """os.environ.get() with default for missing key."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {}
        return None

    m = pydantic_monty.Monty("import os; os.environ.get('MISSING', 'default')")
    result = m.run(os=os_handler)
    assert result == snapshot('default')


def test_os_environ_len():
    """len(os.environ) returns correct count."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {'A': '1', 'B': '2', 'C': '3'}
        return None

    m = pydantic_monty.Monty('import os; len(os.environ)')
    result = m.run(os=os_handler)
    assert result == snapshot(3)


def test_os_environ_contains():
    """'KEY' in os.environ works correctly."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {'HOME': '/home/user'}
        return None

    m = pydantic_monty.Monty("import os; ('HOME' in os.environ, 'MISSING' in os.environ)")
    result = m.run(os=os_handler)
    assert result == snapshot((True, False))


def test_os_environ_keys():
    """os.environ.keys() returns keys."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {'HOME': '/home', 'USER': 'test'}
        return None

    m = pydantic_monty.Monty('import os; list(os.environ.keys())')
    result = m.run(os=os_handler)
    assert set(result) == snapshot({'HOME', 'USER'})


def test_os_environ_values():
    """os.environ.values() returns values."""

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        if function_name == 'os.environ':
            return {'A': '1', 'B': '2'}
        return None

    m = pydantic_monty.Monty('import os; list(os.environ.values())')
    result = m.run(os=os_handler)
    assert set(result) == snapshot({'1', '2'})


# =============================================================================
# Path write operations - write_text()
# =============================================================================


def test_path_write_text_yields_oscall():
    """Path.write_text() yields an OS call with correct function, path, and content."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/output.txt").write_text("hello world")')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.write_text')
    assert result.args == snapshot((PurePosixPath('/tmp/output.txt'), 'hello world'))


def test_path_write_text_resume():
    """Resuming write_text() with byte count returns it to Monty code."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/output.txt").write_text("hello")')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=5)  # write_text returns number of bytes written

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(5)


def test_path_write_text_callback():
    """Path.write_text() with os callback works correctly."""
    written_files: dict[str, str] = {}

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> int | None:
        if function_name == 'Path.write_text':
            path, content = args
            written_files[str(path)] = content
            return len(content.encode('utf-8'))
        return None

    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/test.txt").write_text("test content")')
    result = m.run(os=os_handler)

    assert result == snapshot(12)
    assert written_files == snapshot({'/tmp/test.txt': 'test content'})


# =============================================================================
# Path write operations - write_bytes()
# =============================================================================


def test_path_write_bytes_yields_oscall():
    """Path.write_bytes() yields an OS call with correct function, path, and bytes."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/data.bin").write_bytes(b"\\x00\\x01\\x02")')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.write_bytes')
    assert result.args == snapshot((PurePosixPath('/tmp/data.bin'), b'\x00\x01\x02'))


def test_path_write_bytes_resume():
    """Resuming write_bytes() with byte count returns it to Monty code."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/data.bin").write_bytes(b"abc")')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=3)

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(3)


# =============================================================================
# Path write operations - mkdir()
# =============================================================================


def test_path_mkdir_yields_oscall():
    """Path.mkdir() yields an OS call with correct function and path."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/newdir").mkdir()')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.mkdir')
    assert result.args == snapshot((PurePosixPath('/tmp/newdir'),))


def test_path_mkdir_with_parents_yields_oscall():
    """Path.mkdir(parents=True) yields an OS call with kwargs."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/a/b/c").mkdir(parents=True)')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.mkdir')
    assert result.args == snapshot((PurePosixPath('/tmp/a/b/c'),))
    assert result.kwargs == snapshot({'parents': True})


def test_path_mkdir_with_exist_ok_yields_oscall():
    """Path.mkdir(exist_ok=True) yields an OS call with kwargs."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/existing").mkdir(exist_ok=True)')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.mkdir')
    assert result.kwargs == snapshot({'exist_ok': True})


def test_path_mkdir_with_both_kwargs():
    """Path.mkdir(parents=True, exist_ok=True) yields an OS call with both kwargs."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/a/b").mkdir(parents=True, exist_ok=True)')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.kwargs == snapshot({'parents': True, 'exist_ok': True})


def test_path_mkdir_resume():
    """Resuming mkdir() with None returns correctly."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/newdir").mkdir()')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=None)

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output is None


# =============================================================================
# Path write operations - unlink()
# =============================================================================


def test_path_unlink_yields_oscall():
    """Path.unlink() yields an OS call with correct function and path."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/to_delete.txt").unlink()')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.unlink')
    assert result.args == snapshot((PurePosixPath('/tmp/to_delete.txt'),))


def test_path_unlink_resume():
    """Resuming unlink() with None returns correctly."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/file.txt").unlink()')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=None)

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output is None


# =============================================================================
# Path write operations - rmdir()
# =============================================================================


def test_path_rmdir_yields_oscall():
    """Path.rmdir() yields an OS call with correct function and path."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/empty_dir").rmdir()')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.rmdir')
    assert result.args == snapshot((PurePosixPath('/tmp/empty_dir'),))


def test_path_rmdir_resume():
    """Resuming rmdir() with None returns correctly."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/dir").rmdir()')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    result = snapshot_result.resume(return_value=None)

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output is None


# =============================================================================
# Path write operations - rename()
# =============================================================================


def test_path_rename_yields_oscall():
    """Path.rename() yields an OS call with source and target paths."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/old.txt").rename(Path("/tmp/new.txt"))')
    result = m.start()

    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.is_os_function is True
    assert result.function_name == snapshot('Path.rename')
    assert result.args == snapshot((PurePosixPath('/tmp/old.txt'), PurePosixPath('/tmp/new.txt')))


def test_path_rename_resume():
    """Resuming rename() returns the new path."""
    m = pydantic_monty.Monty('from pathlib import Path; Path("/tmp/old.txt").rename(Path("/tmp/new.txt"))')
    snapshot_result = m.start()

    assert isinstance(snapshot_result, pydantic_monty.MontySnapshot)
    # rename() returns None (the new Path is constructed by Monty)
    result = snapshot_result.resume(return_value=None)

    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output is None


# =============================================================================
# Write operations with os callback
# =============================================================================


def test_write_operations_callback():
    """Multiple write operations work with os callback."""
    operations: list[tuple[str, tuple[Any, ...]]] = []

    def os_handler(function_name: str, args: tuple[Any, ...], kwargs: dict[str, Any] | None = None) -> Any:
        operations.append((function_name, args))
        match function_name:
            case 'Path.mkdir':
                return None
            case 'Path.write_text':
                return len(args[1].encode('utf-8'))
            case 'Path.exists':
                return True
            case 'Path.read_text':
                return 'file content'
            case _:
                return None

    code = """
from pathlib import Path
Path('/tmp/mydir').mkdir()
Path('/tmp/mydir/file.txt').write_text('hello')
Path('/tmp/mydir/file.txt').read_text()
"""
    m = pydantic_monty.Monty(code)
    result = m.run(os=os_handler)

    assert result == snapshot('file content')
    assert operations == snapshot(
        [
            ('Path.mkdir', (PurePosixPath('/tmp/mydir'),)),
            ('Path.write_text', (PurePosixPath('/tmp/mydir/file.txt'), 'hello')),
            ('Path.read_text', (PurePosixPath('/tmp/mydir/file.txt'),)),
        ]
    )




------------------------------------------
File: crates/monty-python/tests/test_print.py
------------------------------------------

from typing import Callable, Literal

import pytest
from inline_snapshot import snapshot

import pydantic_monty

PrintCallback = Callable[[Literal['stdout'], str], None]


def make_print_collector() -> tuple[list[str], PrintCallback]:
    """Create a print callback that collects output into a list."""
    output: list[str] = []

    def callback(stream: Literal['stdout'], text: str) -> None:
        assert stream == 'stdout'
        output.append(text)

    return output, callback


def test_print_basic() -> None:
    m = pydantic_monty.Monty('print("hello")')
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('hello\n')


def test_print_multiple() -> None:
    code = """
print("line 1")
print("line 2")
"""
    m = pydantic_monty.Monty(code)
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('line 1\nline 2\n')


def test_print_with_values() -> None:
    m = pydantic_monty.Monty('print(1, 2, 3)')
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('1 2 3\n')


def test_print_with_sep() -> None:
    m = pydantic_monty.Monty('print(1, 2, 3, sep="-")')
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('1-2-3\n')


def test_print_with_end() -> None:
    m = pydantic_monty.Monty('print("hello", end="!")')
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('hello!')


def test_print_returns_none() -> None:
    m = pydantic_monty.Monty('print("test")')
    _, callback = make_print_collector()
    result = m.run(print_callback=callback)
    assert result is None


def test_print_empty() -> None:
    m = pydantic_monty.Monty('print()')
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('\n')


def test_print_with_limits() -> None:
    """Verify print_callback works together with resource limits."""
    m = pydantic_monty.Monty('print("with limits")')
    output, callback = make_print_collector()
    limits = pydantic_monty.ResourceLimits(max_duration_secs=5.0)
    m.run(print_callback=callback, limits=limits)
    assert ''.join(output) == snapshot('with limits\n')


def test_print_with_inputs() -> None:
    """Verify print_callback works together with inputs."""
    m = pydantic_monty.Monty('print(x)', inputs=['x'])
    output, callback = make_print_collector()
    m.run(inputs={'x': 42}, print_callback=callback)
    assert ''.join(output) == snapshot('42\n')


def test_print_in_loop() -> None:
    code = """
for i in range(3):
    print(i)
"""
    m = pydantic_monty.Monty(code)
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('0\n1\n2\n')


def test_print_mixed_types() -> None:
    m = pydantic_monty.Monty('print(1, "hello", True, None)')
    output, callback = make_print_collector()
    m.run(print_callback=callback)
    assert ''.join(output) == snapshot('1 hello True None\n')


def make_error_callback(error: Exception) -> PrintCallback:
    """Create a print callback that raises an exception."""

    def callback(stream: Literal['stdout'], text: str) -> None:
        raise error

    return callback


def test_print_callback_raises_value_error() -> None:
    """Test that ValueError raised in callback propagates correctly."""
    m = pydantic_monty.Monty('print("hello")')
    callback = make_error_callback(ValueError('callback error'))
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(print_callback=callback)
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('callback error')


def test_print_callback_raises_type_error() -> None:
    """Test that TypeError raised in callback propagates correctly."""
    m = pydantic_monty.Monty('print("hello")')
    callback = make_error_callback(TypeError('wrong type'))
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(print_callback=callback)
    inner = exc_info.value.exception()
    assert isinstance(inner, TypeError)
    assert inner.args[0] == snapshot('wrong type')


def test_print_callback_raises_in_function() -> None:
    """Test exception from callback when print is called inside a function."""
    code = """
def greet(name):
    print(f"Hello, {name}!")

greet("World")
"""
    m = pydantic_monty.Monty(code)
    callback = make_error_callback(RuntimeError('io error'))
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(print_callback=callback)
    inner = exc_info.value.exception()
    assert isinstance(inner, RuntimeError)
    assert inner.args[0] == snapshot('io error')


def test_print_callback_raises_in_nested_function() -> None:
    """Test exception from callback when print is called in nested functions."""
    code = """
def outer():
    def inner():
        print("from inner")
    inner()

outer()
"""
    m = pydantic_monty.Monty(code)
    callback = make_error_callback(ValueError('nested error'))
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(print_callback=callback)
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('nested error')


def test_print_callback_raises_in_loop() -> None:
    """Test exception from callback when print is called in a loop."""
    code = """
for i in range(5):
    print(i)
"""
    m = pydantic_monty.Monty(code)
    call_count = 0

    def callback(stream: Literal['stdout'], text: str) -> None:
        nonlocal call_count
        call_count += 1
        if call_count >= 3:
            raise ValueError('stopped at 3')

    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(print_callback=callback)
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('stopped at 3')
    assert call_count == snapshot(3)




------------------------------------------
File: crates/monty-python/tests/test_readme_examples.py
------------------------------------------

import pytest
from pytest_examples import CodeExample, EvalExample, find_examples

paths = (
    'crates/monty-python/README.md',
    'README.md',
)


@pytest.mark.parametrize('example', find_examples(*paths), ids=str)
def test_readme_examples(example: CodeExample, eval_example: EvalExample):
    eval_example.set_config(target_version='py310', ruff_ignore=['FA102'])
    eval_example.lint(example)
    opt_test = example.prefix_settings().get('test', '')
    if opt_test.startswith('skip'):
        pytest.skip(opt_test[4:].lstrip(' -') or 'running code skipped')
    if eval_example.update_examples:
        eval_example.run_print_update(example)
    else:
        eval_example.run_print_check(example)




------------------------------------------
File: crates/monty-python/tests/test_serialize.py
------------------------------------------

from dataclasses import dataclass
from typing import Any

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_monty_dump_load_roundtrip():
    m = pydantic_monty.Monty('x + 1', inputs=['x'])
    data = m.dump()

    assert isinstance(data, bytes)
    assert len(data) > 0

    m2 = pydantic_monty.Monty.load(data)
    assert m2.run(inputs={'x': 41}) == snapshot(42)


def test_monty_dump_load_preserves_script_name():
    m = pydantic_monty.Monty('1', script_name='custom.py')
    data = m.dump()

    m2 = pydantic_monty.Monty.load(data)
    assert repr(m2) == snapshot("Monty(<1 line of code>, script_name='custom.py')")


def test_monty_dump_load_preserves_inputs():
    m = pydantic_monty.Monty('x + y', inputs=['x', 'y'])
    data = m.dump()

    m2 = pydantic_monty.Monty.load(data)
    assert m2.run(inputs={'x': 1, 'y': 2}) == snapshot(3)


def test_monty_dump_load_preserves_external_functions():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    data = m.dump()

    m2 = pydantic_monty.Monty.load(data)
    result = m2.run(external_functions={'func': lambda: 42})
    assert result == snapshot(42)


def test_monty_load_invalid_data():
    with pytest.raises(ValueError) as exc_info:
        pydantic_monty.Monty.load(b'invalid data')
    assert str(exc_info.value) == snapshot('Hit the end of buffer, expected more data')


def test_progress_dump_load_roundtrip():
    m = pydantic_monty.Monty('func(1, 2)', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    data = progress.dump()
    assert isinstance(data, bytes)
    assert len(data) > 0

    progress2 = pydantic_monty.MontySnapshot.load(data)
    assert progress2.function_name == snapshot('func')
    assert progress2.args == snapshot((1, 2))
    assert progress2.kwargs == snapshot({})

    result = progress2.resume(return_value=100)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(100)


def test_progress_dump_load_preserves_script_name():
    m = pydantic_monty.Monty('func()', script_name='test.py', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    data = progress.dump()
    progress2 = pydantic_monty.MontySnapshot.load(data)
    assert progress2.script_name == snapshot('test.py')


def test_progress_dump_load_with_kwargs():
    m = pydantic_monty.Monty('func(a=1, b="hello")', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    data = progress.dump()
    progress2 = pydantic_monty.MontySnapshot.load(data)
    assert progress2.function_name == snapshot('func')
    assert progress2.args == snapshot(())
    assert progress2.kwargs == snapshot({'a': 1, 'b': 'hello'})


def test_progress_dump_after_resume_fails():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    progress.resume(return_value=1)

    with pytest.raises(RuntimeError) as exc_info:
        progress.dump()
    assert exc_info.value.args[0] == snapshot('Cannot dump progress that has already been resumed')


def test_progress_load_invalid_data():
    with pytest.raises(ValueError):
        pydantic_monty.MontySnapshot.load(b'invalid data')


def test_progress_dump_load_multiple_calls():
    m = pydantic_monty.Monty('a() + b()', external_functions=['a', 'b'])

    # First call
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('a')

    # Dump and load the state
    data = progress.dump()
    progress2 = pydantic_monty.MontySnapshot.load(data)

    # Resume with first return value
    progress3 = progress2.resume(return_value=10)
    assert isinstance(progress3, pydantic_monty.MontySnapshot)
    assert progress3.function_name == snapshot('b')

    # Dump and load again
    data2 = progress3.dump()
    progress4 = pydantic_monty.MontySnapshot.load(data2)

    # Resume with second return value
    result = progress4.resume(return_value=5)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(15)


def test_progress_load_with_print_callback():
    output: list[tuple[str, str]] = []

    def callback(stream: str, text: str) -> None:
        output.append((stream, text))

    m = pydantic_monty.Monty('print("before"); func(); print("after")', external_functions=['func'])
    progress = m.start(print_callback=callback)
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert output == snapshot([('stdout', 'before'), ('stdout', '\n')])

    # Dump and load with new callback
    data = progress.dump()
    output.clear()
    progress2 = pydantic_monty.MontySnapshot.load(data, print_callback=callback)

    result = progress2.resume(return_value=None)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert output == snapshot([('stdout', 'after'), ('stdout', '\n')])


def test_progress_load_without_print_callback():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    data = progress.dump()
    progress2 = pydantic_monty.MontySnapshot.load(data)

    result = progress2.resume(return_value=42)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(42)


@pytest.mark.parametrize(
    'code,expected',
    [
        ('1 + 1', 2),
        ('"hello"', 'hello'),
        ('[1, 2, 3]', [1, 2, 3]),
        ('{"a": 1}', {'a': 1}),
        ('True', True),
        ('None', None),
    ],
)
def test_monty_dump_load_various_outputs(code: str, expected: Any):
    m = pydantic_monty.Monty(code)
    data = m.dump()
    m2 = pydantic_monty.Monty.load(data)
    assert m2.run() == expected


def test_progress_dump_load_with_limits():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    limits = pydantic_monty.ResourceLimits(max_allocations=1000)
    progress = m.start(limits=limits)
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    data = progress.dump()
    progress2 = pydantic_monty.MontySnapshot.load(data)

    result = progress2.resume(return_value=99)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(99)


@dataclass
class Person:
    name: str
    age: int


def test_monty_load_dataclass():
    m = pydantic_monty.Monty('x', inputs=['x'])
    data = m.dump()

    m2 = pydantic_monty.Monty.load(data)
    m2.register_dataclass(Person)
    result = m2.run(inputs={'x': Person(name='Alice', age=30)})
    assert isinstance(result, Person)


def test_progress_dump_load_dataclass():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    data = progress.dump()
    assert isinstance(data, bytes)
    assert len(data) > 0

    progress2 = pydantic_monty.MontySnapshot.load(data, dataclass_registry=[Person])
    assert progress2.function_name == snapshot('func')
    assert progress2.args == snapshot(())
    assert progress2.kwargs == snapshot({})

    result = progress2.resume(return_value=Person(name='Alice', age=30))
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert isinstance(result.output, Person)
    assert result.output.name == snapshot('Alice')
    assert result.output.age == snapshot(30)




------------------------------------------
File: crates/monty-python/tests/test_start.py
------------------------------------------

from typing import Any

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_start_no_external_functions_returns_complete():
    m = pydantic_monty.Monty('1 + 2')
    result = m.start()
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(3)


def test_start_with_external_function_returns_progress():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    result = m.start()
    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.script_name == snapshot('main.py')
    assert result.function_name == snapshot('func')
    assert result.args == snapshot(())
    assert result.kwargs == snapshot({})


def test_start_custom_script_name():
    m = pydantic_monty.Monty('func()', script_name='custom.py', external_functions=['func'])
    result = m.start()
    assert isinstance(result, pydantic_monty.MontySnapshot)
    assert result.script_name == snapshot('custom.py')


def test_start_progress_resume_returns_complete():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('func')
    assert progress.args == snapshot(())
    assert progress.kwargs == snapshot({})

    result = progress.resume(return_value=42)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(42)


def test_start_progress_with_args():
    m = pydantic_monty.Monty('func(1, 2, 3)', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('func')
    assert progress.args == snapshot((1, 2, 3))
    assert progress.kwargs == snapshot({})


def test_start_progress_with_kwargs():
    m = pydantic_monty.Monty('func(a=1, b="two")', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('func')
    assert progress.args == snapshot(())
    assert progress.kwargs == snapshot({'a': 1, 'b': 'two'})


def test_start_progress_with_mixed_args_kwargs():
    m = pydantic_monty.Monty('func(1, 2, x="hello", y=True)', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('func')
    assert progress.args == snapshot((1, 2))
    assert progress.kwargs == snapshot({'x': 'hello', 'y': True})


def test_start_multiple_external_calls():
    m = pydantic_monty.Monty('a() + b()', external_functions=['a', 'b'])

    # First call
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('a')

    # Resume with first return value
    progress = progress.resume(return_value=10)
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('b')

    # Resume with second return value
    result = progress.resume(return_value=5)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(15)


def test_start_chain_of_external_calls():
    m = pydantic_monty.Monty('c() + c() + c()', external_functions=['c'])

    call_count = 0
    progress: pydantic_monty.MontySnapshot | pydantic_monty.MontyFutureSnapshot | pydantic_monty.MontyComplete = (
        m.start()
    )

    while isinstance(progress, pydantic_monty.MontySnapshot | pydantic_monty.MontyFutureSnapshot):
        assert isinstance(progress, pydantic_monty.MontySnapshot), 'Expected MontySnapshot'
        assert progress.function_name == snapshot('c')
        call_count += 1
        progress = progress.resume(return_value=call_count)

    assert isinstance(progress, pydantic_monty.MontyComplete)
    assert progress.output == snapshot(6)  # 1 + 2 + 3
    assert call_count == snapshot(3)


def test_start_with_inputs():
    m = pydantic_monty.Monty('process(x)', inputs=['x'], external_functions=['process'])
    progress = m.start(inputs={'x': 100})
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert progress.function_name == snapshot('process')
    assert progress.args == snapshot((100,))


def test_start_with_limits():
    m = pydantic_monty.Monty('1 + 2')
    limits = pydantic_monty.ResourceLimits(max_allocations=1000)
    result = m.start(limits=limits)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(3)


def test_start_with_print_callback():
    output: list[tuple[str, str]] = []

    def callback(stream: str, text: str) -> None:
        output.append((stream, text))

    m = pydantic_monty.Monty('print("hello")')
    result = m.start(print_callback=callback)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert output == snapshot([('stdout', 'hello'), ('stdout', '\n')])


def test_start_resume_cannot_be_called_twice():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    # First resume succeeds
    progress.resume(return_value=1)

    # Second resume should fail
    with pytest.raises(RuntimeError) as exc_info:
        progress.resume(return_value=2)
    assert exc_info.value.args[0] == snapshot('Progress already resumed')


def test_start_complex_return_value():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    result = progress.resume(return_value={'a': [1, 2, 3], 'b': {'nested': True}})
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot({'a': [1, 2, 3], 'b': {'nested': True}})


def test_start_resume_with_none():
    m = pydantic_monty.Monty('func()', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    result = progress.resume(return_value=None)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output is None


def test_progress_repr():
    m = pydantic_monty.Monty('func(1, x=2)', external_functions=['func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    assert repr(progress) == snapshot(
        "MontySnapshot(script_name='main.py', function_name='func', args=(1,), kwargs={'x': 2})"
    )


def test_complete_repr():
    m = pydantic_monty.Monty('42')
    result = m.start()
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert repr(result) == snapshot('MontyComplete(output=42)')


def test_start_can_reuse_monty_instance():
    m = pydantic_monty.Monty('func(x)', inputs=['x'], external_functions=['func'])

    # First run
    progress1 = m.start(inputs={'x': 1})
    assert isinstance(progress1, pydantic_monty.MontySnapshot)
    assert progress1.args == snapshot((1,))
    result1 = progress1.resume(return_value=10)
    assert isinstance(result1, pydantic_monty.MontyComplete)
    assert result1.output == snapshot(10)

    # Second run with different input
    progress2 = m.start(inputs={'x': 2})
    assert isinstance(progress2, pydantic_monty.MontySnapshot)
    assert progress2.args == snapshot((2,))
    result2 = progress2.resume(return_value=20)
    assert isinstance(result2, pydantic_monty.MontyComplete)
    assert result2.output == snapshot(20)


@pytest.mark.parametrize(
    'code,expected',
    [
        ('1', 1),
        ('"hello"', 'hello'),
        ('[1, 2, 3]', [1, 2, 3]),
        ('{"a": 1}', {'a': 1}),
        ('None', None),
        ('True', True),
    ],
)
def test_start_returns_complete_for_various_types(code: str, expected: Any):
    m = pydantic_monty.Monty(code)
    result = m.start()
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == expected


def test_start_progress_resume_with_exception_caught():
    """Test that resuming with an exception is caught by try/except."""
    code = """
try:
    result = external_func()
except ValueError:
    caught = True
caught
"""
    m = pydantic_monty.Monty(code, external_functions=['external_func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    # Resume with an exception using keyword argument
    result = progress.resume(exception=ValueError('test error'))
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(True)


def test_start_progress_resume_exception_propagates_uncaught():
    """Test that uncaught exceptions from resume() propagate to caller."""
    code = 'external_func()'
    m = pydantic_monty.Monty(code, external_functions=['external_func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    # Resume with an exception that won't be caught - wrapped in MontyRuntimeError
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        progress.resume(exception=ValueError('uncaught error'))
    inner = exc_info.value.exception()
    assert isinstance(inner, ValueError)
    assert inner.args[0] == snapshot('uncaught error')


def test_resume_none():
    code = 'external_func()'
    m = pydantic_monty.Monty(code, external_functions=['external_func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    result = progress.resume(return_value=None)
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot(None)


def test_invalid_resume_args():
    """Test that resume() with no args returns None."""
    code = 'external_func()'
    m = pydantic_monty.Monty(code, external_functions=['external_func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    # no args provided
    with pytest.raises(TypeError) as exc_info:
        progress.resume()  # pyright: ignore[reportCallIssue]
    assert exc_info.value.args[0] == snapshot('resume() accepts either return_value or exception, not both')

    # Both arguments provided
    with pytest.raises(TypeError) as exc_info:
        progress.resume(return_value=42, exception=ValueError('error'))  # pyright: ignore[reportCallIssue]
    assert exc_info.value.args[0] == snapshot('resume() accepts either return_value or exception, not both')

    # invalid kwarg provided
    with pytest.raises(TypeError) as exc_info:
        progress.resume(invalid_kwarg=42)  # pyright: ignore[reportCallIssue]
    assert exc_info.value.args[0] == snapshot('resume() accepts either return_value or exception, not both')


def test_start_progress_resume_exception_in_nested_try():
    """Test exception handling in nested try/except blocks."""
    code = """
outer_caught = False
finally_ran = False
try:
    try:
        external_func()
    except TypeError:
        pass  # Won't catch ValueError
    finally:
        finally_ran = True
except ValueError:
    outer_caught = True
(outer_caught, finally_ran)
"""
    m = pydantic_monty.Monty(code, external_functions=['external_func'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    result = progress.resume(exception=ValueError('propagates to outer'))
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == snapshot((True, True))




------------------------------------------
File: crates/monty-python/tests/test_threading.py
------------------------------------------

import os
import threading
import time
from functools import partial
from typing import cast

import pytest
from inline_snapshot import snapshot

import pydantic_monty

# I don't see a way to run these tests reliably on CI since github actions only has one CPU
# perhaps we could use ubuntu-24.04-arm once the repo is open source (it's currently not supported for private repos)
# https://docs.github.com/en/actions/reference/runners/github-hosted-runners
pytestmark = pytest.mark.skipif('CI' in os.environ, reason='on CI')


def test_parallel_exec():
    """Run code directly, run it in parallel, check that parallel execution not much slower."""
    code = """
x = 0
for i in range(200_000):
    x += 1
x
"""
    m = pydantic_monty.Monty(code)
    start = time.perf_counter()
    result = m.run()
    diff = time.perf_counter() - start
    assert result == 200_000

    threads = [threading.Thread(target=m.run) for _ in range(4)]
    start = time.perf_counter()
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    diff_parallel = time.perf_counter() - start
    # check that running the function in parallel 4 times is less than 1.5x slower than running it once
    time_multiple = diff_parallel / diff
    assert time_multiple < 1.5, 'Execution should not be slower in parallel'


def test_parallel_exec_print():
    """Run code directly, run it in parallel, check that parallel execution not much slower."""
    code = """
x = 0
for i in range(200_000):
    x += 1
print(x)
"""
    captured: list[str] = []

    def print_callback(file: str, content: str):
        captured.append(f'{file}: {content}')

    m = pydantic_monty.Monty(code)
    start = time.perf_counter()
    result = m.run(print_callback=print_callback)
    diff = time.perf_counter() - start
    assert result is None
    assert captured == snapshot(['stdout: 200000', 'stdout: \n'])

    threads = [threading.Thread(target=partial(m.run, print_callback=print_callback)) for _ in range(4)]
    start = time.perf_counter()
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    diff_parallel = time.perf_counter() - start
    # check that running the function in parallel 4 times is less than 1.5x slower than running it once
    time_multiple = diff_parallel / diff
    assert time_multiple < 1.5, 'Execution should not be slower in parallel'


def double(a: int) -> int:
    return a * 2


def test_parallel_exec_ext_functions():
    """Run code directly, run it in parallel, check that parallel execution not much slower."""
    code = """
x = 0
for i in range(100_000):
    x += 1
x = double(x)
for i in range(100_000):
    x += 1
x
"""
    m = pydantic_monty.Monty(code, external_functions=['double'])
    start = time.perf_counter()
    result = m.run(external_functions={'double': double})
    diff = time.perf_counter() - start
    assert result == 300_000

    threads = [threading.Thread(target=partial(m.run, external_functions={'double': double})) for _ in range(4)]
    start = time.perf_counter()
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    diff_parallel = time.perf_counter() - start
    # check that running the function in parallel 4 times is less than 1.5x slower than running it once
    time_multiple = diff_parallel / diff
    assert time_multiple < 1.5, 'Execution should not be slower in parallel'


def test_parallel_exec_start():
    """Run code directly, run it in parallel, check that parallel execution not much slower."""
    code = """
x = 0
for i in range(200_000):
    x += 1
double(x)
"""
    m = pydantic_monty.Monty(code, external_functions=['double'])
    start = time.perf_counter()
    progress = m.start()
    diff = time.perf_counter() - start
    assert isinstance(progress, pydantic_monty.MontySnapshot)

    threads = [threading.Thread(target=m.start) for _ in range(4)]
    start = time.perf_counter()
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    diff_parallel = time.perf_counter() - start
    # check that running the function in parallel 4 times is less than 1.5x slower than running it once
    time_multiple = diff_parallel / diff
    assert time_multiple < 1.5, 'Execution should not be slower in parallel'


def test_parallel_exec_start_resume():
    """Run code directly, run it in parallel, check that parallel execution not much slower."""
    code = """
x = double(1)
for i in range(200_000):
    x += 1
x
"""
    m = pydantic_monty.Monty(code, external_functions=['double'])
    progress = m.start()
    assert isinstance(progress, pydantic_monty.MontySnapshot)
    start = time.perf_counter()
    result = progress.resume(return_value=2)
    diff = time.perf_counter() - start
    assert isinstance(result, pydantic_monty.MontyComplete)
    assert result.output == 200_002

    progresses = cast(list[pydantic_monty.MontySnapshot], [m.start() for _ in range(4)])

    threads = [threading.Thread(target=partial(p.resume, return_value=2)) for p in progresses]
    start = time.perf_counter()
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    diff_parallel = time.perf_counter() - start
    # check that running the function in parallel 4 times is less than 1.5x slower than running it once
    time_multiple = diff_parallel / diff
    assert time_multiple < 1.5, 'Execution should not be slower in parallel'




------------------------------------------
File: crates/monty-python/tests/test_type_check.py
------------------------------------------

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_type_check_no_errors():
    """Type checking code with no errors returns None."""
    m = pydantic_monty.Monty('x = 1')
    assert m.type_check() is None


def test_type_check_with_errors():
    """Type checking code with type errors raises MontyTypingError."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    assert str(exc_info.value) == snapshot("""\
error[unsupported-operator]: Unsupported `+` operation
 --> main.py:1:1
  |
1 | "hello" + 1
  | -------^^^-
  | |         |
  | |         Has type `Literal[1]`
  | Has type `Literal["hello"]`
  |
info: rule `unsupported-operator` is enabled by default

""")


def test_type_check_function_return_type():
    """Type checking detects mismatched return types."""
    code = """
def foo() -> int:
    return "not an int"
"""
    m = pydantic_monty.Monty(code)
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    assert str(exc_info.value) == snapshot("""\
error[invalid-return-type]: Return type does not match returned value
 --> main.py:2:14
  |
2 | def foo() -> int:
  |              --- Expected `int` because of return type
3 |     return "not an int"
  |            ^^^^^^^^^^^^ expected `int`, found `Literal["not an int"]`
  |
info: rule `invalid-return-type` is enabled by default

""")


def test_type_check_undefined_variable():
    """Type checking detects undefined variables."""
    m = pydantic_monty.Monty('print(undefined_var)')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    assert str(exc_info.value) == snapshot("""\
error[unresolved-reference]: Name `undefined_var` used when not defined
 --> main.py:1:7
  |
1 | print(undefined_var)
  |       ^^^^^^^^^^^^^
  |
info: rule `unresolved-reference` is enabled by default

""")


def test_type_check_valid_function():
    """Type checking valid function returns None."""
    code = """
def add(a: int, b: int) -> int:
    return a + b

add(1, 2)
"""
    m = pydantic_monty.Monty(code)
    assert m.type_check() is None


def test_type_check_with_prefix_code():
    """Type checking with prefix code for input declarations."""
    m = pydantic_monty.Monty('result = x + 1')
    # Without prefix, x is undefined
    with pytest.raises(pydantic_monty.MontyTypingError):
        m.type_check()
    # With prefix declaring x as a variable, it should pass
    assert m.type_check(prefix_code='x = 0') is None


def test_type_check_display_invalid_format():
    """Invalid format string on display() raises ValueError."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    with pytest.raises(ValueError) as val_exc:
        exc_info.value.display('invalid_format')  # pyright: ignore[reportArgumentType]
    assert str(val_exc.value) == snapshot('Unknown format: invalid_format')


def test_type_check_display_concise_format():
    """Type checking with concise format via display()."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    assert exc_info.value.display('concise') == snapshot(
        'main.py:1:1: error[unsupported-operator] Operator `+` is not supported between objects of type `Literal["hello"]` and `Literal[1]`\n'
    )


# === MontyTypingError tests ===


def test_monty_typing_error_is_monty_error_subclass():
    """MontyTypingError is a subclass of MontyError."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    error = exc_info.value
    assert isinstance(error, pydantic_monty.MontyError)
    assert isinstance(error, Exception)


def test_monty_typing_error_repr():
    """MontyTypingError has proper repr with truncation."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    # repr truncates at 50 chars
    assert repr(exc_info.value) == snapshot("""\
MontyTypingError(error[unsupported-operator]: Unsupported `+` operation
 --> main.py:1:1
  |
1 | "hello" + 1
  | -------^^^-
  | |         |
  | |         Has type `Literal[1]`
  | Has type `Literal["hello"]`
  |
info: rule `unsupported-operator` is enabled by default

)\
""")


def test_monty_typing_error_caught_as_monty_error():
    """MontyTypingError can be caught as MontyError."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyError):
        m.type_check()


def test_monty_typing_error_display_default():
    """MontyTypingError display() defaults to full format."""
    m = pydantic_monty.Monty('"hello" + 1')
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        m.type_check()
    # Default display should match str()
    assert exc_info.value.display() == str(exc_info.value)


# === Constructor type_check parameter tests ===


def test_constructor_type_check_default_false():
    """Type checking is disabled by default in constructor."""
    # This should NOT raise during construction (type_check=False is default)
    m = pydantic_monty.Monty('"hello" + 1')
    # But we can still call type_check() manually later
    with pytest.raises(pydantic_monty.MontyTypingError):
        m.type_check()


def test_constructor_type_check_explicit_true():
    """Explicit type_check=True raises on type errors."""
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        pydantic_monty.Monty('"hello" + 1', type_check=True)
    assert str(exc_info.value) == snapshot("""\
error[unsupported-operator]: Unsupported `+` operation
 --> main.py:1:1
  |
1 | "hello" + 1
  | -------^^^-
  | |         |
  | |         Has type `Literal[1]`
  | Has type `Literal["hello"]`
  |
info: rule `unsupported-operator` is enabled by default

""")


def test_constructor_type_check_explicit_false():
    """Explicit type_check=False skips type checking during construction."""
    # This should NOT raise during construction
    m = pydantic_monty.Monty('"hello" + 1', type_check=False)
    # But we can still call type_check() manually later
    with pytest.raises(pydantic_monty.MontyTypingError):
        m.type_check()


def test_constructor_default_allows_run_with_inputs():
    """Default (type_check=False) allows running code that would fail type checking."""
    # Code with undefined variable - type checking would fail
    m = pydantic_monty.Monty('x + 1', inputs=['x'])
    # But runtime works fine with the input provided
    result = m.run(inputs={'x': 5})
    assert result == 6


def test_constructor_type_check_stubs():
    """type_check_stubs provides declarations for type checking."""
    # Without prefix, this would fail type checking (x is undefined)
    # Use assignment to define x, not just type annotation
    m = pydantic_monty.Monty('result = x + 1', type_check=True, type_check_stubs='x = 0')
    # Should construct successfully because prefix declares x
    assert m is not None


def test_constructor_type_check_stubs_with_external_function():
    """type_check_stubs can declare external function signatures."""
    # Define fetch as a function that takes a string and returns a string
    prefix = """
def fetch(url: str) -> str:
    return ''
"""
    m = pydantic_monty.Monty(
        'result = fetch("https://example.com")',
        external_functions=['fetch'],
        type_check=True,
        type_check_stubs=prefix,
    )
    assert m is not None


def test_constructor_type_check_stubs_invalid():
    """type_check_stubs with wrong types still catches errors."""
    # Prefix defines x as str, but code tries to use it with int addition
    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        pydantic_monty.Monty(
            'result: int = x + 1',
            type_check=True,
            type_check_stubs='x = "hello"',
        )
    # Should fail because str + int is invalid
    assert str(exc_info.value) == snapshot("""\
error[unsupported-operator]: Unsupported `+` operation
 --> main.py:1:15
  |
1 | result: int = x + 1
  |               -^^^-
  |               |   |
  |               |   Has type `Literal[1]`
  |               Has type `Literal["hello"]`
  |
info: rule `unsupported-operator` is enabled by default

""")


def test_inject_stubs_offset():
    type_definitions = """\
from typing import Any

Messages = list[dict[str, Any]]

async def call_llm(prompt: str, messages: Messages) -> str | Messages:
    ...

prompt: str = ''
"""

    code = """\
async def agent(prompt: str, messages: Messages):
    while True:
        print(f'messages so far: {messages}')
        output = await call_llm(prompt, messages)
        if isinstance(output, str):
            return output
        messages.extend(output)

await agent(prompt, [])
"""
    pydantic_monty.Monty(
        code,
        inputs=['prompt'],
        external_functions=['call_llm'],
        script_name='agent.py',
        type_check=True,
        type_check_stubs=type_definitions,
    )

    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        pydantic_monty.Monty(
            code.replace('Messages', 'MXessages'),
            inputs=['prompt'],
            external_functions=['call_llm'],
            script_name='agent.py',
            type_check=True,
            type_check_stubs=type_definitions,
        )
    assert str(exc_info.value) == snapshot("""\
error[unresolved-reference]: Name `MXessages` used when not defined
 --> agent.py:1:40
  |
1 | async def agent(prompt: str, messages: MXessages):
  |                                        ^^^^^^^^^
2 |     while True:
3 |         print(f'messages so far: {messages}')
  |
info: rule `unresolved-reference` is enabled by default

""")

    code_call_func_wrong = 'await call_llm(prompt, 42)'

    with pytest.raises(pydantic_monty.MontyTypingError) as exc_info:
        pydantic_monty.Monty(
            code_call_func_wrong,
            inputs=['prompt'],
            external_functions=['call_llm'],
            script_name='agent.py',
            type_check=True,
            type_check_stubs=type_definitions,
        )
    assert str(exc_info.value) == snapshot("""\
error[invalid-argument-type]: Argument to function `call_llm` is incorrect
 --> agent.py:1:24
  |
1 | await call_llm(prompt, 42)
  |                        ^^ Expected `list[dict[str, Any]]`, found `Literal[42]`
  |
info: Function defined here
 --> type_stubs.pyi:5:11
  |
3 | Messages = list[dict[str, Any]]
4 |
5 | async def call_llm(prompt: str, messages: Messages) -> str | Messages:
  |           ^^^^^^^^              ------------------ Parameter declared here
6 |     ...
  |
info: rule `invalid-argument-type` is enabled by default

""")




------------------------------------------
File: crates/monty-python/tests/test_types.py
------------------------------------------

import pytest
from inline_snapshot import snapshot

import pydantic_monty


def test_none_input():
    m = pydantic_monty.Monty('x is None', inputs=['x'])
    assert m.run(inputs={'x': None}) is True


def test_none_output():
    m = pydantic_monty.Monty('None')
    assert m.run() is None


def test_bool_true():
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': True})
    assert result is True
    assert type(result) is bool


def test_bool_false():
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': False})
    assert result is False
    assert type(result) is bool


def test_int():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': 42}) == snapshot(42)
    assert m.run(inputs={'x': -100}) == snapshot(-100)
    assert m.run(inputs={'x': 0}) == snapshot(0)


def test_float():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': 3.14}) == snapshot(3.14)
    assert m.run(inputs={'x': -2.5}) == snapshot(-2.5)
    assert m.run(inputs={'x': 0.0}) == snapshot(0.0)


def test_string():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': 'hello'}) == snapshot('hello')
    assert m.run(inputs={'x': ''}) == snapshot('')
    assert m.run(inputs={'x': 'unicode: éè'}) == snapshot('unicode: éè')


def test_bytes():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': b'hello'}) == snapshot(b'hello')
    assert m.run(inputs={'x': b''}) == snapshot(b'')
    assert m.run(inputs={'x': b'\x00\x01\x02'}) == snapshot(b'\x00\x01\x02')


def test_list():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': [1, 2, 3]}) == snapshot([1, 2, 3])
    assert m.run(inputs={'x': []}) == snapshot([])
    assert m.run(inputs={'x': ['a', 'b']}) == snapshot(['a', 'b'])


def test_tuple():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': (1, 2, 3)}) == snapshot((1, 2, 3))
    assert m.run(inputs={'x': ()}) == snapshot(())
    assert m.run(inputs={'x': ('a',)}) == snapshot(('a',))


def test_dict():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': {'a': 1, 'b': 2}}) == snapshot({'a': 1, 'b': 2})
    assert m.run(inputs={'x': {}}) == snapshot({})


def test_set():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': {1, 2, 3}}) == snapshot({1, 2, 3})
    assert m.run(inputs={'x': set()}) == snapshot(set())


def test_frozenset():
    m = pydantic_monty.Monty('x', inputs=['x'])
    assert m.run(inputs={'x': frozenset([1, 2, 3])}) == snapshot(frozenset({1, 2, 3}))
    assert m.run(inputs={'x': frozenset()}) == snapshot(frozenset())


def test_ellipsis_input():
    m = pydantic_monty.Monty('x is ...', inputs=['x'])
    assert m.run(inputs={'x': ...}) is True


def test_ellipsis_output():
    m = pydantic_monty.Monty('...')
    assert m.run() is ...


def test_nested_list():
    m = pydantic_monty.Monty('x', inputs=['x'])
    nested = [[1, 2], [3, [4, 5]]]
    assert m.run(inputs={'x': nested}) == snapshot([[1, 2], [3, [4, 5]]])


def test_nested_dict():
    m = pydantic_monty.Monty('x', inputs=['x'])
    nested = {'a': {'b': {'c': 1}}}
    assert m.run(inputs={'x': nested}) == snapshot({'a': {'b': {'c': 1}}})


def test_mixed_nested():
    m = pydantic_monty.Monty('x', inputs=['x'])
    mixed = {'list': [1, 2], 'tuple': (3, 4), 'nested': {'set': {5, 6}}}
    result = m.run(inputs={'x': mixed})
    assert result['list'] == snapshot([1, 2])
    assert result['tuple'] == snapshot((3, 4))
    assert result['nested']['set'] == snapshot({5, 6})


def test_list_output():
    m = pydantic_monty.Monty('[1, 2, 3]')
    assert m.run() == snapshot([1, 2, 3])


def test_dict_output():
    m = pydantic_monty.Monty("{'a': 1, 'b': 2}")
    assert m.run() == snapshot({'a': 1, 'b': 2})


def test_tuple_output():
    m = pydantic_monty.Monty('(1, 2, 3)')
    assert m.run() == snapshot((1, 2, 3))


def test_set_output():
    m = pydantic_monty.Monty('{1, 2, 3}')
    assert m.run() == snapshot({1, 2, 3})


# === Exception types ===


def test_exception_input():
    m = pydantic_monty.Monty('x', inputs=['x'])
    exc = ValueError('test error')
    result = m.run(inputs={'x': exc})
    assert isinstance(result, ValueError)
    assert str(result) == snapshot('test error')


def test_exception_output():
    m = pydantic_monty.Monty('ValueError("created")')
    result = m.run()
    assert isinstance(result, ValueError)
    assert str(result) == snapshot('created')


@pytest.mark.parametrize('exc_class', [ValueError, TypeError, RuntimeError, AttributeError], ids=repr)
def test_exception_roundtrip(exc_class: type[Exception]):
    m = pydantic_monty.Monty('x', inputs=['x'])
    exc = exc_class('message')
    result = m.run(inputs={'x': exc})
    assert type(result) is exc_class
    assert str(result) == snapshot('message')


def test_exception_subclass_input():
    """Custom exception subtypes are converted to their nearest supported base."""

    class MyError(ValueError):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    exc = MyError('custom')
    result = m.run(inputs={'x': exc})
    # Custom exception becomes ValueError (nearest supported type)
    assert type(result) is ValueError
    assert str(result) == snapshot('custom')


# === Subtype coercion ===
# Monty converts Python subclasses to their base types since it doesn't
# have Python's class system.


def test_int_subclass_input():
    class MyInt(int):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': MyInt(42)})
    assert type(result) is int
    assert result == snapshot(42)


def test_str_subclass_input():
    class MyStr(str):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': MyStr('hello')})
    assert type(result) is str
    assert result == snapshot('hello')


def test_list_subclass_input():
    class MyList(list[int]):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': MyList([1, 2, 3])})
    assert type(result) is list
    assert result == snapshot([1, 2, 3])


def test_dict_subclass_input():
    class MyDict(dict[str, int]):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': MyDict({'a': 1})})
    assert type(result) is dict
    assert result == snapshot({'a': 1})


def test_tuple_subclass_input():
    class MyTuple(tuple[int, ...]):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': MyTuple((1, 2))})
    assert type(result) is tuple
    assert result == snapshot((1, 2))


def test_set_subclass_input():
    class MySet(set[int]):
        pass

    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': MySet({1, 2})})
    assert type(result) is set
    assert result == snapshot({1, 2})


def test_bool_preserves_type():
    """Bool is a subclass of int but should be preserved as bool."""
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': True})
    assert type(result) is bool
    assert result is True


def test_return_int():
    m = pydantic_monty.Monty('x = 4\ntype(x)')
    result = m.run()
    assert result is int

    m = pydantic_monty.Monty('int')
    result = m.run()
    assert result is int


def test_return_exception():
    m = pydantic_monty.Monty('x = ValueError()\ntype(x)')
    result = m.run()
    assert result is ValueError

    m = pydantic_monty.Monty('ValueError')
    result = m.run()
    assert result is ValueError


def test_return_builtin():
    m = pydantic_monty.Monty('len')
    result = m.run()
    assert result is len


# === BigInt (arbitrary precision integers) ===


def test_bigint_input():
    """Passing a large integer (> i64::MAX) as input."""
    big = 2**100
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': big})
    assert result == big
    assert type(result) is int


def test_bigint_output():
    """Returning a large integer computed inside Monty."""
    m = pydantic_monty.Monty('2**100')
    result = m.run()
    assert result == 2**100
    assert type(result) is int


def test_bigint_negative_input():
    """Passing a large negative integer as input."""
    big_neg = -(2**100)
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': big_neg})
    assert result == big_neg
    assert type(result) is int


def test_int_overflow_to_bigint():
    """Small int input that overflows to bigint during computation."""
    max_i64 = 9223372036854775807
    m = pydantic_monty.Monty('x + 1', inputs=['x'])
    result = m.run(inputs={'x': max_i64})
    assert result == max_i64 + 1
    assert type(result) is int


def test_bigint_arithmetic():
    """BigInt arithmetic operations."""
    big = 2**100
    m = pydantic_monty.Monty('x * 2 + y', inputs=['x', 'y'])
    result = m.run(inputs={'x': big, 'y': big})
    assert result == big * 2 + big
    assert type(result) is int


def test_bigint_comparison():
    """Comparing bigints with regular ints."""
    big = 2**100
    m = pydantic_monty.Monty('x > y', inputs=['x', 'y'])
    assert m.run(inputs={'x': big, 'y': 42}) is True
    assert m.run(inputs={'x': 42, 'y': big}) is False


def test_bigint_in_collection():
    """BigInts inside collections."""
    big = 2**100
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': [big, 42, big * 2]})
    assert result == [big, 42, big * 2]
    assert type(result[0]) is int


def test_bigint_as_dict_key():
    """BigInt as dictionary key."""
    big = 2**100
    m = pydantic_monty.Monty('x', inputs=['x'])
    result = m.run(inputs={'x': {big: 'value'}})
    assert result == {big: 'value'}
    assert big in result


def test_bigint_hash_consistency_small_values():
    """Hash of small values computed as BigInt must match regular int hash.

    This is critical for dict key lookups: inserting with int and looking up
    with a computed BigInt (or vice versa) must work correctly.
    """
    # Value 42 computed via BigInt arithmetic
    big = 2**100
    m = pydantic_monty.Monty('(x - x) + 42', inputs=['x'])
    computed_42 = m.run(inputs={'x': big})

    # Hash must match
    assert hash(computed_42) == hash(42), 'hash of computed int must match literal'

    # Dict lookup must work both ways
    d = {42: 'value'}
    assert d[computed_42] == 'value', 'lookup with computed bigint finds int key'

    d2 = {computed_42: 'value'}
    assert d2[42] == 'value', 'lookup with int finds computed bigint key'


def test_bigint_hash_consistency_boundary():
    """Hash consistency at i64 boundary values."""
    max_i64 = 9223372036854775807

    # Compute MAX_I64 via BigInt arithmetic
    m = pydantic_monty.Monty('(x - 1)', inputs=['x'])
    computed_max = m.run(inputs={'x': max_i64 + 1})

    assert hash(computed_max) == hash(max_i64), 'hash at MAX_I64 boundary must match'


def test_bigint_hash_consistency_large_values():
    """Equal large BigInts must hash the same."""
    big1 = 2**100
    big2 = 2**100

    # Verify they hash the same in Python first
    assert hash(big1) == hash(big2), 'precondition: equal bigints hash same in Python'

    # Verify hashes match after round-trip through Monty
    m = pydantic_monty.Monty('x', inputs=['x'])
    result1 = m.run(inputs={'x': big1})
    result2 = m.run(inputs={'x': big2})

    assert hash(result1) == hash(result2), 'equal bigints from Monty must hash same'

    # Dict lookup must work
    d = {result1: 'value'}
    assert d[result2] == 'value', 'lookup with equal bigint works'


# === NamedTuple output ===


def test_namedtuple_sys_version_info():
    """sys.version_info returns a proper namedtuple with attribute access."""
    m = pydantic_monty.Monty('import sys; sys.version_info')
    result = m.run()

    # Should have named attribute access
    assert hasattr(result, 'major')
    assert hasattr(result, 'minor')
    assert hasattr(result, 'micro')
    assert hasattr(result, 'releaselevel')
    assert hasattr(result, 'serial')

    # Values should match Monty's Python version (3.14)
    assert result.major == snapshot(3)
    assert result.minor == snapshot(14)
    assert result.micro == snapshot(0)
    assert result.releaselevel == snapshot('final')
    assert result.serial == snapshot(0)


def test_namedtuple_sys_version_info_index_access():
    """sys.version_info supports both index and attribute access."""
    m = pydantic_monty.Monty('import sys; sys.version_info')
    result = m.run()

    # Index access should work
    assert result[0] == result.major
    assert result[1] == result.minor
    assert result[2] == result.micro


def test_namedtuple_sys_version_info_tuple_comparison():
    """sys.version_info can be compared to tuples."""
    m = pydantic_monty.Monty('import sys; (sys.version_info.major, sys.version_info.minor, sys.version_info.micro)')
    result = m.run()
    assert result == snapshot((3, 14, 0))


# === User-defined NamedTuple input ===


def test_namedtuple_custom_input_attribute_access():
    """User-defined NamedTuple with custom field names can be accessed by attribute."""
    from typing import NamedTuple

    class Person(NamedTuple):
        name: str
        age: int

    m = pydantic_monty.Monty('p.name', inputs=['p'])
    assert m.run(inputs={'p': Person(name='Alice', age=30)}) == snapshot('Alice')

    m = pydantic_monty.Monty('p.age', inputs=['p'])
    assert m.run(inputs={'p': Person(name='Alice', age=30)}) == snapshot(30)


def test_namedtuple_custom_input_index_access():
    """User-defined NamedTuple supports both attribute and index access."""
    from typing import NamedTuple

    class Point(NamedTuple):
        x: int
        y: int

    m = pydantic_monty.Monty('p[0] + p[1]', inputs=['p'])
    assert m.run(inputs={'p': Point(x=10, y=20)}) == snapshot(30)


def test_namedtuple_custom_input_multiple_fields():
    """NamedTuple with multiple custom field names works correctly."""
    from typing import NamedTuple

    class Config(NamedTuple):
        host: str
        port: int
        debug: bool
        timeout: float

    m = pydantic_monty.Monty("f'{c.host}:{c.port}'", inputs=['c'])
    result = m.run(inputs={'c': Config(host='localhost', port=8080, debug=True, timeout=30.0)})
    assert result == snapshot('localhost:8080')

    m = pydantic_monty.Monty('c.debug', inputs=['c'])
    result = m.run(inputs={'c': Config(host='localhost', port=8080, debug=True, timeout=30.0)})
    assert result is True


def test_namedtuple_custom_input_repr():
    """User-defined NamedTuple has correct repr with fully-qualified type name."""
    from typing import NamedTuple

    class Item(NamedTuple):
        name: str
        price: float

    m = pydantic_monty.Monty('repr(item)', inputs=['item'])
    result = m.run(inputs={'item': Item(name='widget', price=9.99)})
    # Monty uses the full qualified name (module.ClassName) for the type
    assert result == snapshot("test_types.Item(name='widget', price=9.99)")


def test_namedtuple_custom_input_len():
    """User-defined NamedTuple supports len()."""
    from typing import NamedTuple

    class Triple(NamedTuple):
        a: int
        b: int
        c: int

    m = pydantic_monty.Monty('len(t)', inputs=['t'])
    assert m.run(inputs={'t': Triple(a=1, b=2, c=3)}) == snapshot(3)


def test_namedtuple_custom_input_roundtrip():
    """User-defined NamedTuple can be passed through and returned."""
    from typing import NamedTuple

    class Pair(NamedTuple):
        first: int
        second: int

    m = pydantic_monty.Monty('p', inputs=['p'])
    result = m.run(inputs={'p': Pair(first=1, second=2)})
    # Returns a namedtuple-like object (not the same Python class)
    assert result[0] == snapshot(1)
    assert result[1] == snapshot(2)
    assert result.first == snapshot(1)
    assert result.second == snapshot(2)


def test_namedtuple_custom_missing_attr_error():
    """Accessing non-existent attribute on custom NamedTuple raises AttributeError."""
    from typing import NamedTuple

    class Simple(NamedTuple):
        value: int

    m = pydantic_monty.Monty('s.nonexistent', inputs=['s'])
    with pytest.raises(pydantic_monty.MontyRuntimeError) as exc_info:
        m.run(inputs={'s': Simple(value=42)})
    # Monty uses the full qualified name (module.ClassName) for the type
    assert "AttributeError: 'test_types.Simple' object has no attribute 'nonexistent'" in str(exc_info.value)




------------------------------------------
File: crates/monty-type-checking/src/type_check.rs
------------------------------------------

use std::{
    fmt::{self, Display},
    sync::{Arc, Mutex},
};

use ruff_db::{
    Db as SourceDb,
    diagnostic::{
        Annotation, Diagnostic, DiagnosticFormat, DiagnosticId, DisplayDiagnosticConfig, DisplayDiagnostics,
        UnifiedFile,
    },
    files::{File, FileRootKind, system_path_to_file},
    system::{DbWithWritableSystem as _, SystemPathBuf},
};
use ruff_text_size::{TextRange, TextSize};
use ty_module_resolver::SearchPathSettings;
use ty_python_semantic::{
    Program, ProgramSettings, PythonPlatform, PythonVersionSource, PythonVersionWithSource, types::check_types,
};

use crate::db::MemoryDb;

/// Definition of a source file.
pub struct SourceFile<'a> {
    /// source code
    pub source_code: &'a str,
    /// file path
    pub path: &'a str,
}

impl<'a> SourceFile<'a> {
    /// Create a new source file.
    #[must_use]
    pub fn new(source_code: &'a str, path: &'a str) -> Self {
        Self { source_code, path }
    }
}

/// Type check some python source code, checking if it's valid to run with monty.
///
/// # Arguments
/// * `python_source` - The python source code to type check.
/// * `stubs_file` - Optional stubs file to use for type checking.
///
/// # Returns
/// * `Ok(Some(TypeCheckingFailure))` - If there are typing errors.
/// * `Ok(None)` - If there are no typing errors.
/// * `Err(String)` - If there was an unexpected/internal error during type checking.
pub fn type_check(
    python_source: &SourceFile<'_>,
    stubs_file: Option<&SourceFile<'_>>,
) -> Result<Option<TypeCheckingDiagnostics>, String> {
    let mut db = MemoryDb::new();

    // Files must be written under a directory that's registered as a search path for module
    // resolution to work. We use "/" as the root directory so paths appear without a prefix.
    let src_root = SystemPathBuf::from("/");

    // Register the source root for Salsa tracking - required for module resolution
    db.files().try_add_root(&db, &src_root, FileRootKind::Project);

    let search_paths = SearchPathSettings::new(vec![src_root.clone()])
        .to_search_paths(db.system(), db.vendored())
        .map_err(to_string)?;

    // The API is confusing here - we have to load the "program" here like this, otherwise we get unwrap
    // panics when calling `check_types`
    Program::from_settings(
        &db,
        ProgramSettings {
            python_version: PythonVersionWithSource {
                version: db.python_version(),
                source: PythonVersionSource::default(),
            },
            python_platform: PythonPlatform::default(),
            search_paths,
        },
    );

    // Build absolute paths for files under /
    let main_path = src_root.join(python_source.path);
    let main_source = python_source.source_code;

    let code_offset: u32 = if let Some(stubs_file) = stubs_file {
        let stubs_path = src_root.join(stubs_file.path);

        // write the stub file
        db.write_file(&stubs_path, stubs_file.source_code).map_err(to_string)?;

        // prepend the stub import to the main source code
        let stub_stem = stubs_file
            .path
            .split_once('.')
            .map_or(stubs_file.path, |(before, _)| before);
        let mut new_source = format!("from {stub_stem} import *\n");
        let offset = u32::try_from(new_source.len()).map_err(to_string)?;
        new_source.push_str(main_source);

        // write the main source code
        db.write_file(&main_path, &new_source).map_err(to_string)?;
        // one line offset for errors vs. the original source code since we injected the stub import
        offset
    } else {
        // write just the main source code
        db.write_file(&main_path, main_source).map_err(to_string)?;
        0
    };

    let main_file = system_path_to_file(&db, &main_path).map_err(to_string)?;
    let mut diagnostics = check_types(&db, main_file);
    diagnostics.retain(filter_diagnostics);

    if diagnostics.is_empty() {
        Ok(None)
    } else {
        // without all this errors would appear on the wrong line because we injected `from type_stubs import *`

        // if we injected the stubs import, we need to write the actual source back to the file in the database
        db.write_file(&main_path, main_source).map_err(to_string)?;
        // and then adjust each span in the error message to account for the injected stubs import
        if code_offset > 0 {
            let offset = TextSize::new(code_offset);
            for diagnostic in &mut diagnostics {
                // Adjust spans in main diagnostic annotations (only for spans in the main file)
                for ann in diagnostic.annotations_mut() {
                    adjust_annotation_span(ann, main_file, offset);
                }
                // Adjust spans in sub-diagnostic annotations (e.g., "info: Function defined here")
                for sub in diagnostic.sub_diagnostics_mut() {
                    for ann in sub.annotations_mut() {
                        adjust_annotation_span(ann, main_file, offset);
                    }
                }
            }
        }
        // Sort diagnostics by line number
        diagnostics.sort_by(|a, b| a.rendering_sort_key(&db).cmp(&b.rendering_sort_key(&db)));

        Ok(Some(TypeCheckingDiagnostics::new(diagnostics, db)))
    }
}

fn to_string(err: impl Display) -> String {
    err.to_string()
}

/// Adjust the span of an annotation by subtracting the given offset.
///
/// This is used when we inject a stub import at the beginning of the source code,
/// and need to adjust all spans to account for the injected code.
/// Only adjusts spans that belong to the main file being type-checked.
fn adjust_annotation_span(ann: &mut Annotation, main_file: File, offset: TextSize) {
    let span = ann.get_span();
    // Only adjust spans for the main file (not stubs or other files)
    if let UnifiedFile::Ty(span_file) = span.file()
        && *span_file == main_file
        && let Some(range) = span.range()
    {
        let new_range = TextRange::new(range.start() - offset, range.end() - offset);
        let new_span = span.clone().with_range(new_range);
        ann.set_span(new_span);
    }
}

/// Represents diagnostic details when type checking fails.
#[derive(Clone)]
pub struct TypeCheckingDiagnostics {
    /// The actual diagnostic message
    diagnostics: Vec<Diagnostic>,
    /// db used to display diagnostics, wrapped in Mutex for Sync so MontyTypingError is sendable
    db: Arc<Mutex<MemoryDb>>,
    /// How to format the output
    format: DiagnosticFormat,
    /// Whether to highlight the output with ansi colors
    color: bool,
}

/// Debug output for TypeCheckingDiagnostics shows the pretty typing output, and no other values since
/// this will be displayed when users are printing `Result<..., TypeCheckingDiagnostics>` etc. and the
/// raw errors are not useful to end users.
impl fmt::Debug for TypeCheckingDiagnostics {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let config = self.config();
        let db = self.db.lock().unwrap();
        write!(
            f,
            "TypeCheckingDiagnostics:\n{}",
            DisplayDiagnostics::new(&*db, &config, &self.diagnostics)
        )
    }
}

/// To display true debugs details about the TypeCheckingDiagnostics
#[derive(Debug)]
#[expect(dead_code)]
pub struct DebugTypeCheckingDiagnostics<'a> {
    diagnostics: &'a [Diagnostic],
    db: Arc<Mutex<MemoryDb>>,
    format: DiagnosticFormat,
    color: bool,
}

impl fmt::Display for TypeCheckingDiagnostics {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let db = self.db.lock().unwrap();
        DisplayDiagnostics::new(&*db, &self.config(), &self.diagnostics).fmt(f)
    }
}

impl TypeCheckingDiagnostics {
    fn new(diagnostics: Vec<Diagnostic>, db: MemoryDb) -> Self {
        Self {
            diagnostics,
            db: Arc::new(Mutex::new(db)),
            format: DiagnosticFormat::Full,
            color: false,
        }
    }

    fn config(&self) -> DisplayDiagnosticConfig {
        DisplayDiagnosticConfig::new("monty")
            .format(self.format)
            .color(self.color)
    }

    /// To display debug details for the TypeCheckingDiagnostics since debug is the pretty output
    #[must_use]
    pub fn debug_details(&self) -> DebugTypeCheckingDiagnostics<'_> {
        DebugTypeCheckingDiagnostics {
            diagnostics: &self.diagnostics,
            db: self.db.clone(),
            format: self.format,
            color: self.color,
        }
    }

    /// Set the format of the diagnostics.
    #[must_use]
    pub fn format(self, format: DiagnosticFormat) -> Self {
        Self { format, ..self }
    }

    /// Set the format of the diagnostics from a string.
    /// Valid formats: "full", "concise", "azure", "json", "jsonlines", "rdjson",
    /// "pylint", "gitlab", "github".
    pub fn format_from_str(self, format: &str) -> Result<Self, String> {
        let format = match format.to_ascii_lowercase().as_str() {
            "full" => DiagnosticFormat::Full,
            "concise" => DiagnosticFormat::Concise,
            "azure" => DiagnosticFormat::Azure,
            "json" => DiagnosticFormat::Json,
            "jsonlines" | "json-lines" => DiagnosticFormat::JsonLines,
            "rdjson" => DiagnosticFormat::Rdjson,
            "pylint" => DiagnosticFormat::Pylint,
            // don't bother with the "junit" feature, please check the binary size and add it if you need this format
            // "junit" => DiagnosticFormat::Junit,
            "gitlab" => DiagnosticFormat::Gitlab,
            "github" => DiagnosticFormat::Github,
            _ => return Err(format!("Unknown format: {format}")),
        };
        Ok(Self { format, ..self })
    }

    /// Set whether to highlight the output with ansi colors
    #[must_use]
    pub fn color(self, color: bool) -> Self {
        Self { color, ..self }
    }
}

/// Filter out diagnostics we want to ignore.
///
/// Should only be necessary until <https://github.com/astral-sh/ty/issues/2599> is fixed.
fn filter_diagnostics(d: &Diagnostic) -> bool {
    !(matches!(d.id(), DiagnosticId::InvalidSyntax)
        && matches!(
            d.primary_message(),
            "`await` statement outside of a function" | "`await` outside of an asynchronous function"
        ))
}




------------------------------------------
File: crates/monty-type-checking/tests/bad_types_output.txt
------------------------------------------

bad_types.py:22:11: error[invalid-argument-type] Argument to function `takes_int` is incorrect: Expected `int`, found `Literal["hello"]`
bad_types.py:23:11: error[invalid-argument-type] Argument to function `takes_int` is incorrect: Expected `int`, found `float`
bad_types.py:24:11: error[invalid-argument-type] Argument to function `takes_str` is incorrect: Expected `str`, found `Literal[42]`
bad_types.py:25:11: error[invalid-argument-type] Argument to function `takes_str` is incorrect: Expected `str`, found `list[Unknown | int]`
bad_types.py:28:16: error[invalid-argument-type] Argument to function `takes_list_int` is incorrect: Expected `list[int]`, found `list[int | str]`
bad_types.py:29:16: error[invalid-argument-type] Argument to function `takes_list_int` is incorrect: Expected `list[int]`, found `list[int | float]`
bad_types.py:36:12: error[invalid-return-type] Return type does not match returned value: expected `int`, found `Literal["oops"]`
bad_types.py:40:12: error[invalid-return-type] Return type does not match returned value: expected `str`, found `Literal[123]`
bad_types.py:44:12: error[invalid-return-type] Return type does not match returned value: expected `list[int]`, found `list[int | str]`
bad_types.py:48:12: error[invalid-return-type] Return type does not match returned value: expected `None`, found `Literal[42]`
bad_types.py:63:11: error[unsupported-operator] Operator `+` is not supported between objects of type `int` and `str`
bad_types.py:64:11: error[unsupported-operator] Operator `-` is not supported between objects of type `str` and `int`
bad_types.py:70:1: error[type-assertion-failure] Type `str` does not match asserted type `Literal[42]`
bad_types.py:73:1: error[type-assertion-failure] Type `list[str]` does not match asserted type `list[int]`
bad_types.py:85:5: error[unresolved-attribute] Object of type `MyClass` has no attribute `nonexistent_attr`
bad_types.py:95:1: error[missing-argument] No argument provided for required parameter `b` of function `takes_two`
bad_types.py:96:23: error[too-many-positional-arguments] Too many positional arguments to function `takes_two`: expected 2, got 3
bad_types.py:101:1: error[missing-argument] No argument provided for required parameter `b` of function `takes_two`
bad_types.py:101:16: error[unknown-argument] Argument `c` does not match any known parameter of function `takes_two`
bad_types.py:107:1: error[call-non-callable] Object of type `Literal[42]` is not callable
bad_types.py:109:7: error[unresolved-attribute] Module `sys` has no member `copyright`




------------------------------------------
File: crates/monty-type-checking/tests/bad_types.py
------------------------------------------

# This file contains intentional type errors to test the type checker.
# Each section demonstrates a different category of type error.
# ===

import sys
from typing import assert_type


def takes_int(x: int) -> None:
    pass


def takes_str(x: str) -> None:
    pass


def takes_list_int(x: list[int]) -> None:
    pass


# Wrong primitive types
takes_int('hello')
takes_int(3.14)
takes_str(42)
takes_str([1, 2, 3])

# Wrong container element types
takes_list_int(['a', 'b', 'c'])
takes_list_int([1.0, 2.0, 3.0])


# === Invalid return types ===


def should_return_int() -> int:
    return 'oops'


def should_return_str() -> str:
    return 123


def should_return_list_int() -> list[int]:
    return ['a', 'b']


def should_return_none() -> None:
    return 42


# === Type mismatches in expressions ===


def get_int() -> int:
    return 42


def get_str() -> str:
    return 'hello'


# Binary operations with incompatible types
result1 = get_int() + get_str()
result2 = get_str() - get_int()


# === assert_type failures ===

x: int = 42
assert_type(x, str)

y: list[int] = [1, 2, 3]
assert_type(y, list[str])


# === Attribute errors ===


class MyClass:
    def __init__(self) -> None:
        self.value: int = 42


obj = MyClass()
z = obj.nonexistent_attr


# === Too many / too few arguments ===


def takes_two(a: int, b: str) -> None:
    pass


takes_two(1)
takes_two(1, 'hello', 'extra')


# === Wrong keyword arguments ===

takes_two(a=1, c='wrong')


# === Calling non-callable ===

not_callable: int = 42
not_callable()

print(sys.copyright)




------------------------------------------
File: crates/monty-type-checking/tests/good_types.py
------------------------------------------

import asyncio
import os
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import assert_type

# === Type checking helper functions ===


def check_int(x: int) -> None:
    pass


def check_float(x: float) -> None:
    pass


def check_str(x: str) -> None:
    pass


def check_bool(x: bool) -> None:
    pass


def check_bytes(x: bytes) -> None:
    pass


def check_list_int(x: list[int]) -> None:
    pass


def check_list_str(x: list[str]) -> None:
    pass


def check_tuple_int(x: tuple[int, ...]) -> None:
    pass


def check_dict_str_int(x: dict[str, int]) -> None:
    pass


def check_set_int(x: set[int]) -> None:
    pass


def check_frozenset_int(x: frozenset[int]) -> None:
    pass


# === Value getter functions ===


def get_int() -> int:
    return 123


def get_float() -> float:
    return 3.14


def get_str() -> str:
    return 'hello'


def get_list_int() -> list[int]:
    return [1, 2, 3]


def get_list_str() -> list[str]:
    return ['a', 'b', 'c']


def get_object() -> object:
    return object()


def get_dict_str_int() -> dict[str, int]:
    return {'a': 1, 'b': 2}


def get_set_str() -> set[str]:
    return {'a', 'b', 'c'}


def get_frozenset_str() -> frozenset[str]:
    return frozenset({'a', 'b', 'c'})


def get_tuple_str_int() -> tuple[str, int]:
    return ('hello', 42)


def get_bytes() -> bytes:
    return b'hello'


# === Core Types ===

obj = object()
t = type(42)


# === Primitive Types ===

# bool
check_bool(True)
check_bool(False)
check_bool(bool(1))
check_bool(bool(''))

# int
check_int(42)
check_int(int('42'))
check_int(int(3.14))
check_int(int(get_int()))
check_int(int(get_float()))

# float
check_float(3.14)
check_float(float('3.14'))
check_float(float(42))
f = get_float()
assert_type(f, float)


# === String and Bytes Types ===

# str
check_str('hello')
check_str(str(42))
check_str(str(b'hello', 'utf-8'))
check_str(str(get_int()))

# bytes
check_bytes(b'hello')
check_bytes(bytes('hello', 'utf-8'))
check_bytes(bytes(10))
check_bytes(bytes([65, 66, 67]))
check_bytes(bytes(get_int()))
k2 = get_bytes()
assert_type(k2, bytes)


# === Container Types ===

# list
check_list_int([1, 2, 3])
check_list_str(list('abc'))
check_list_int(list(range(10)))
m2 = get_list_int()
assert_type(m2, list[int])
m3 = get_list_str()
assert_type(m3, list[str])

# tuple
check_tuple_int(tuple([1, 2, 3]))
p2 = get_tuple_str_int()
assert_type(p2, tuple[str, int])

# dict
check_dict_str_int({'a': 1, 'b': 2})
check_dict_str_int(dict(a=1, b=2))
d = get_dict_str_int()
assert_type(d, dict[str, int])

# set
check_set_int({1, 2, 3})
check_set_int(set([1, 2, 3]))

# frozenset
check_frozenset_int(frozenset([1, 2, 3]))

# range
w = range(get_int())
assert_type(w, range)

# slice
sl1 = slice(10)
sl2 = slice(0, 10)
sl3 = slice(0, 10, 2)


# === Builtin Functions ===

# abs
check_int(abs(-5))
check_float(abs(-3.14))

# all / any
check_bool(all([True, False]))
check_bool(any([True, False]))
aa = all(get_list_int())
assert_type(aa, bool)

# bin / hex / oct
check_str(bin(42))
check_str(hex(255))
check_str(oct(8))
ac = bin(get_int())
assert_type(ac, str)

# chr / ord
check_str(chr(65))
check_int(ord('A'))
af = chr(get_int())
assert_type(af, str)
ag = ord(get_str())
assert_type(ag, int)

# divmod
dm = divmod(10, 3)

# hash
check_int(hash('hello'))
ai = hash(get_str())
assert_type(ai, int)

# id
check_int(id(object()))
ak = id(get_object())
assert_type(ak, int)

# isinstance
check_bool(isinstance(42, int))
al = isinstance(get_object(), int)
assert_type(al, bool)

# len
check_int(len([1, 2, 3]))
an = len(get_list_int())
assert_type(an, int)

# max / min
check_int(max(1, 2, 3))
check_int(min(1, 2, 3))

# pow
check_int(pow(2, 3))
check_float(pow(2.0, 3.0))

# print
aw = print(get_str())
assert_type(aw, None)

# repr
check_str(repr(42))
ax = repr(get_int())
assert_type(ax, str)

# round
check_int(round(3.7))

# sorted
check_list_int(sorted([3, 1, 2]))

# sum
check_int(sum([1, 2, 3]))
ba = sum(get_list_int())
assert_type(ba, int)

# type
bf = type(get_int())
assert_type(bf, type[int])


# === Iterator Types ===

# enumerate
for i_enum, v_enum in enumerate([1, 2, 3]):
    check_int(i_enum)
    check_int(v_enum)

# reversed
for v_rev in reversed([1, 2, 3]):
    check_int(v_rev)

# zip
for a_zip, b_zip in zip([1, 2], ['a', 'b']):
    check_int(a_zip)
    check_str(b_zip)


# === Literal Types ===

bk = None
assert_type(bk, None)


# === Exception Types ===

e1 = BaseException('error')
e2 = Exception('error')
e3 = SystemExit(1)
e4 = KeyboardInterrupt()
e5 = ArithmeticError('error')
e6 = OverflowError('error')
e7 = ZeroDivisionError('error')
e8 = LookupError('error')
e9 = IndexError('error')
e10 = KeyError('key')
e11 = RuntimeError('error')
e12 = NotImplementedError('error')
e13 = RecursionError('error')
e14 = AttributeError('error')
e15 = AssertionError('error')
e16 = MemoryError('error')
e17 = NameError('error')
e18 = SyntaxError('error')
e19 = TimeoutError('error')
e20 = TypeError('error')
e21 = ValueError('error')
e22 = StopIteration()


# === Exception Inheritance ===


def handle_base(e: BaseException) -> None:
    pass


handle_base(Exception('error'))
handle_base(ValueError('error'))
handle_base(KeyError('key'))
handle_base(ZeroDivisionError('error'))


def handle_exception(e: Exception) -> None:
    pass


handle_exception(ValueError('error'))
handle_exception(TypeError('error'))
handle_exception(RuntimeError('error'))


# === Try/Except ===

try:
    x_try = 1 / 0
except ZeroDivisionError as e_try:
    check_str(str(e_try))

try:
    d_try: dict[str, int] = {}
    v_try = d_try['missing']
except KeyError:
    pass

try:
    lst_try: list[int] = []
    v_lst = lst_try[0]
except IndexError:
    pass


# === Raise ===


def may_fail(x_fail: int) -> int:
    if x_fail < 0:
        raise ValueError('x must be non-negative')
    if x_fail == 0:
        raise ZeroDivisionError('x cannot be zero')
    return 100 // x_fail


def not_implemented() -> None:
    raise NotImplementedError('subclass must implement')


print(sys.version)
print(sys.version_info)
print(None, file=sys.stdout)
print(None, file=sys.stderr)

# === async ===


async def foo(a: int):
    return a * 2


async def bar():
    await foo(1)
    await foo(2)
    await foo(3)


await asyncio.gather(bar())  # pyright: ignore


@dataclass
class Point:
    x: int
    y: float


p = Point(1, 2)
assert_type(p.x, int)
assert_type(p.y, float)
p.x = 3
print(p)

path = Path(__file__)
assert_type(path, Path)
# assert_type(path.name, str)

p2 = path.parent
assert_type(p2, Path)

p3 = path / 'test.txt'
assert_type(p3, Path)
assert p3.name == 'test.txt'

x = os.getenv('foobar')
assert_type(x, str | None)

y = os.getenv('foobar', default=int('123'))
assert_type(y, str | int)

x2 = os.environ.get('foobar')
assert_type(x2, str | None)




------------------------------------------
File: crates/monty-type-checking/tests/main.rs
------------------------------------------

use std::fs;

use monty_type_checking::{SourceFile, type_check};
use pretty_assertions::assert_eq;
use ruff_db::diagnostic::DiagnosticFormat;

#[test]
fn type_checking_success() {
    let code = r"
def add(x: int, y: int) -> int:
    return x + y

result = add(1, 2)
    ";

    let result = type_check(&SourceFile::new(code, "main.py"), None).unwrap();
    assert!(result.is_none());
}

#[test]
fn type_checking_error() {
    let code = "\
def add(x: int, y: int) -> int:
    return x + y

result = add(1, '2')
    ";

    let result = type_check(&SourceFile::new(code, "main.py"), None).unwrap();
    assert!(result.is_some());

    let error_diagnostics = result.unwrap().to_string();
    assert_eq!(
        error_diagnostics,
        r#"error[invalid-argument-type]: Argument to function `add` is incorrect
 --> main.py:4:17
  |
2 |     return x + y
3 |
4 | result = add(1, '2')
  |                 ^^^ Expected `int`, found `Literal["2"]`
  |
info: Function defined here
 --> main.py:1:5
  |
1 | def add(x: int, y: int) -> int:
  |     ^^^         ------ Parameter declared here
2 |     return x + y
  |
info: rule `invalid-argument-type` is enabled by default

"#
    );
}

#[test]
fn type_checking_error_stubs() {
    let stubs = "\
from dataclasses import dataclass

@dataclass
class User:
    name: str
    age: int
";
    let code = "\
def add(x: int, y: int) -> int:
    return x + y

result = add(1, '2')";

    let result = type_check(
        &SourceFile::new(code, "main.py"),
        Some(&SourceFile::new(stubs, "type_stubs.pyi")),
    )
    .unwrap();

    let error_diagnostics = result.unwrap();
    assert_eq!(
        error_diagnostics.to_string(),
        r#"error[invalid-argument-type]: Argument to function `add` is incorrect
 --> main.py:4:17
  |
2 |     return x + y
3 |
4 | result = add(1, '2')
  |                 ^^^ Expected `int`, found `Literal["2"]`
  |
info: Function defined here
 --> main.py:1:5
  |
1 | def add(x: int, y: int) -> int:
  |     ^^^         ------ Parameter declared here
2 |     return x + y
  |
info: rule `invalid-argument-type` is enabled by default

"#
    );
}

#[test]
fn type_checking_error_concise() {
    let code = r"
def add(x: int, y: int) -> int:
    return x + y

result = add(1, '2')
    ";

    let result = type_check(&SourceFile::new(code, "main.py"), None).unwrap();
    assert!(result.is_some());

    let failure = result.unwrap().format(DiagnosticFormat::Concise);
    let error_diagnostics = failure.to_string();
    assert_eq!(
        error_diagnostics,
        "main.py:5:17: error[invalid-argument-type] Argument to function `add` is incorrect: Expected `int`, found `Literal[\"2\"]`\n"
    );
    let color_failure = failure.color(true).to_string();
    assert!(color_failure.starts_with('\u{1b}'));
}

#[test]
fn missing_stdlib_datetime() {
    let code = "import datetime\nprint(datetime.datetime.now())";

    let result = type_check(&SourceFile::new(code, "main.py"), None).unwrap();
    assert!(result.is_some());

    let failure = result.unwrap().format(DiagnosticFormat::Concise);
    let error_diagnostics = failure.to_string();
    assert_eq!(
        error_diagnostics,
        "main.py:1:8: error[unresolved-import] Cannot resolve imported module `datetime`\n"
    );
    let dbg = format!("{failure:?}");
    assert!(dbg.starts_with("TypeCheckingDiagnostics:"), "got: {dbg}");
}

/// Test that good_types.py type-checks without errors.
///
/// This file uses `assert_type` from typing to verify that inferred types match expected types.
#[test]
fn type_good_types() {
    let code = include_str!("good_types.py");
    let result = type_check(&SourceFile::new(code, "good_types.py"), None).unwrap();
    assert!(result.is_none(), "Expected no type errors, got: {result:#?}");
}

fn check_file_content(file_name: &str, mut actual: &str) {
    let expected_path = format!("{}/tests/{}", env!("CARGO_MANIFEST_DIR"), file_name);
    let expected = if fs::exists(&expected_path).unwrap() {
        fs::read_to_string(&expected_path).unwrap()
    } else {
        std::fs::write(&expected_path, actual).unwrap();
        panic!("{file_name} did not exist, file created.")
    };

    let expected = expected.as_str().trim();
    actual = actual.trim();

    if actual == expected {
        println!("File content matches expected.");
        return;
    }

    let status = if std::env::var("UPDATE_EXPECT").is_ok() {
        std::fs::write(&expected_path, actual).unwrap();
        "FILE UPDATE"
    } else {
        "file not updated, run with UPDATE_EXPECT=1 to update"
    };

    panic!("Type errors don't match expected.\n\nEXPECTED:\n{expected}\n\nACTUAL:\n{actual}\n\n{status}.");
}

/// Test that bad_types.py produces the expected type errors.
///
/// Set `UPDATE_EXPECT=1` to update the expected errors file.
#[test]
fn type_bad_types() {
    let code = include_str!("bad_types.py");
    let result = type_check(&SourceFile::new(code, "bad_types.py"), None).unwrap();

    let failure = result.expect("Expected type errors in bad_types.py");
    let actual = failure
        .format(ruff_db::diagnostic::DiagnosticFormat::Concise)
        .to_string();

    check_file_content("bad_types_output.txt", &actual);
}

#[test]
fn test_reveal_types() {
    let code = include_str!("reveal_types.py");
    let result = type_check(&SourceFile::new(code, "reveal_types.py"), None).unwrap();

    let failure = result.expect("Expected type errors in reveal_types.py");
    let actual = failure
        .format(ruff_db::diagnostic::DiagnosticFormat::Concise)
        .to_string();

    check_file_content("reveal_types_output.txt", &actual);
}




------------------------------------------
File: crates/monty-type-checking/tests/reveal_types_output.txt
------------------------------------------

reveal_types.py:4:13: info[revealed-type] Revealed type: `None`
reveal_types.py:5:13: info[revealed-type] Revealed type: `object`
reveal_types.py:6:13: info[revealed-type] Revealed type: `<class 'int'>`
reveal_types.py:9:13: info[revealed-type] Revealed type: `Literal[True]`
reveal_types.py:10:13: info[revealed-type] Revealed type: `int`
reveal_types.py:11:13: info[revealed-type] Revealed type: `float`
reveal_types.py:14:13: info[revealed-type] Revealed type: `Literal["hello"]`
reveal_types.py:15:13: info[revealed-type] Revealed type: `Literal[b"foobar"]`
reveal_types.py:18:13: info[revealed-type] Revealed type: `list[Unknown | int]`
reveal_types.py:19:13: info[revealed-type] Revealed type: `tuple[Literal[1], Literal[2]]`
reveal_types.py:20:13: info[revealed-type] Revealed type: `dict[Unknown | int, Unknown | int]`
reveal_types.py:21:13: info[revealed-type] Revealed type: `set[Unknown | int]`
reveal_types.py:22:13: info[revealed-type] Revealed type: `frozenset[int]`
reveal_types.py:23:13: info[revealed-type] Revealed type: `range`
reveal_types.py:26:13: info[revealed-type] Revealed type: `enumerate[int]`
reveal_types.py:27:13: info[revealed-type] Revealed type: `reversed[int]`
reveal_types.py:28:13: info[revealed-type] Revealed type: `zip[Unknown]`
reveal_types.py:31:13: info[revealed-type] Revealed type: `slice[Any, Any, Any]`
reveal_types.py:34:13: info[revealed-type] Revealed type: `BaseException`
reveal_types.py:35:13: info[revealed-type] Revealed type: `Exception`
reveal_types.py:36:13: info[revealed-type] Revealed type: `SystemExit`
reveal_types.py:37:13: info[revealed-type] Revealed type: `KeyboardInterrupt`
reveal_types.py:38:13: info[revealed-type] Revealed type: `ArithmeticError`
reveal_types.py:39:13: info[revealed-type] Revealed type: `OverflowError`
reveal_types.py:40:13: info[revealed-type] Revealed type: `ZeroDivisionError`
reveal_types.py:41:13: info[revealed-type] Revealed type: `LookupError`
reveal_types.py:42:13: info[revealed-type] Revealed type: `IndexError`
reveal_types.py:43:13: info[revealed-type] Revealed type: `KeyError`
reveal_types.py:44:13: info[revealed-type] Revealed type: `RuntimeError`
reveal_types.py:45:13: info[revealed-type] Revealed type: `NotImplementedError`
reveal_types.py:46:13: info[revealed-type] Revealed type: `RecursionError`
reveal_types.py:47:13: info[revealed-type] Revealed type: `AttributeError`
reveal_types.py:48:13: info[revealed-type] Revealed type: `AssertionError`
reveal_types.py:49:13: info[revealed-type] Revealed type: `MemoryError`
reveal_types.py:50:13: info[revealed-type] Revealed type: `NameError`
reveal_types.py:51:13: info[revealed-type] Revealed type: `SyntaxError`
reveal_types.py:52:13: info[revealed-type] Revealed type: `OSError`
reveal_types.py:53:13: info[revealed-type] Revealed type: `TimeoutError`
reveal_types.py:54:13: info[revealed-type] Revealed type: `TypeError`
reveal_types.py:55:13: info[revealed-type] Revealed type: `ValueError`
reveal_types.py:56:13: info[revealed-type] Revealed type: `StopIteration`




------------------------------------------
File: crates/monty-type-checking/tests/reveal_types.py
------------------------------------------

from typing import reveal_type

# === Core types ===
reveal_type(None)
reveal_type(object())
reveal_type(type(1))

# === Primitive types ===
reveal_type(True)
reveal_type(int(1))
reveal_type(float(1.2))

# === String/bytes types ===
reveal_type('hello')
reveal_type(b'foobar')

# === Container types ===
reveal_type([1])
reveal_type((1, 2))
reveal_type({1: 2})
reveal_type({1, 2})
reveal_type(frozenset({1, 2}))
reveal_type(range(10))

# === Iterator types ===
reveal_type(enumerate([1, 2]))
reveal_type(reversed([1, 2]))
reveal_type(zip([1], [2]))

# === Slicing ===
reveal_type(slice(1, 2))

# === Exception types ===
reveal_type(BaseException())
reveal_type(Exception())
reveal_type(SystemExit())
reveal_type(KeyboardInterrupt())
reveal_type(ArithmeticError())
reveal_type(OverflowError())
reveal_type(ZeroDivisionError())
reveal_type(LookupError())
reveal_type(IndexError())
reveal_type(KeyError())
reveal_type(RuntimeError())
reveal_type(NotImplementedError())
reveal_type(RecursionError())
reveal_type(AttributeError())
reveal_type(AssertionError())
reveal_type(MemoryError())
reveal_type(NameError())
reveal_type(SyntaxError())
reveal_type(OSError())
reveal_type(TimeoutError())
reveal_type(TypeError())
reveal_type(ValueError())
reveal_type(StopIteration())




------------------------------------------
File: crates/monty-typeshed/README.md
------------------------------------------

# Vendored types for a very minimal subset of the CPython stdlib

Copied originally from <https://github.com/astral-sh/ruff/tree/main/crates/ty_vendored> but only parts of
<https://github.com/python/typeshed/blob/main/stdlib/builtins.pyi> are kept, since those are the
only functions supported from the stdlib.

The `vendor/typeshed` directory is updated by calling `make update-typeshed` which calls the `update.py` script in this directory.

See <https://github.com/pydantic/monty> for more information on the project.

THEREFORE FILES IN THE `vendor/typeshed` DIRECTORY SHOULD NOT BE EDITED MANUALLY.




------------------------------------------
File: crates/monty-typeshed/update.py
------------------------------------------

#!/usr/bin/env python3
"""Update vendored typeshed files from the upstream repository.

This script:
1. Clones the typeshed repository to crates/monty-typeshed/typeshed-repo (or updates if it exists)
2. Records the HEAD commit hash
3. Filters builtins.pyi to keep only supported classes and functions
4. Writes the filtered file to the vendor directory

Usage:
    python crates/monty-typeshed/update.py
"""

import ast
import shutil
import subprocess
from pathlib import Path

# Whitelisted builtin functions (from crates/monty/src/builtins/)
ALLOWED_FUNCTIONS = {
    'abs',
    'all',
    'any',
    'bin',
    'chr',
    'divmod',
    'hash',
    'hex',
    'id',
    'isinstance',
    'len',
    'max',
    'min',
    'oct',
    'ord',
    'pow',
    'print',
    'repr',
    'round',
    'sorted',
    'sum',
}

# Whitelisted builtin classes (from crates/monty/src/types/ and exception_private.rs)
ALLOWED_CLASSES = {
    # Core types
    'object',
    'type',
    # Primitive types
    'bool',
    'int',
    'float',
    # String/bytes types
    'str',
    'bytes',
    # Container types
    'list',
    'tuple',
    'dict',
    'set',
    'frozenset',
    'range',
    # Iterator types (these are classes, not functions)
    'enumerate',
    'reversed',
    'zip',
    # Slicing
    'slice',
    # property is used by pathlib.Path
    'property',
    # Exception hierarchy (from crates/monty/src/exception_private.rs)
    'BaseException',
    'Exception',
    'SystemExit',
    'KeyboardInterrupt',
    'ArithmeticError',
    'OverflowError',
    'ZeroDivisionError',
    'LookupError',
    'IndexError',
    'KeyError',
    'RuntimeError',
    'NotImplementedError',
    'RecursionError',
    'AttributeError',
    'AssertionError',
    'MemoryError',
    'NameError',
    'SyntaxError',
    'OSError',
    'TimeoutError',
    'TypeError',
    'ValueError',
    'StopIteration',
}

# Dependency modules that builtins.pyi imports from.
# These are copied without filtering.
DEPENDENCY_FILES = [
    # Core type system
    'typing.pyi',
    'typing_extensions.pyi',
    '_collections_abc.pyi',
    # Used in type annotations
    'types.pyi',
    # So type checking works with dataclasses
    'dataclasses.pyi',
    # used by dataclasses
    'enum.pyi',
]


# Dependency directories (copied recursively)
DEPENDENCY_DIRS = [
    'collections',
    '_typeshed',
    'pathlib',
]
# content for typeshed's `VERSIONS` file
VERSIONS = """\
# absolutely minimal VERSIONS file exposing only the modules required
# all these modules are required to get type checking working with ty
# or for the stdlib modules we (partially) implement

_collections_abc: 3.3-
_typeshed: 3.0-  # not present at runtime, only for type checking
asyncio: 3.4-
builtins: 3.0-
collections: 3.0-
dataclasses: 3.7-
os: 3.0-
pathlib: 3.4-
pathlib.types: 3.14-
sys: 3.0-
typing: 3.5-
typing_extensions: 3.7-
types: 3.0-
"""

SCRIPT_DIR = Path(__file__).parent
VENDOR_DIR = SCRIPT_DIR / 'vendor' / 'typeshed'
STDLIB_DIR = VENDOR_DIR / 'stdlib'
CUSTOM_DIR = SCRIPT_DIR / 'custom'
TYPESHED_REPO_DIR = SCRIPT_DIR / 'typeshed-repo'

TYPESHED_REPO_URL = 'git@github.com:python/typeshed.git'


def clone_or_update_typeshed() -> tuple[Path, str]:
    """Clone or update the typeshed repository and return the path and HEAD commit hash.

    If the repository already exists at TYPESHED_REPO_DIR, performs a git pull.
    Otherwise, clones the repository to that location.

    Returns:
        Tuple of (repo_path, commit_hash).
    """
    if TYPESHED_REPO_DIR.exists():
        print(f'{TYPESHED_REPO_DIR} exists, not pulling')
        # subprocess.run(
        #     ['git', 'pull'],
        #     cwd=TYPESHED_REPO_DIR,
        #     check=True,
        #     capture_output=True,
        # )
    else:
        print(f'Cloning typeshed to {TYPESHED_REPO_DIR}...')
        subprocess.run(
            ['git', 'clone', '--depth=1', TYPESHED_REPO_URL, str(TYPESHED_REPO_DIR)],
            check=True,
            capture_output=True,
        )

    result = subprocess.run(
        ['git', 'rev-parse', 'HEAD'],
        cwd=TYPESHED_REPO_DIR,
        check=True,
        capture_output=True,
        text=True,
    )
    commit = result.stdout.strip()

    return TYPESHED_REPO_DIR, commit


def filter_statements(nodes: list[ast.stmt]) -> list[ast.stmt]:
    """Filter a list of statements to keep only allowed functions and classes.

    Keeps:
    - Imports
    - Type variable assignments (e.g., _T = TypeVar('_T'))
    - Allowed function definitions
    - Allowed class definitions

    Args:
        nodes: List of AST statement nodes.

    Returns:
        Filtered list of statements.
    """
    result: list[ast.stmt] = []
    for node in nodes:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            if node.name in ALLOWED_FUNCTIONS:
                result.append(node)
        elif isinstance(node, ast.ClassDef):
            if node.name.startswith('_') or node.name in ALLOWED_CLASSES:
                result.append(node)
        elif isinstance(node, ast.If):
            # Recursively filter version-conditional blocks
            filtered = filter_if_block(node)
            if filtered is not None:
                result.append(filtered)
        else:
            # Keep imports, type aliases, assignments, etc.
            result.append(node)
    return result


def filter_if_block(node: ast.If) -> ast.If | None:
    """Filter an if block, recursively filtering function and class definitions.

    Handles version conditionals like `if sys.version_info >= (3, 10):`.

    Args:
        node: An ast.If node.

    Returns:
        Filtered If node, or None if both branches are empty after filtering.
    """
    filtered_body = filter_statements(node.body)
    filtered_orelse = filter_statements(node.orelse)

    # If both branches are empty, skip this if block entirely
    if not filtered_body and not filtered_orelse:
        return None

    # Create a new If node with filtered contents
    new_node = ast.If(
        test=node.test,
        body=filtered_body if filtered_body else [ast.Pass()],
        orelse=filtered_orelse,
    )
    return ast.copy_location(new_node, node)


def filter_builtins(source: str) -> str:
    """Filter builtins.pyi to keep only allowed classes and functions.

    This function parses the source with Python's ast module and filters
    top-level definitions to only include those in the allow lists.
    All imports and type definitions are preserved.

    Args:
        source: The source code of builtins.pyi.

    Returns:
        Filtered source code.
    """
    tree = ast.parse(source)
    tree.body = filter_statements(tree.body)
    ast.fix_missing_locations(tree)
    return ast.unparse(tree)


def copy_dependencies(src_stdlib: Path, dest_stdlib: Path) -> None:
    """Copy dependency modules from typeshed stdlib to vendor directory.

    Args:
        src_stdlib: Path to the source stdlib directory in cloned typeshed.
        dest_stdlib: Path to the destination stdlib directory in vendor.
    """
    # Copy individual files
    for filename in DEPENDENCY_FILES:
        src_file = src_stdlib / filename
        if src_file.exists():
            dest_file = dest_stdlib / filename
            shutil.copy2(src_file, dest_file)
            print(f'Copied {filename}')
        else:
            print(f'Warning: {filename} not found in typeshed')

    # Copy directories recursively
    for dirname in DEPENDENCY_DIRS:
        src_dir = src_stdlib / dirname
        if src_dir.exists():
            dest_dir = dest_stdlib / dirname
            if dest_dir.exists():
                shutil.rmtree(dest_dir)
            shutil.copytree(src_dir, dest_dir)
            print(f'Copied {dirname}/')
        else:
            print(f'Warning: {dirname}/ not found in typeshed')


def main() -> int:
    """Main entry point."""
    # Clean up any stale files from previous runs
    if VENDOR_DIR.exists():
        print(f'Removing existing {VENDOR_DIR}...')
        shutil.rmtree(VENDOR_DIR)

    # Clone or update typeshed
    repo_path, commit = clone_or_update_typeshed()
    print(f'At commit {commit}')

    # Read source file
    builtins_path = repo_path / 'stdlib' / 'builtins.pyi'
    source = builtins_path.read_text()
    print(f'Read {len(source)} bytes from builtins.pyi')

    # Filter
    filtered = filter_builtins(source)
    print(f'Filtered to {len(filtered)} bytes')

    # Copy VERSIONS file
    src_stdlib = repo_path / 'stdlib'

    # Write output files
    STDLIB_DIR.mkdir(parents=True, exist_ok=True)
    (STDLIB_DIR / 'builtins.pyi').write_text(filtered)
    (STDLIB_DIR / 'VERSIONS').write_text(VERSIONS)

    # Copy dependency modules
    copy_dependencies(src_stdlib, STDLIB_DIR)

    # copy pyi files from CUSTOM_DIR into STDLIB_DIR
    for file in CUSTOM_DIR.glob('*.pyi'):
        shutil.copy2(file, STDLIB_DIR)

    (VENDOR_DIR / 'source_commit.txt').write_text(commit + '\n')

    print(f'Updated to commit {commit}')
    print(f'Wrote {STDLIB_DIR / "builtins.pyi"}')
    print(f'Wrote {STDLIB_DIR / "VERSIONS"}')
    print(f'Wrote {VENDOR_DIR / "source_commit.txt"}')

    return 0


if __name__ == '__main__':
    raise SystemExit(main())




------------------------------------------
File: examples/expense_analysis/data.py
------------------------------------------

from typing import Any

team_members = [
    {'id': 1, 'name': 'Alice Chen'},
    {'id': 2, 'name': 'Bob Smith'},
    {'id': 3, 'name': 'Carol Jones'},
    {'id': 4, 'name': 'David Kim'},
    {'id': 5, 'name': 'Eve Wilson'},
]

# Simulated expense data (multiple line items per person to bloat traditional context)
expenses = {
    1: [  # Alice - under budget
        {'date': '2024-07-15', 'amount': 450.00, 'description': 'Flight to NYC'},
        {'date': '2024-07-16', 'amount': 200.00, 'description': 'Hotel NYC'},
        {'date': '2024-07-17', 'amount': 85.00, 'description': 'Meals NYC'},
        {'date': '2024-08-20', 'amount': 380.00, 'description': 'Flight to Chicago'},
        {'date': '2024-08-21', 'amount': 175.00, 'description': 'Hotel Chicago'},
        {'date': '2024-09-05', 'amount': 520.00, 'description': 'Flight to Seattle'},
        {'date': '2024-09-06', 'amount': 225.00, 'description': 'Hotel Seattle'},
        {'date': '2024-09-07', 'amount': 95.00, 'description': 'Meals Seattle'},
    ],
    2: [  # Bob - over standard budget but has custom budget
        {'date': '2024-07-01', 'amount': 850.00, 'description': 'Flight to London'},
        {'date': '2024-07-02', 'amount': 450.00, 'description': 'Hotel London'},
        {'date': '2024-07-03', 'amount': 125.00, 'description': 'Meals London'},
        {'date': '2024-07-04', 'amount': 450.00, 'description': 'Hotel London'},
        {'date': '2024-07-05', 'amount': 120.00, 'description': 'Meals London'},
        {'date': '2024-08-10', 'amount': 780.00, 'description': 'Flight to Tokyo'},
        {'date': '2024-08-11', 'amount': 380.00, 'description': 'Hotel Tokyo'},
        {'date': '2024-08-12', 'amount': 380.00, 'description': 'Hotel Tokyo'},
        {'date': '2024-08-13', 'amount': 150.00, 'description': 'Meals Tokyo'},
        {'date': '2024-09-15', 'amount': 920.00, 'description': 'Flight to Singapore'},
        {'date': '2024-09-16', 'amount': 320.00, 'description': 'Hotel Singapore'},
        {'date': '2024-09-17', 'amount': 320.00, 'description': 'Hotel Singapore'},
        {'date': '2024-09-18', 'amount': 180.00, 'description': 'Meals Singapore'},
    ],
    3: [  # Carol - way over budget (no custom budget)
        {'date': '2024-07-08', 'amount': 1200.00, 'description': 'Flight to Paris'},
        {'date': '2024-07-09', 'amount': 550.00, 'description': 'Hotel Paris'},
        {'date': '2024-07-10', 'amount': 550.00, 'description': 'Hotel Paris'},
        {'date': '2024-07-11', 'amount': 550.00, 'description': 'Hotel Paris'},
        {'date': '2024-07-12', 'amount': 200.00, 'description': 'Meals Paris'},
        {'date': '2024-08-25', 'amount': 1100.00, 'description': 'Flight to Sydney'},
        {'date': '2024-08-26', 'amount': 480.00, 'description': 'Hotel Sydney'},
        {'date': '2024-08-27', 'amount': 480.00, 'description': 'Hotel Sydney'},
        {'date': '2024-08-28', 'amount': 480.00, 'description': 'Hotel Sydney'},
        {'date': '2024-08-29', 'amount': 220.00, 'description': 'Meals Sydney'},
        {'date': '2024-09-20', 'amount': 650.00, 'description': 'Flight to Denver'},
        {'date': '2024-09-21', 'amount': 280.00, 'description': 'Hotel Denver'},
    ],
    4: [  # David - slightly under budget
        {'date': '2024-07-22', 'amount': 420.00, 'description': 'Flight to Boston'},
        {'date': '2024-07-23', 'amount': 190.00, 'description': 'Hotel Boston'},
        {'date': '2024-07-24', 'amount': 75.00, 'description': 'Meals Boston'},
        {'date': '2024-08-05', 'amount': 510.00, 'description': 'Flight to Austin'},
        {'date': '2024-08-06', 'amount': 210.00, 'description': 'Hotel Austin'},
        {'date': '2024-08-07', 'amount': 90.00, 'description': 'Meals Austin'},
        {'date': '2024-09-12', 'amount': 480.00, 'description': 'Flight to Portland'},
        {'date': '2024-09-13', 'amount': 195.00, 'description': 'Hotel Portland'},
        {'date': '2024-09-14', 'amount': 85.00, 'description': 'Meals Portland'},
    ],
    5: [  # Eve - over standard budget (no custom budget)
        {'date': '2024-07-03', 'amount': 680.00, 'description': 'Flight to Miami'},
        {'date': '2024-07-04', 'amount': 320.00, 'description': 'Hotel Miami'},
        {'date': '2024-07-05', 'amount': 320.00, 'description': 'Hotel Miami'},
        {'date': '2024-07-06', 'amount': 145.00, 'description': 'Meals Miami'},
        {'date': '2024-08-18', 'amount': 750.00, 'description': 'Flight to San Diego'},
        {'date': '2024-08-19', 'amount': 290.00, 'description': 'Hotel San Diego'},
        {'date': '2024-08-20', 'amount': 290.00, 'description': 'Hotel San Diego'},
        {'date': '2024-08-21', 'amount': 130.00, 'description': 'Meals San Diego'},
        {'date': '2024-09-08', 'amount': 820.00, 'description': 'Flight to Las Vegas'},
        {'date': '2024-09-09', 'amount': 380.00, 'description': 'Hotel Las Vegas'},
        {'date': '2024-09-10', 'amount': 380.00, 'description': 'Hotel Las Vegas'},
        {'date': '2024-09-11', 'amount': 175.00, 'description': 'Meals Las Vegas'},
    ],
}

# Custom budgets (only Bob has one)
custom_budgets = {
    2: {'amount': 7000.00, 'reason': 'International travel required'},
}


async def get_team_members(department: str) -> dict[str, Any]:
    """Get list of team members for a department.

    Args:
        department: The department name (e.g., "Engineering").

    Returns:
        Dictionary with list of team members.
    """
    return {'department': department, 'members': team_members}


async def get_expenses(user_id: int, quarter: str, category: str) -> dict[str, Any]:
    """Get expense line items for a user.

    Args:
        user_id: The user's ID.
        quarter: The quarter (e.g., "Q3").
        category: The expense category (e.g., "travel").

    Returns:
        Dictionary with expense items.
    """
    items = expenses.get(user_id, [])
    return {'user_id': user_id, 'quarter': quarter, 'category': category, 'items': items}


async def get_custom_budget(user_id: int) -> dict[str, Any] | None:
    """Get custom budget for a user if they have one.

    Args:
        user_id: The user's ID.

    Returns:
        Custom budget info or None if no custom budget.
    """
    custom_budgets.get(user_id)




------------------------------------------
File: examples/expense_analysis/main.py
------------------------------------------

import data

import pydantic_monty

type_definitions = '''
from typing import Any

async def get_team_members(department: str) -> dict[str, Any]:
    """Get list of team members for a department.
    Args:
        department: The department name (e.g., "Engineering").
    Returns:
        Dictionary with list of team members.
    """
    ...

async def get_expenses(user_id: int, quarter: str, category: str) -> dict[str, Any]:
    """Get expense line items for a user.
    Args:
        user_id: The user's ID.
        quarter: The quarter (e.g., "Q3").
        category: The expense category (e.g., "travel").
    Returns:
        Dictionary with expense items.
    """
    ...

async def get_custom_budget(user_id: int) -> dict[str, Any] | None:
    """Get custom budget for a user if they have one.
    Args:
        user_id: The user's ID.
    Returns:
        Custom budget info or None if no custom budget.
    """
    ...
'''

code = """
# Get Engineering team members
team_data = await get_team_members(department="Engineering")
team_members = team_data.get("members", [])

# Standard budget
STANDARD_BUDGET = 5000

# Process each team member
total_members = len(team_members)
over_budget_list = []

for member in team_members:
    user_id = member.get("id")
    name = member.get("name")

    # Get Q3 travel expenses for this user
    expenses_data = await get_expenses(user_id=user_id, quarter="Q3", category="travel")
    expense_items = expenses_data.get("expenses", [])

    # Sum up total expenses
    total_spent = sum(item.get("amount", 0) for item in expense_items)

    # Check if they exceeded standard budget
    if total_spent > STANDARD_BUDGET:
        # Check for custom budget
        custom_budget_data = await get_custom_budget(user_id=user_id)

        if custom_budget_data is not None:
            budget = custom_budget_data.get("budget", STANDARD_BUDGET)
        else:
            budget = STANDARD_BUDGET

        # Check if they exceeded their actual budget (standard or custom)
        if total_spent > budget:
            amount_over = total_spent - budget
            over_budget_list.append({
                "name": name,
                "total_spent": total_spent,
                "budget": budget,
                "amount_over": amount_over
            })

# Return the analysis
{
    "total_team_members_analyzed": total_members,
    "count_exceeded_budget": len(over_budget_list),
    "over_budget_details": over_budget_list
}
"""


m = pydantic_monty.Monty(
    code,
    inputs=['prompt'],
    external_functions=['get_team_members', 'get_expenses', 'get_custom_budget'],
    script_name='expense.py',
    type_check=True,
    type_check_stubs=type_definitions,
)


async def main():
    output = await pydantic_monty.run_monty_async(
        m,
        inputs={'prompt': 'testing'},
        external_functions={
            'get_team_members': data.get_team_members,
            'get_expenses': data.get_expenses,
            'get_custom_budget': data.get_custom_budget,
        },
    )
    print(output)


if __name__ == '__main__':
    import asyncio

    asyncio.run(main())




------------------------------------------
File: examples/expense_analysis/README.md
------------------------------------------

# Team Expense Analysis

From [this](https://platform.claude.com/cookbook/tool-use-programmatic-tool-calling-ptc#understanding-the-third-party-api) Anthropic example.




------------------------------------------
File: examples/README.md
------------------------------------------

# Monty Examples

Numerous examples of what monty can do, and how.




------------------------------------------
File: examples/sql_playground/external_functions.py
------------------------------------------

from __future__ import annotations

import json
import tempfile
from dataclasses import dataclass
from pathlib import PurePosixPath
from typing import Any

from pydantic_monty import OSAccess

try:
    import duckdb
except ImportError as e:
    raise ImportError('duckdb is required for query_csv. Install with: pip install duckdb') from e


@dataclass
class ExternalFunctions:
    fs: OSAccess

    async def query_csv(
        self, filepath: PurePosixPath, sql: str, parameters: dict[str, Any] | None = None
    ) -> list[dict[str, Any]]:
        """Execute SQL query on a CSV file using DuckDB.

        Args:
            filepath: Path to the CSV file in the virtual filesystem.
            sql: SQL query to execute. The CSV data is available as a table named 'data'.
            parameters: Optional dictionary of parameters to bind to the SQL query.

        Returns:
            List of dictionaries, one per row, with column names as keys.
        """
        # Read CSV content from virtual filesystem
        content = self.fs.path_read_bytes(filepath)

        # Write to a temporary file for DuckDB to read
        # (DuckDB's read_csv_auto works best with file paths)
        with tempfile.NamedTemporaryFile(mode='wb', suffix='.csv') as tmp:
            tmp.write(content)
            tmp.flush()

            conn = duckdb.connect(':memory:')
            # Create table from CSV
            # NOTE! duckdb (horribly) reads locals as tables, hence `data` here that isn't used
            data = conn.read_csv(tmp.name)
            # Execute the user's query
            result_rel = conn.execute(sql, parameters)
            del data
        # Get column names and rows, then convert to list of dicts
        columns = [desc[0] for desc in result_rel.description]
        rows = result_rel.fetchall()
        return [dict(zip(columns, row)) for row in rows]

    async def read_json(self, filepath: PurePosixPath) -> list[Any] | dict[str, Any]:
        """Read and parse a JSON file from the virtual filesystem.

        Args:
            filepath: Path to the JSON file in the virtual filesystem.

        Returns:
            Parsed JSON data (list or dict).
        """
        content = self.fs.path_read_text(filepath)
        return json.loads(content)

    @staticmethod
    async def analyze_sentiment(text: str) -> float:
        """Analyze sentiment of text using simple keyword matching.

        This is a basic sentiment analyzer that scores text based on
        the presence of positive and negative keywords. For production use,
        you would want to use a proper NLP library or API.

        Args:
            text: The text to analyze.

        Returns:
            Sentiment score from -1.0 (very negative) to +1.0 (very positive).
            A score of 0.0 indicates neutral sentiment.

        Example:
            >>> await analyze_sentiment('This product is amazing!')
            0.3
        """
        positive_words = [
            'amazing',
            'great',
            'love',
            'thank',
            'helpful',
            'a+',
            'good',
            'best',
            'excellent',
            'awesome',
            'fantastic',
            'wonderful',
            'glad',
            'enjoy',
            'better',
        ]
        negative_words = [
            'bad',
            'angry',
            'hate',
            'terrible',
            'worst',
            'fraud',
            'awful',
            'horrible',
            'disappointed',
            'poor',
            'useless',
        ]

        score = 0.0
        text_lower = text.lower()

        for word in positive_words:
            if word in text_lower:
                score += 0.3

        for word in negative_words:
            if word in text_lower:
                score -= 0.3

        # Clamp score to [-1, 1]
        return max(-1.0, min(1.0, score))




------------------------------------------
File: examples/sql_playground/main.py
------------------------------------------

"""SQL Playground Example: Customer Sentiment Analysis with SQL and JSON."""

from __future__ import annotations

import asyncio
from pathlib import Path

from external_functions import ExternalFunctions

import pydantic_monty
from pydantic_monty import MemoryFile, OSAccess

# Path to the mafudge datasets repository (adjust if needed)
THIS_DIR = Path(__file__).parent
REPO_ROOT = THIS_DIR.parent.parent
MAFUDGE_DATASETS = (REPO_ROOT / '..' / 'mafudge_datasets').resolve()
assert MAFUDGE_DATASETS.is_dir(), f'mafudge_datasets directory not found at {MAFUDGE_DATASETS}. '
SANDBOX_CODE_PATH = THIS_DIR / 'sandbox_code.py'

TYPE_STUBS = (THIS_DIR / 'type_stubs.pyi').read_text()
SANDBOX_CODE = SANDBOX_CODE_PATH.read_text()

# Read file contents
customers_csv = (MAFUDGE_DATASETS / 'customers' / 'customers.csv').read_text()
surveys_csv = (MAFUDGE_DATASETS / 'customers' / 'surveys.csv').read_text()
tweets_json = (MAFUDGE_DATASETS / 'tweets' / 'tweets.json').read_text()

# Create virtual filesystem with mounted files
fs = OSAccess(
    [
        MemoryFile('/data/customers/customers.csv', content=customers_csv),
        MemoryFile('/data/customers/surveys.csv', content=surveys_csv),
        MemoryFile('/data/tweets/tweets.json', content=tweets_json),
    ]
)


async def main():
    """Run the customer sentiment analysis in the Monty sandbox.

    Returns:
        List of analysis results for top customers with sentiment scores.
    """
    # Set up the virtual filesystem with data files

    # Create external functions that can access the filesystem
    external_funcs = ExternalFunctions(fs)

    # Create the Monty runner with type checking enabled
    m = pydantic_monty.Monty(
        SANDBOX_CODE_PATH.read_text(),
        script_name='sql_playground.py',
        external_functions=['query_csv', 'read_json', 'analyze_sentiment'],
        type_check=True,
        type_check_stubs=TYPE_STUBS,
    )

    # Run the analysis with external functions and OS access
    results = await pydantic_monty.run_monty_async(
        m,
        external_functions={
            'query_csv': external_funcs.query_csv,
            'read_json': external_funcs.read_json,
            'analyze_sentiment': external_funcs.analyze_sentiment,
        },
        os=fs,
    )

    if not results:
        print('No results found. Check if customers have matching Twitter handles and tweets.')
    for r in results:
        sentiment_emoji = '😊' if r['avg_sentiment'] > 0 else '😐' if r['avg_sentiment'] == 0 else '😞'
        print(f'  {r["name"]}')
        print(f'    Purchases: ${r["total_purchases"]:,}')
        print(f'    Twitter: @{r["twitter"]}')
        print(f'    Tweets: {r["tweet_count"]}')
        print(f'    Sentiment: {r["avg_sentiment"]:+.2f} {sentiment_emoji}')
        print()


if __name__ == '__main__':
    asyncio.run(main())




------------------------------------------
File: examples/sql_playground/README.md
------------------------------------------

# SQL Playground: Customer Sentiment Analysis

This example demonstrates using Monty for a task that **cannot be solved with a single SQL query**: analyzing customer purchase data (CSV) and correlating it with their social media sentiment (JSON tweets).

Data is from <https://github.com/mafudge/datasets>.

## Why This Example is Interesting

1. **Cross-format data joining**: CSV customer data must join with JSON tweets via Twitter handle - requires programmatic data wrangling
2. **Loop-based external calls**: Sentiment analysis for each tweet happens in a loop - with JSON tool calling this would flood the context window with 50+ results
3. **In-sandbox computation**: Averages, correlation, and aggregation happen in Python - no need for the LLM to do mental math
4. **Variable iteration**: Different customers have different numbers of tweets - code handles this naturally
5. **File sandboxing**: Uses `OSAccess` to mount data files, demonstrating secure file access patterns
6. **Type checking**: Validates LLM-generated code against type stubs before execution

## To run

```bash
uv run python examples/sql_playground/main.py
```




------------------------------------------
File: examples/sql_playground/sandbox_code.py
------------------------------------------

"""Sandboxed analysis code that runs inside Monty.

This code is executed in the Monty sandbox with access to external functions
for SQL queries, JSON parsing, and sentiment analysis.
"""

from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from type_stubs import analyze_sentiment, query_csv, read_json


async def main():
    # Step 1: Query top 10 customers by total purchases
    print('getting top customers...')
    top_customers = await query_csv(
        filepath=Path('/data/customers/customers.csv'),
        sql="""
        SELECT "First", "Last", "Email", "Total Purchased" as TotalPurchased
        FROM data
        ORDER BY "Total Purchased"
        DESC LIMIT 10
        """,
    )

    # Step 2: Get their Twitter handles from the survey data
    emails: list[str] = [c['Email'] for c in top_customers]
    print('getting twitter handles...')
    twitter_handles = await query_csv(
        Path('/data/customers/surveys.csv'),
        f"""
        SELECT "Email", "Twitter Username" as Twitter
        FROM data
        WHERE "Email" IN $emails
        """,
        parameters={'emails': emails},
    )
    email_to_twitter = {row['Email']: row['Twitter'] for row in twitter_handles}

    # Step 3: Load all tweets
    tweets = await read_json(filepath=Path('/data/tweets/tweets.json'))
    assert isinstance(tweets, list)

    print(f'processing {len(top_customers)} customers...')

    # Step 4: For each customer, find their tweets and analyze sentiment
    results: list[dict[str, object]] = []
    for customer in top_customers:
        twitter = email_to_twitter.get(customer['Email'])
        if not twitter:
            continue

        # Find tweets by this user
        user_tweets = [t for t in tweets if t['user'] == twitter]
        if not user_tweets:
            continue

        # Analyze sentiment of each tweet
        sentiments: list[float] = []
        for tweet in user_tweets:
            score = await analyze_sentiment(text=tweet['text'])
            sentiments.append(score)

        # Calculate average sentiment
        avg_sentiment = sum(sentiments) / len(sentiments)
        print(f'{customer["First"]} {customer["Last"]} - {avg_sentiment=}')

        results.append(
            {
                'name': f'{customer["First"]} {customer["Last"]}',
                'total_purchases': customer['TotalPurchased'],
                'twitter': twitter,
                'tweet_count': len(user_tweets),
                'avg_sentiment': round(avg_sentiment, 2),
            }
        )
        return results


# Return the analysis results
await main()  # pyright: ignore




------------------------------------------
File: examples/sql_playground/type_stubs.pyi
------------------------------------------

from pathlib import Path
from typing import Any

async def query_csv(filepath: Path, sql: str, parameters: dict[str, Any] | None = None) -> list[dict[str, Any]]:
    """Execute SQL query on a CSV file using DuckDB."""
    ...

async def read_json(filepath: Path) -> list[Any] | dict[str, Any]:
    """Read and parse a JSON file."""
    ...

async def analyze_sentiment(text: str) -> float:
    """Analyze sentiment of text. Returns score from -1.0 to +1.0."""
    ...




------------------------------------------
File: README.md
------------------------------------------

<div align="center">
  <h1>Monty</h1>
</div>
<div align="center">
  <h3>A minimal, secure Python interpreter written in Rust for use by AI.</h3>
</div>
<div align="center">
  <a href="https://github.com/pydantic/monty/actions/workflows/ci.yml?query=branch%3Amain"><img src="https://github.com/pydantic/monty/actions/workflows/ci.yml/badge.svg" alt="CI"></a>
  <a href="https://codspeed.io/pydantic/monty?utm_source=badge"><img src="https://img.shields.io/badge/CodSpeed-Performance%20Tracked-blue?logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOCAwTDAgOEw4IDE2TDE2IDhMOCAwWiIgZmlsbD0id2hpdGUiLz48L3N2Zz4=" alt="Codspeed"></a>
  <a href="https://codecov.io/gh/pydantic/monty"><img src="https://codecov.io/gh/pydantic/monty/graph/badge.svg?token=HX4RDQX5OG" alt="Coverage"></a>
  <a href="https://pypi.python.org/pypi/pydantic-monty"><img src="https://img.shields.io/pypi/v/pydantic-monty.svg" alt="PyPI"></a>
  <a href="https://github.com/pydantic/monty"><img src="https://img.shields.io/pypi/pyversions/pydantic-monty.svg" alt="versions"></a>
  <a href="https://github.com/pydantic/monty/blob/main/LICENSE"><img src="https://img.shields.io/github/license/pydantic/monty.svg?v=2" alt="license"></a>
  <a href="https://logfire.pydantic.dev/docs/join-slack/"><img src="https://img.shields.io/badge/Slack-Join%20Slack-4A154B?logo=slack" alt="Join Slack" /></a>
</div>

---

**Experimental** - This project is still in development, and not ready for the prime time.

A minimal, secure Python interpreter written in Rust for use by AI.

Monty avoids the cost, latency, complexity and general faff of using a full container based sandbox for running LLM generated code.

Instead, it lets you safely run Python code written by an LLM embedded in your agent, with startup times measured in single digit microseconds not hundreds of milliseconds.

What Monty **can** do:
* Run a reasonable subset of Python code - enough for your agent to express what it wants to do
* Completely block access to the host environment: filesystem, env variables and network access are all implemented via external function calls the developer can control
* Call functions on the host - only functions you give it access to
* Run typechecking - monty supports full modern python type hints and comes with [ty](https://docs.astral.sh/ty/) included in a single binary to run typechecking
* Be snapshotted to bytes at external function calls, meaning you can store the interpreter state in a file or database, and resume later
* Startup extremely fast (<1μs to go from code to execution result), and has runtime performance that is similar to CPython (generally between 5x faster and 5x slower)
* Be called from Rust, Python, or Javascript - because Monty has no dependencies on cpython, you can use it anywhere you can run Rust
* Control resource usage - Monty can track memory usage, allocations, stack depth, and execution time and cancel execution if it exceeds preset limits
* Collect stdout and stderr and return it to the caller
* Run async or sync code on the host via async or sync code on the host

What Monty **cannot** do:
* Use the standard library (except a few select modules: `sys`, `typing`, `asyncio`, `dataclasses` (soon), `json` (soon))
* Use third party libraries (like Pydantic), support for external python library is not a goal
* define classes (support should come soon)
* use match statements (again, support should come soon)

---

In short, Monty is extremely limited and designed for **one** use case:

**To run code written by agents.**

For motivation on why you might want to do this, see:
* [Codemode](https://blog.cloudflare.com/code-mode/) from Cloudflare
* [Programmatic Tool Calling](https://platform.claude.com/docs/en/agents-and-tools/tool-use/programmatic-tool-calling) from Anthropic
* [Code Execution with MCP](https://www.anthropic.com/engineering/code-execution-with-mcp) from Anthropic
* [Smol Agents](https://github.com/huggingface/smolagents) from Hugging Face

In very simple terms, the idea of all the above is that LLMs can work faster, cheaper and more reliably if they're asked to write Python (or Javascript) code, instead of relying on traditional tool calling. Monty makes that possible without the complexity of a sandbox or risk of running code directly on the host.

**Note:** Monty will (soon) be used to implement `codemode` in [Pydantic AI](https://github.com/pydantic/pydantic-ai)

## Usage

Monty can be called from Python, JavaScript/TypeScript or Rust.

### Python

To install:

```bash
uv add pydantic-monty
```

(Or `pip install pydantic-monty` for the boomers)

Usage:

```python
from typing import Any

import pydantic_monty

code = """
async def agent(prompt: str, messages: Messages):
    while True:
        print(f'messages so far: {messages}')
        output = await call_llm(prompt, messages)
        if isinstance(output, str):
            return output
        messages.extend(output)

await agent(prompt, [])
"""

type_definitions = """
from typing import Any

Messages = list[dict[str, Any]]

async def call_llm(prompt: str, messages: Messages) -> str | Messages:
    raise NotImplementedError()

prompt: str = ''
"""

m = pydantic_monty.Monty(
    code,
    inputs=['prompt'],
    external_functions=['call_llm'],
    script_name='agent.py',
    type_check=True,
    type_check_stubs=type_definitions,
)


Messages = list[dict[str, Any]]


async def call_llm(prompt: str, messages: Messages) -> str | Messages:
    if len(messages) < 2:
        return [{'role': 'system', 'content': 'example response'}]
    else:
        return f'example output, message count {len(messages)}'


async def main():
    output = await pydantic_monty.run_monty_async(
        m,
        inputs={'prompt': 'testing'},
        external_functions={'call_llm': call_llm},
    )
    print(output)
    #> example output, message count 2


if __name__ == '__main__':
    import asyncio

    asyncio.run(main())
```

#### Iterative Execution with External Functions

Use `start()` and `resume()` to handle external function calls iteratively,
giving you control over each call:

```python
import pydantic_monty

code = """
data = fetch(url)
len(data)
"""

m = pydantic_monty.Monty(code, inputs=['url'], external_functions=['fetch'])

# Start execution - pauses when fetch() is called
result = m.start(inputs={'url': 'https://example.com'})

print(type(result))
#> <class 'pydantic_monty.MontySnapshot'>
print(result.function_name)  # fetch
#> fetch
print(result.args)
#> ('https://example.com',)

# Perform the actual fetch, then resume with the result
result = result.resume(return_value='hello world')

print(type(result))
#> <class 'pydantic_monty.MontyComplete'>
print(result.output)
#> 11
```

#### Serialization

Both `Monty` and `MontySnapshot` can be serialized to bytes and restored later.
This allows caching parsed code or suspending execution across process boundaries:

```python
import pydantic_monty

# Serialize parsed code to avoid re-parsing
m = pydantic_monty.Monty('x + 1', inputs=['x'])
data = m.dump()

# Later, restore and run
m2 = pydantic_monty.Monty.load(data)
print(m2.run(inputs={'x': 41}))
#> 42

# Serialize execution state mid-flight
m = pydantic_monty.Monty('fetch(url)', inputs=['url'], external_functions=['fetch'])
progress = m.start(inputs={'url': 'https://example.com'})
state = progress.dump()

# Later, restore and resume (e.g., in a different process)
progress2 = pydantic_monty.MontySnapshot.load(state)
result = progress2.resume(return_value='response data')
print(result.output)
#> response data
```

### Rust

```rust
use monty::{MontyRun, MontyObject, NoLimitTracker, StdPrint};

let code = r#"
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

fib(x)
"#;

let runner = MontyRun::new(code.to_owned(), "fib.py", vec!["x".to_owned()], vec![]).unwrap();
let result = runner.run(vec![MontyObject::Int(10)], NoLimitTracker, &mut StdPrint).unwrap();
assert_eq!(result, MontyObject::Int(55));
```

#### Serialization

`MontyRun` and `RunProgress` can be serialized using the `dump()` and `load()` methods:

```rust
use monty::{MontyRun, MontyObject, NoLimitTracker, StdPrint};

// Serialize parsed code
let runner = MontyRun::new("x + 1".to_owned(), "main.py", vec!["x".to_owned()], vec![]).unwrap();
let bytes = runner.dump().unwrap();

// Later, restore and run
let runner2 = MontyRun::load(&bytes).unwrap();
let result = runner2.run(vec![MontyObject::Int(41)], NoLimitTracker, &mut StdPrint).unwrap();
assert_eq!(result, MontyObject::Int(42));
```

## PydanticAI Integration

Monty will power code-mode in
[Pydantic AI](https://github.com/pydantic/pydantic-ai). Instead of making
sequential tool calls, the LLM writes Python code that calls your tools
as functions and Monty executes it safely.

```python test="skip"
from pydantic_ai import Agent
from pydantic_ai.toolsets.code_mode import CodeModeToolset
from pydantic_ai.toolsets.function import FunctionToolset
from typing_extensions import TypedDict


class WeatherResult(TypedDict):
    city: str
    temp_c: float
    conditions: str


toolset = FunctionToolset()


@toolset.tool
def get_weather(city: str) -> WeatherResult:
    """Get current weather for a city."""
    # your real implementation here
    return {'city': city, 'temp_c': 18, 'conditions': 'partly cloudy'}


@toolset.tool
def get_population(city: str) -> int:
    """Get the population of a city."""
    return {'london': 9_000_000, 'paris': 2_100_000, 'tokyo': 14_000_000}.get(
        city.lower(), 0
    )


toolset = CodeModeToolset(toolset)

agent = Agent(
    'anthropic:claude-sonnet-4-5',
    toolsets=[toolset],
)

result = agent.run_sync(
    'Compare the weather and population of London, Paris, and Tokyo.'
)
print(result.output)
```

# Alternatives

There are generally two responses when you show people Monty:

1. Oh my god, this solves so many problems, I want it.
2. Why not X?

Where X is some alternative technology. Oddly often these responses are combined, suggesting people have not yet found an alternative that works for them, but are incredulous that there's really no good alternative to creating an entire Python implementation from scratch.

I'll try to run through the most obvious alternatives, and why there aren't right for what we wanted.

NOTE: all these technologies are impressive and have widespread uses, this commentary on their limitations for our use case should not be seen as a criticism. Most of these solutions were not conceived with the goal of providing an LLM sandbox, which is why they're not necessary great at it.

| Tech               | Language completeness | Security     | Start latency  | FOSS       | Setup complexity | File mounting  | Snapshotting |
|--------------------|-----------------------|--------------|----------------|------------|------------------|----------------|--------------|
| Monty              | partial               | strict       | 0.06ms         | free / OSS | easy             | easy           | easy         |
| Docker             | full                  | good         | 195ms          | free / OSS | intermediate     | easy           | intermediate |
| Pyodide            | full                  | poor         | 2800ms         | free / OSS | intermediate     | easy           | hard         |
| starlark-rust      | very limited          | good         | 1.7ms          | free / OSS | easy             | not available? | impossible?  |
| WASI / Wasmer      | partial, almost full  | strict       | 66ms           | free *     | intermediate     | easy           | intermediate |
| sandboxing service | full                  | strict       | 1033ms         | not free   | intermediate     | hard           | intermediate |
| YOLO Python        | full                  | non-existent | 0.1ms / 30ms   | free / OSS | easy             | easy / scary   | hard         |

See [./scripts/startup_performance.py](scripts/startup_performance.py) for the script used to calculate the startup performance numbers.

Details on each row below:

### Monty

- **Language completeness**: No classes (yet), limited stdlib, no third-party libraries
- **Security**: Explicitly controlled filesystem, network, and env access, strict limits on execution time and memory usage
- **Start latency**: Starts in microseconds
- **Setup complexity**: just `pip install pydantic-monty` or `npm install @pydantic/monty`, ~4.5MB download
- **File mounting**: Strictly controlled, see [#85](https://github.com/pydantic/monty/pull/85)
- **Snapshotting**: Monty's pause and resume functionality with `dump()` and `load()` makes it trivial to pause, resume and fork execution

### Docker

- **Language completeness**: Full CPython with any library
- **Security**: Process and filesystem isolation, network policies, but container escapes exist, memory limitation is possible
- **Start latency**: Container startup overhead (~195ms measured)
- **Setup complexity**: Requires Docker daemon, container images, orchestration, `python:3.14-alpine` is 50MB - docker can't be installed from PyPI
- **File mounting**: Volume mounts work well
- **Snapshotting**: Possible with durable execution solutions like Temporal, or snapshotting an image and saving it as a Docker image.

### Pyodide

- **Language completeness**: Full CPython compiled to WASM, almost all libraries available
- **Security**: Relies on browser/WASM sandbox - not designed for server-side isolation, python code can run arbitrary code in the JS runtime, only deno allows isolation, memory limits are hard/impossible to enforce with deno
- **Start latency**: WASM runtime loading is slow (~2800ms cold start)
- **Setup complexity**: Need to load WASM runtime, handle async initialization, pyodide NPM package is ~12MB, deno is ~50MB - Pyodide can't be called with just PyPI packages
- **File mounting**: Virtual filesystem via browser APIs
- **Snapshotting**: Possible with durable execution solutions like Temporal presumably, but hard

### starlark-rust

See [starlark-rust](https://github.com/facebook/starlark-rust).

- **Language completeness**: Configuration language, not Python - no classes, exceptions, async
- **Security**: Deterministic and hermetic by design
- **Start latency**: runs embedded in the process like Monty, hence impressive startup time
- **Setup complexity**: Usable in python via [starlark-pyo3](https://github.com/inducer/starlark-pyo3)
- **File mounting**: No file handling by design AFAIK?
- **Snapshotting**: Impossible AFAIK?

### WASI / Wasmer

Running Python in WebAssembly via [Wasmer](https://wasmer.io/).

- **Language completeness**: Full CPython, pure Python external packages work via mounting, external packages with C bindings don't work
- **Security**: In principle WebAssembly should provide strong sandboxing guarantees.
- **Start latency**: The [wasmer](https://pypi.org/project/wasmer/) python package hasn't been updated for 3 years and I couldn't find docs on calling Python in wasmer from Python, so I called it via subprocess. Start latency was 66ms.
- **Setup complexity**: wasmer download is 100mb, the "python/python" package is 50mb.
- **FOSS**: I marked this as "free *" since the cost is zero but not everything seems to be open source. As of 2026-02-10 the [`python/python` wasmer package](https://wasmer.io/python/python) package has no readme, no license, no source link and no indication of how it's built, the recently uploaded versions show size as "0B" although the download is ~50MB - the build process for the Python binary is not clear and transparent. _(If I'm wrong here, please create an issue to correct correct me)_
- **File mounting**: Supported
- **Snapshotting**: Supported via journaling

### sandboxing service

Services like [Daytona](https://daytona.io), [E2B](https://e2b.dev), [Modal](https://modal.com).

There are similar challenges, more setup complexity but lower network latency for setting up your own sandbox setup with k8s.

- **Language completeness**: Full CPython with any library
- **Security**: Professionally managed container isolation
- **Start latency**: Network round-trip and container startup time. I got ~1s cold start time with Daytona EU from London, Daytona advertise sub 90ms latency, presumably that's for an existing container, not clear if it includes network latency
- **FOSS**: Pay per execution or compute time, some implementations are open source
- **Setup complexity**: API integration, auth tokens - fine for startups but generally a non-start for enterprises
- **File mounting**: Upload/download via API calls
- **Snapshotting**: Possible with durable execution solutions like Temporal, also the services offer some solutions for this, I think based con docker containers

### YOLO Python

Running Python directly via `exec()` (~0.1ms) or subprocess (~30ms).

- **Language completeness**: Full CPython with any library
- **Security**: None - full filesystem, network, env vars, system commands
- **Start latency**: Near-zero for `exec()`, ~30ms for subprocess
- **Setup complexity**: None
- **File mounting**: Direct filesystem access (that's the problem)
- **Snapshotting**: Possible with durable execution solutions like Temporal




------------------------------------------
File: scripts/check_imports.py
------------------------------------------

#!/usr/bin/env python3
"""Check that all `use` statements in Rust files are at the top of the file.

Exits with code 1 if any misplaced imports are found.
"""

import re
import sys
from pathlib import Path


def check_file(path: Path) -> list[str]:
    """Check a single Rust file for misplaced imports.

    Returns a list of error messages for any `use` statements found after
    the import block (i.e., after non-import code has started).

    Handles these valid patterns:
    - mod declarations followed by pub use re-exports
    - use statements inside mod/fn/impl blocks (tracked via brace depth)
    """
    errors: list[str] = []
    past_imports = False
    brace_depth = 0

    # Patterns that are allowed before/during the import block at top level
    allowed_pattern = re.compile(
        r'^(\s*$'  # empty lines
        r'|//[!/]'  # doc comments (//! or ///)
        r'|//'  # regular comments
        r'|/\*'  # block comment start
        r'|\*'  # block comment continuation
        r'|\*/'  # block comment end
        r'|#\['  # attributes
        r'|#!\['  # inner attributes
        r'|pub use '  # pub use statements
        r'|use '  # use statements
        r'|(pub )?mod (r#)?\w+;'  # mod declarations (mod foo; or pub mod r#type;)
        r'|\}'  # closing braces
        r')'
    )

    use_pattern = re.compile(r'^use |^pub use ')

    with open(path) as f:
        for line_num, line in enumerate(f, 1):
            stripped = line.strip()

            # Track brace depth to detect when we're inside a block
            brace_depth += line.count('{') - line.count('}')

            # Only check top-level imports (brace_depth == 0)
            if brace_depth > 0:
                continue

            # Skip allowed lines if we haven't passed the import block
            if not past_imports and allowed_pattern.match(stripped):
                continue

            # Once we see a non-allowed line at top level, we're past imports
            if not past_imports and stripped:
                past_imports = True

            # Check for use statements after the import block at top level
            if past_imports and use_pattern.match(stripped):
                errors.append(f'{path}:{line_num}: {stripped}')

    return errors


def main() -> int:
    """Find all Rust files and check for misplaced imports."""
    all_errors: list[str] = []

    for rs_file in Path('./crates').rglob('*.rs'):
        all_errors += check_file(rs_file)

    if all_errors:
        print('Error: Found `use` statements outside the import block:', file=sys.stderr)
        print('Move these imports to the top of the file.', file=sys.stderr)
        print(file=sys.stderr)
        for error in all_errors:
            print(error, file=sys.stderr)
        return 1

    return 0


if __name__ == '__main__':
    sys.exit(main())




------------------------------------------
File: scripts/codecov_diff.py
------------------------------------------

"""
Fetch coverage diff from Codecov for a GitHub pull request.

This script uses Codecov's GraphQL API to fetch line-by-line coverage
information and outputs a text file with the coverage diff.

See https://x.com/samuelcolvin/status/2019838805210198289 for rationale.

Usage:
    uv run scripts/codecov_diff.py [-h] [--org ORG] [--repo REPO] [pr-number]

By default, the org, repo and PR are auto-detected using the gh CLI.
"""

from __future__ import annotations

import argparse
import json
import subprocess
import sys
from typing import Any

import httpx

CODECOV_GRAPHQL_URL = 'https://api.codecov.io/graphql/gh'

# GraphQL query to get PR overview and impacted files
PULL_QUERY = """
query Pull($owner: String!, $repo: String!, $pullId: Int!) {
  owner(username: $owner) {
    repository(name: $repo) {
      __typename
      ... on Repository {
        pull(id: $pullId) {
          pullId
          title
          state
          head {
            commitid
            coverageAnalytics {
              totals {
                percentCovered
              }
            }
          }
          compareWithBase {
            __typename
            ... on Comparison {
              state
              patchTotals {
                percentCovered
              }
              headTotals {
                percentCovered
              }
              changeCoverage
              impactedFiles {
                __typename
                ... on ImpactedFiles {
                  results {
                    fileName
                    headName
                    missesCount
                    patchCoverage {
                      percentCovered
                    }
                    headCoverage {
                      percentCovered
                    }
                    changeCoverage
                  }
                }
              }
            }
            ... on FirstPullRequest {
              message
            }
            ... on MissingBaseCommit {
              message
            }
            ... on MissingHeadCommit {
              message
            }
            ... on MissingComparison {
              message
            }
            ... on MissingBaseReport {
              message
            }
            ... on MissingHeadReport {
              message
            }
          }
        }
      }
      ... on NotFoundError {
        message
      }
      ... on OwnerNotActivatedError {
        message
      }
    }
  }
}
"""

# GraphQL query to get line-level coverage for a specific file
FILE_COVERAGE_QUERY = """
query ImpactedFileComparison($owner: String!, $repo: String!, $pullId: Int!, $path: String!) {
  owner(username: $owner) {
    repository(name: $repo) {
      __typename
      ... on Repository {
        pull(id: $pullId) {
          compareWithBase {
            __typename
            ... on Comparison {
              impactedFile(path: $path) {
                headName
                patchCoverage {
                  percentCovered
                }
                segments {
                  __typename
                  ... on SegmentComparisons {
                    results {
                      header
                      lines {
                        baseNumber
                        headNumber
                        baseCoverage
                        headCoverage
                        content
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
"""


def get_repo_from_gh() -> tuple[str, str] | None:
    """Get the current repository's owner and name using gh CLI."""
    try:
        result = subprocess.run(
            ['gh', 'repo', 'view', '--json', 'owner,name'],
            capture_output=True,
            text=True,
            check=True,
        )
        data = json.loads(result.stdout)
        return data['owner']['login'], data['name']
    except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError, FileNotFoundError):
        return None


def get_pr_from_gh() -> int | None:
    """Get the current PR number for the current branch using gh CLI."""
    try:
        result = subprocess.run(
            ['gh', 'pr', 'view', '--json', 'number'],
            capture_output=True,
            text=True,
            check=True,
        )
        data = json.loads(result.stdout)
        return data['number']
    except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError, FileNotFoundError):
        return None


def graphql_request(query: str, variables: dict[str, Any]) -> dict[str, Any]:
    """Make a GraphQL request to Codecov API."""
    with httpx.Client(timeout=30.0) as client:
        response = client.post(
            CODECOV_GRAPHQL_URL,
            json={'query': query, 'variables': variables},
            headers={'Content-Type': 'application/json'},
        )
        response.raise_for_status()
        return response.json()


def get_pull_coverage(org: str, repo: str, pr_number: int) -> dict[str, Any] | None:
    """Fetch PR coverage overview from Codecov."""
    result = graphql_request(PULL_QUERY, {'owner': org, 'repo': repo, 'pullId': pr_number})

    # Navigate to the pull data
    data = result.get('data', {})
    owner = data.get('owner', {})
    repository = owner.get('repository', {})

    if repository.get('__typename') != 'Repository':
        print(f'Error: {repository.get("message", "Repository not found")}', file=sys.stderr)
        return None

    pull = repository.get('pull')
    if not pull:
        print('Error: Pull request not found', file=sys.stderr)
        return None

    return pull


def get_file_coverage(org: str, repo: str, pr_number: int, file_path: str) -> dict[str, Any] | None:
    """Fetch line-level coverage for a specific file."""
    result = graphql_request(
        FILE_COVERAGE_QUERY,
        {'owner': org, 'repo': repo, 'pullId': pr_number, 'path': file_path},
    )

    # Navigate to the file data
    data = result.get('data', {})
    owner = data.get('owner', {})
    repository = owner.get('repository', {})

    if repository.get('__typename') != 'Repository':
        return None

    pull = repository.get('pull', {})
    compare = pull.get('compareWithBase', {})

    if compare.get('__typename') != 'Comparison':
        return None

    return compare.get('impactedFile')


def parse_line_coverage(segments: list[dict[str, Any]]) -> tuple[list[int], list[int]]:
    """
    Parse segments to extract uncovered and partial line numbers.

    Coverage values from Codecov:
    - "H" = hit (covered)
    - "M" = miss (uncovered)
    - "P" = partial
    - null = not applicable (e.g., blank line, comment)
    """
    uncovered: list[int] = []
    partial: list[int] = []

    for segment in segments:
        lines = segment.get('lines', [])
        for line in lines:
            head_num = line.get('headNumber')
            head_cov = line.get('headCoverage')

            if head_num is None:
                continue

            # Convert to int since API returns strings
            head_num = int(head_num)

            if head_cov == 'M':
                uncovered.append(head_num)
            elif head_cov == 'P':
                partial.append(head_num)

    return sorted(set(uncovered)), sorted(set(partial))


def format_line_ranges(lines: list[int]) -> str:
    """Format a list of line numbers as ranges where consecutive."""
    if not lines:
        return ''

    ranges: list[str] = []
    start = lines[0]
    end = lines[0]

    for line in lines[1:]:
        if line == end + 1:
            end = line
        else:
            if start == end:
                ranges.append(str(start))
            else:
                ranges.append(f'{start}-{end}')
            start = end = line

    # Don't forget the last range
    if start == end:
        ranges.append(str(start))
    else:
        ranges.append(f'{start}-{end}')

    return ', '.join(ranges)


def format_percentage(value: float | None) -> str:
    """Format a percentage value."""
    if value is None:
        return 'N/A'
    return f'{value:.2f}%'


def fetch_codecov_coverage(org: str, repo: str, pr_number: int) -> None:
    """Fetch and print coverage data from Codecov for a GitHub PR."""
    url = f'https://app.codecov.io/gh/{org}/{repo}/pull/{pr_number}'

    pull = get_pull_coverage(org, repo, pr_number)
    if not pull:
        print(f'Error: Could not fetch coverage for {org}/{repo} PR #{pr_number}')
        return

    print(f'Coverage Report for {org}/{repo} PR #{pr_number}')
    print(f'URL: {url}')
    print(f'Title: {pull.get("title", "N/A")}')
    print(f'State: {pull.get("state", "N/A")}')
    print()

    compare = pull.get('compareWithBase', {})
    if compare.get('__typename') != 'Comparison':
        print(f'# Note: {compare.get("message", "No comparison available")}')
        return

    head_totals = compare.get('headTotals', {})
    patch_totals = compare.get('patchTotals', {})
    change = compare.get('changeCoverage')

    print(f'HEAD Coverage: {format_percentage(head_totals.get("percentCovered"))}')
    print(f'Patch Coverage: {format_percentage(patch_totals.get("percentCovered"))}')
    if change is not None:
        print(f'Change: {change:+.2f}%')
    print()

    impacted = compare.get('impactedFiles', {})
    if impacted.get('__typename') != 'ImpactedFiles':
        print('# No impacted files found')
        return

    for file_info in impacted.get('results', []):
        file_path = file_info.get('headName') or file_info.get('fileName')
        if not file_path:
            continue

        missed = file_info.get('missesCount', 0)
        patch_cov_data = file_info.get('patchCoverage')
        patch_cov = patch_cov_data.get('percentCovered') if patch_cov_data else None

        print(f'## {file_path}')
        if missed:
            print(f'   Missed: {missed} lines')
        if patch_cov is not None:
            print(f'   Patch: {patch_cov:.2f}%')

        if patch_cov is not None and patch_cov >= 100.0:
            print('   All changed lines covered!')
            print()
            continue

        file_data = get_file_coverage(org, repo, pr_number, file_path)
        if file_data:
            segments_data = file_data.get('segments', {})
            if segments_data.get('__typename') == 'SegmentComparisons':
                segments = segments_data.get('results', [])
                uncovered, partial = parse_line_coverage(segments)

                if uncovered:
                    print(f'   Uncovered lines: {format_line_ranges(uncovered)}')
                if partial:
                    print(f'   Partial lines: {format_line_ranges(partial)}')

                if not uncovered and not partial:
                    if missed:
                        print('   (Coverage details not available)')
                    else:
                        print('   All changed lines covered!')
            else:
                print('   (Line coverage not available)')
        else:
            print('   (Could not fetch line coverage)')

        print()


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('pr', nargs='?', type=int, help='Pull request number (auto-detected if not provided)')
    parser.add_argument('--org', help='GitHub organization name (auto-detected if not provided)')
    parser.add_argument('--repo', help='Repository name (auto-detected if not provided)')
    args = parser.parse_args()

    org = args.org
    repo = args.repo
    if not org or not repo:
        repo_info = get_repo_from_gh()
        if repo_info:
            org, repo = repo_info
        else:
            print('Error: Could not detect repository. Use --org and --repo.', file=sys.stderr)
            sys.exit(1)

    pr_number = args.pr
    if not pr_number:
        pr_number = get_pr_from_gh()
        if not pr_number:
            print('Error: Could not detect PR number. Provide PR number as argument.', file=sys.stderr)
            sys.exit(1)

    fetch_codecov_coverage(org, repo, pr_number)


if __name__ == '__main__':
    main()




------------------------------------------
File: scripts/complete_tests.py
------------------------------------------

"""
Complete test expectations using CPython.

Scans test_cases/*.py files for incomplete expectations (e.g., `# Return=` with no value)
and fills them in by running the code through CPython.

Supported incomplete patterns:
- `# Return=`      -> fills with repr() of result
- `# Return.str=`  -> fills with str() of result
- `# Return.type=` -> fills with type name of result
- `# Raise=`       -> fills with exception type and message
"""

import re
from pathlib import Path
from typing import Any


def get_cpython_result(code: str, expect_type: str) -> str:
    """Run code through CPython and return the formatted result."""
    # Wrap code in a function that returns the last expression
    lines = code.strip().split('\n')
    last_idx = len(lines) - 1

    # Find last non-empty line
    while last_idx >= 0 and not lines[last_idx].strip():
        last_idx -= 1

    if last_idx < 0:
        raise ValueError('Empty code')

    # Build wrapped function
    if expect_type == 'Raise':
        # For exceptions, don't add return
        func_body = '\n'.join(f'    {line}' if line.strip() else '' for line in lines[: last_idx + 1])
    else:
        # Add return to last line
        func_body = '\n'.join(f'    {line}' if line.strip() else '' for line in lines[:last_idx])
        if func_body:
            func_body += '\n'
        func_body += f'    return {lines[last_idx]}'

    wrapped = f'def __test__():\n{func_body}\n'

    # Execute and get result
    namespace: dict[str, Any] = {}
    exec(wrapped, namespace)

    try:
        result = namespace['__test__']()
        if expect_type == 'Return':
            return repr(result)
        elif expect_type == 'Return.str':
            return str(result)
        elif expect_type == 'Return.type':
            return type(result).__name__
        elif expect_type == 'Raise':
            raise RuntimeError('Expected exception but code completed normally')
        else:
            raise ValueError(f'Unknown expect_type: {expect_type}')
    except Exception as e:
        if expect_type == 'Raise':
            exc_type = type(e).__name__
            msg = str(e)
            if not msg:
                return f'{exc_type}()'
            elif "'" in msg:
                return f'{exc_type}("{msg}")'
            else:
                return f"{exc_type}('{msg}')"
        else:
            raise


incomplete_re = re.compile(r'^# (Return|Return\.str|Return\.type|Raise)=')


def process_file(filepath: Path, dry_run: bool = False) -> bool:
    """Process a single test file. Returns True if file was updated."""
    content = filepath.read_text()
    lines = content.rstrip('\n').split('\n')

    if not lines:
        return False

    if '# test=monty' in lines:
        # testing only with monty, ignore
        return False

    last_line = lines[-1]

    match = incomplete_re.fullmatch(last_line)
    if not match:
        return False

    expect_type = match.group(1)

    code = '\n'.join(lines[:-1])
    result = get_cpython_result(code, expect_type)

    if result == '':
        # happens for empty strings
        return False

    # Update the file
    new_last_line = f'{last_line}{result}'
    lines[-1] = new_last_line
    new_content = '\n'.join(lines) + '\n'

    if dry_run:
        print(f'  Would updated {filepath.name} to assert {new_last_line!r}')
    else:
        filepath.write_text(new_content)
        print(f'  Updated {filepath.name} to assert {new_last_line!r}')

    return True


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Complete test expectations using CPython')
    parser.add_argument('--dry-run', '-n', action='store_true', help='Show what would be done without making changes')
    parser.add_argument('files', nargs='*', help='Specific files to process (default: all test_cases/*.py)')
    args = parser.parse_args()

    # Find test files
    script_dir = Path(__file__).parent
    test_cases_dir = script_dir.parent / 'test_cases'

    if args.files:
        files = [Path(f) for f in args.files]
    else:
        files = sorted(test_cases_dir.glob('*.py'))

    updated = 0
    for filepath in files:
        if process_file(filepath, dry_run=args.dry_run):
            updated += 1

    action = 'Would update' if args.dry_run else 'Updated'
    print(f'\n{action} {updated} file(s)')


if __name__ == '__main__':
    main()




------------------------------------------
File: scripts/flamegraph_to_text.py
------------------------------------------

#!/usr/bin/env python3
"""
Convert flamegraph SVGs to text format suitable for LLM reading.

This script finds all criterion flamegraph SVGs, copies them to ./flame/,
and generates corresponding .txt files with a hierarchical text representation.
"""

import re
import shutil
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import TypedDict


class Frame(TypedDict):
    """A single stack frame extracted from a flamegraph SVG."""

    name: str
    samples: int
    percentage: float
    y: float
    width: int


def parse_title(title: str) -> tuple[str, int, float] | None:
    """
    Parse a flamegraph title element.

    Returns (function_name, samples, percentage) or None if parsing fails.
    """
    # Match: "function_name (N samples, X.XX%)"
    match = re.match(r'^(.+?)\s+\((\d+)\s+samples?,\s+([\d.]+)%\)$', title)
    if match:
        return match.group(1), int(match.group(2)), float(match.group(3))
    return None


def extract_frames(svg_path: Path) -> list[Frame]:
    """
    Extract stack frames from a flamegraph SVG.

    Returns a list of Frame dicts with keys: name, samples, percentage, y, width.
    """
    tree = ET.parse(svg_path)
    root = tree.getroot()

    frames: list[Frame] = []

    # Find all g elements (they contain title and rect)
    for g in root.iter('{http://www.w3.org/2000/svg}g'):
        title_elem = g.find('{http://www.w3.org/2000/svg}title')
        rect_elem = g.find('{http://www.w3.org/2000/svg}rect')

        if title_elem is None or rect_elem is None:
            continue

        title_text = title_elem.text
        if not title_text:
            continue

        parsed = parse_title(title_text)
        if not parsed:
            continue

        name, samples, percentage = parsed

        # Get y position to determine depth (higher y = deeper in stack for bottom-up)
        y = float(rect_elem.get('y', 0))
        # Get width from fg:w attribute (sample count for this frame)
        fg_w = int(rect_elem.get('{http://github.com/jonhoo/inferno}w', samples))

        frames.append(
            {
                'name': name,
                'samples': samples,
                'percentage': percentage,
                'y': y,
                'width': fg_w,
            }
        )

    return frames


def frames_to_text(frames: list[Frame], benchmark_name: str) -> str:
    """
    Convert frames to a text representation suitable for LLM reading.

    Produces a hierarchical view sorted by sample count (hottest first).
    """
    if not frames:
        return f'# Flamegraph: {benchmark_name}\n\nNo frames found.\n'

    # Sort by samples descending to show hottest functions first
    sorted_frames = sorted(frames, key=lambda f: f['samples'], reverse=True)

    # Get total samples from the root frame (highest sample count)
    total_samples = sorted_frames[0]['samples'] if sorted_frames else 0

    lines = [
        f'# Flamegraph: {benchmark_name}',
        f'# Total samples: {total_samples}',
        '',
        '## Hot Functions (sorted by sample count)',
        '',
    ]

    # Show top functions with their percentages
    seen: set[str] = set()
    for frame in sorted_frames:
        name = frame['name']
        # Skip duplicates (same function at different stack depths)
        if name in seen:
            continue
        seen.add(name)

        samples = frame['samples']
        pct = frame['percentage']

        lines.append(f'{pct:6.2f}% [{samples:5d}] {name}')

    # Add a section showing unique call paths
    lines.extend(
        [
            '',
            '## Stack Frames (by depth)',
            '',
        ]
    )

    # Group frames by y position (depth) and sort
    by_depth: dict[float, list[Frame]] = {}
    for frame in frames:
        y = frame['y']
        if y not in by_depth:
            by_depth[y] = []
        by_depth[y].append(frame)

    # Sort depths (lower y = higher in stack for standard flamegraphs)
    for y in sorted(by_depth.keys(), reverse=True):
        depth_frames = sorted(by_depth[y], key=lambda f: f['samples'], reverse=True)
        depth_num = int((max(by_depth.keys()) - y) / 16)  # Approximate depth from y
        for frame in depth_frames[:10]:  # Limit per depth level
            indent = '  ' * min(depth_num, 10)
            lines.append(f'{indent}{frame["percentage"]:5.2f}% {frame["name"]}')

    lines.append('')
    return '\n'.join(lines)


def find_flamegraph_svgs(target_dir: Path) -> list[tuple[str, Path]]:
    """
    Find all criterion flamegraph SVGs.

    Returns list of (benchmark_name, svg_path) tuples.
    """
    criterion_dir = target_dir / 'criterion'
    if not criterion_dir.exists():
        return []

    results: list[tuple[str, Path]] = []
    # Pattern: target/criterion/<group>/<variant>/profile/flamegraph.svg
    for svg_path in criterion_dir.glob('**/profile/flamegraph.svg'):
        # Extract benchmark name from path
        parts = svg_path.relative_to(criterion_dir).parts
        if len(parts) >= 3:
            benchmark_name = f'{parts[0]}_{parts[1]}'
            results.append((benchmark_name, svg_path))

    return results


def main():
    project_root = Path(__file__).parent.parent
    target_dir = project_root / 'target'
    flame_dir = project_root / 'flame'

    # Clean and recreate flame directory
    if flame_dir.exists():
        shutil.rmtree(flame_dir)
    flame_dir.mkdir()

    # Find all flamegraph SVGs
    svgs = find_flamegraph_svgs(target_dir)

    if not svgs:
        print('No flamegraph SVGs found in target/criterion/')
        print('Run `make profile` first to generate flamegraphs.')
        return

    for benchmark_name, svg_path in svgs:
        # Copy SVG
        dest_svg = flame_dir / f'{benchmark_name}.svg'
        shutil.copy(svg_path, dest_svg)

        # Generate text version
        frames = extract_frames(svg_path)
        text_content = frames_to_text(frames, benchmark_name)

        dest_txt = flame_dir / f'{benchmark_name}.txt'
        dest_txt.write_text(text_content)

    print(f'\n{len(svgs)} flamegraphs written to {flame_dir.name}/ as SVG and text files.')


if __name__ == '__main__':
    main()




------------------------------------------
File: scripts/iter_test_methods.py
------------------------------------------

"""
External function implementations for iter mode tests.

These implementations mirror the behavior of `dispatch_external_call` in the Rust test runner
so that iter mode tests produce identical results in both Monty and CPython.

This module is shared between:
- scripts/run_traceback.py (for traceback tests)
- crates/monty/tests/datatest_runner.rs (via include_str! for CPython execution)
"""

from __future__ import annotations

import os
import stat as stat_module
from dataclasses import dataclass
from pathlib import Path


def add_ints(a: int, b: int) -> int:
    return a + b


def concat_strings(a: str, b: str) -> str:
    return a + b


def return_value(x: object) -> object:
    return x


def get_list() -> list[int]:
    return [1, 2, 3]


def raise_error(exc_type: str, message: str) -> None:
    exc_types: dict[str, type[Exception]] = {
        'ValueError': ValueError,
        'TypeError': TypeError,
        'KeyError': KeyError,
        'RuntimeError': RuntimeError,
    }
    raise exc_types[exc_type](message)


@dataclass(frozen=True)
class Point:
    x: int
    y: int


def make_point() -> Point:
    return Point(x=1, y=2)


@dataclass
class MutablePoint:
    x: int
    y: int


def make_mutable_point() -> MutablePoint:
    return MutablePoint(x=1, y=2)


@dataclass(frozen=True)
class User:
    name: str
    active: bool = True


def make_user(name: str) -> User:
    return User(name=name, active=True)


@dataclass
class Empty:
    pass


def make_empty() -> Empty:
    return Empty()


async def async_call(x: object) -> object:
    """Async function that returns its argument.

    This is a coroutine - it returns a future that resolves to the given value.
    Used for testing async external function calls.
    """
    return x


# =============================================================================
# Virtual Filesystem for OS Call Tests
# =============================================================================

# Virtual filesystem modification time (matches Rust constant)
VFS_MTIME: float = 1700000000.0

# Virtual files: path -> (content, mode)
VIRTUAL_FILES: dict[str, tuple[bytes, int]] = {
    '/virtual/file.txt': (b'hello world\n', 0o644),
    '/virtual/data.bin': (b'\x00\x01\x02\x03', 0o644),
    '/virtual/empty.txt': (b'', 0o644),
    '/virtual/subdir/nested.txt': (b'nested content', 0o644),
    '/virtual/subdir/deep/file.txt': (b'deep', 0o644),
    '/virtual/readonly.txt': (b'readonly', 0o444),
}

# Virtual directories
VIRTUAL_DIRS: set[str] = {'/virtual', '/virtual/subdir', '/virtual/subdir/deep'}

# Directory contents: parent_path -> list of child paths
VIRTUAL_DIR_CONTENTS: dict[str, list[str]] = {
    '/virtual': [
        '/virtual/file.txt',
        '/virtual/data.bin',
        '/virtual/empty.txt',
        '/virtual/subdir',
        '/virtual/readonly.txt',
    ],
    '/virtual/subdir': ['/virtual/subdir/nested.txt', '/virtual/subdir/deep'],
    '/virtual/subdir/deep': ['/virtual/subdir/deep/file.txt'],
}


class VirtualStatResult:
    """Mock stat_result for virtual filesystem.

    Mimics os.stat_result structure with named attributes and index access.
    """

    def __init__(self, st_mode: int, st_size: int):
        self.st_mode = st_mode
        self.st_ino = 0
        self.st_dev = 0
        # nlink is 1 for files, 2 for directories
        self.st_nlink = 1 if stat_module.S_ISREG(st_mode) else 2
        self.st_uid = 0
        self.st_gid = 0
        self.st_size = st_size
        self.st_atime = VFS_MTIME
        self.st_mtime = VFS_MTIME
        self.st_ctime = VFS_MTIME

    def __getitem__(self, index: int) -> int | float:
        """Support index access like real stat_result."""
        fields = [
            self.st_mode,
            self.st_ino,
            self.st_dev,
            self.st_nlink,
            self.st_uid,
            self.st_gid,
            self.st_size,
            self.st_atime,
            self.st_mtime,
            self.st_ctime,
        ]
        return fields[index]


def is_virtual_path(path: str) -> bool:
    """Check if a path should use the virtual filesystem."""
    return path.startswith('/virtual') or path.startswith('/nonexistent')


class VirtualPath(type(Path())):
    """Path subclass that uses virtual filesystem for /virtual/ and /nonexistent paths.

    Inherits from the concrete Path class (PosixPath or WindowsPath) and overrides
    filesystem methods to use the virtual filesystem when appropriate.
    """

    def exists(self, *, follow_symlinks: bool = True) -> bool:
        path_str = str(self)
        if is_virtual_path(path_str):
            return path_str in VIRTUAL_FILES or path_str in VIRTUAL_DIRS
        return super().exists(follow_symlinks=follow_symlinks)

    def is_file(self, *, follow_symlinks: bool = True) -> bool:
        path_str = str(self)
        if is_virtual_path(path_str):
            return path_str in VIRTUAL_FILES
        return super().is_file(follow_symlinks=follow_symlinks)

    def is_dir(self, *, follow_symlinks: bool = True) -> bool:
        path_str = str(self)
        if is_virtual_path(path_str):
            return path_str in VIRTUAL_DIRS
        return super().is_dir(follow_symlinks=follow_symlinks)

    def is_symlink(self) -> bool:
        path_str = str(self)
        if is_virtual_path(path_str):
            return False  # No symlinks in virtual fs
        return super().is_symlink()

    def read_text(self, encoding: str | None = None, errors: str | None = None, newline: str | None = None) -> str:
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_FILES:
                content, _ = VIRTUAL_FILES[path_str]
                return content.decode('utf-8')
            raise FileNotFoundError(2, 'No such file or directory', path_str)
        return super().read_text(encoding=encoding, errors=errors, newline=newline)

    def read_bytes(self) -> bytes:
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_FILES:
                content, _ = VIRTUAL_FILES[path_str]
                return content
            raise FileNotFoundError(2, 'No such file or directory', path_str)
        return super().read_bytes()

    def stat(  # pyright: ignore[reportIncompatibleMethodOverride]
        self, *, follow_symlinks: bool = True
    ) -> VirtualStatResult | os.stat_result:
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_FILES:
                content, mode = VIRTUAL_FILES[path_str]
                # Add regular file type bits
                st_mode = mode | stat_module.S_IFREG
                return VirtualStatResult(st_mode, len(content))
            if path_str in VIRTUAL_DIRS:
                # Directory: 0o755 with directory type bits
                st_mode = 0o755 | stat_module.S_IFDIR
                return VirtualStatResult(st_mode, 4096)
            raise FileNotFoundError(2, 'No such file or directory', path_str)
        return super().stat(follow_symlinks=follow_symlinks)

    def iterdir(self):  # pyright: ignore[reportUnknownParameterType]
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_DIR_CONTENTS:
                for child_path in VIRTUAL_DIR_CONTENTS[path_str]:
                    yield VirtualPath(child_path)
                return
            raise FileNotFoundError(2, 'No such file or directory', path_str)
        yield from super().iterdir()

    def resolve(self, strict: bool = False) -> 'VirtualPath':
        path_str = str(self)
        if is_virtual_path(path_str):
            # For virtual paths, just return as-is (already absolute)
            return VirtualPath(path_str)
        return VirtualPath(super().resolve(strict=strict))

    def absolute(self) -> 'VirtualPath':
        path_str = str(self)
        if is_virtual_path(path_str):
            # For virtual paths, return as-is
            return VirtualPath(path_str)
        return VirtualPath(super().absolute())

    def write_text(
        self,
        data: str,
        encoding: str | None = None,
        errors: str | None = None,
        newline: str | None = None,
    ) -> int:
        path_str = str(self)
        if is_virtual_path(path_str):
            content = data.encode(encoding or 'utf-8')
            VIRTUAL_FILES[path_str] = (content, 0o644)
            # Add to parent directory contents
            _add_to_parent_dir(path_str)
            return len(content)
        return super().write_text(data, encoding=encoding, errors=errors, newline=newline)

    def write_bytes(self, data: bytes) -> int:  # pyright: ignore[reportIncompatibleMethodOverride]
        path_str = str(self)
        if is_virtual_path(path_str):
            VIRTUAL_FILES[path_str] = (data, 0o644)
            # Add to parent directory contents
            _add_to_parent_dir(path_str)
            return len(data)
        return super().write_bytes(data)

    def mkdir(self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False) -> None:
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_DIRS:
                if exist_ok:
                    return
                raise FileExistsError(17, 'File exists', path_str)
            if path_str in VIRTUAL_FILES:
                raise FileExistsError(17, 'File exists', path_str)

            # Check if parent exists
            parent_str = str(self.parent)
            if parent_str and parent_str not in VIRTUAL_DIRS:
                if parents:
                    VirtualPath(parent_str).mkdir(mode=mode, parents=True, exist_ok=True)
                else:
                    raise FileNotFoundError(2, 'No such file or directory', path_str)

            VIRTUAL_DIRS.add(path_str)
            _add_to_parent_dir(path_str)
            # Initialize empty directory contents
            if path_str not in VIRTUAL_DIR_CONTENTS:
                VIRTUAL_DIR_CONTENTS[path_str] = []
            return
        super().mkdir(mode=mode, parents=parents, exist_ok=exist_ok)

    def unlink(self, missing_ok: bool = False) -> None:
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_FILES:
                del VIRTUAL_FILES[path_str]
                _remove_from_parent_dir(path_str)
                return
            if not missing_ok:
                raise FileNotFoundError(2, 'No such file or directory', path_str)
            return
        super().unlink(missing_ok=missing_ok)

    def rmdir(self) -> None:
        path_str = str(self)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_DIRS:
                VIRTUAL_DIRS.remove(path_str)
                if path_str in VIRTUAL_DIR_CONTENTS:
                    del VIRTUAL_DIR_CONTENTS[path_str]
                _remove_from_parent_dir(path_str)
                return
            raise FileNotFoundError(2, 'No such file or directory', path_str)
        super().rmdir()

    def rename(self, target: 'VirtualPath | str') -> 'VirtualPath':  # pyright: ignore[reportIncompatibleMethodOverride]
        path_str = str(self)
        target_str = str(target)
        if is_virtual_path(path_str):
            if path_str in VIRTUAL_FILES:
                content, mode = VIRTUAL_FILES[path_str]
                del VIRTUAL_FILES[path_str]
                _remove_from_parent_dir(path_str)
                VIRTUAL_FILES[target_str] = (content, mode)
                _add_to_parent_dir(target_str)
                return VirtualPath(target_str)
            if path_str in VIRTUAL_DIRS:
                VIRTUAL_DIRS.remove(path_str)
                _remove_from_parent_dir(path_str)
                VIRTUAL_DIRS.add(target_str)
                _add_to_parent_dir(target_str)
                return VirtualPath(target_str)
            raise FileNotFoundError(2, 'No such file or directory', path_str)
        return VirtualPath(super().rename(target))

    # __truediv__ is NOT overridden - the parent class already uses type(self)
    # to create new paths, which will be VirtualPath instances


def _add_to_parent_dir(path_str: str) -> None:
    """Add a path to its parent directory's contents."""
    parent = str(Path(path_str).parent)
    if parent in VIRTUAL_DIR_CONTENTS:
        if path_str not in VIRTUAL_DIR_CONTENTS[parent]:
            VIRTUAL_DIR_CONTENTS[parent].append(path_str)


def _remove_from_parent_dir(path_str: str) -> None:
    """Remove a path from its parent directory's contents."""
    parent = str(Path(path_str).parent)
    if parent in VIRTUAL_DIR_CONTENTS and path_str in VIRTUAL_DIR_CONTENTS[parent]:
        VIRTUAL_DIR_CONTENTS[parent].remove(path_str)


# Monkey-patch pathlib.Path to use VirtualPath
# This is done so tests can use `from pathlib import Path` and get VirtualPath behavior
_original_path_new = Path.__new__


def _virtual_path_new(cls: type, *args: object, **kwargs: object) -> Path:
    """Custom __new__ that returns VirtualPath for paths starting with /virtual or /nonexistent.

    Only virtual paths get the VirtualPath treatment. All other paths use the
    standard pathlib behavior (PosixPath/WindowsPath).
    """
    if cls is Path and args and isinstance(args[0], str):
        path_str = args[0]
        if path_str.startswith('/virtual') or path_str.startswith('/nonexistent'):
            return object.__new__(VirtualPath)
    return _original_path_new(cls, *args, **kwargs)  # pyright: ignore[reportUnknownVariableType,reportArgumentType]


# Apply the monkey-patch
Path.__new__ = _virtual_path_new


# =============================================================================
# Virtual Environment for os.getenv Tests
# =============================================================================

# Virtual environment variables (matches Rust test constants)
VIRTUAL_ENV: dict[str, str] = {
    'VIRTUAL_HOME': '/virtual/home',
    'VIRTUAL_USER': 'testuser',
    'VIRTUAL_EMPTY': '',
}

# Store original os functions before monkey-patching
# Check if already patched (happens when module is re-executed in same interpreter)
if not hasattr(os, '_monty_original_getenv'):
    os._monty_original_getenv = os.getenv  # pyright: ignore[reportAttributeAccessIssue]
    os._monty_original_environ = os.environ  # pyright: ignore[reportAttributeAccessIssue]

_original_getenv = os._monty_original_getenv  # pyright: ignore[reportAttributeAccessIssue,reportUnknownVariableType,reportUnknownMemberType]
_original_environ = os._monty_original_environ  # pyright: ignore[reportAttributeAccessIssue,reportUnknownVariableType,reportUnknownMemberType]


def _virtual_getenv(key: str, default: str | None = None) -> str | None:
    """Virtual os.getenv that returns predefined values for VIRTUAL_* keys.

    For keys starting with 'VIRTUAL_', returns the virtual environment value
    or None if not in the virtual env (ignoring default for these keys to match Monty behavior).
    For all other keys, falls through to the real os.getenv.
    """
    # Check key type first to match CPython's behavior
    if not isinstance(key, str):  # pyright: ignore[reportUnnecessaryIsInstance]
        # to get the real error
        return _original_getenv(key)  # pyright: ignore[reportUnknownVariableType]

    if key.startswith('VIRTUAL_') or key in ('NONEXISTENT', 'ALSO_MISSING', 'MISSING'):
        value = VIRTUAL_ENV.get(key)
        if value is not None:
            return value
        return default
    return _original_getenv(key, default)  # pyright: ignore[reportUnknownVariableType]


# Monkey-patch os.getenv to use virtual environment for test keys
os.getenv = _virtual_getenv


class VirtualEnviron:
    """Wrapper around os.environ that provides virtual environment variables.

    For keys in VIRTUAL_ENV or test-specific keys (NONEXISTENT, etc.), returns
    virtual values. For all other keys, falls through to real os.environ.

    This ensures tests using `os.environ['VIRTUAL_HOME']` work identically
    in both Monty (virtual env) and CPython (real env + virtual overlay).
    """

    def __getitem__(self, key: str) -> str:
        if key in VIRTUAL_ENV:
            return VIRTUAL_ENV[key]
        if key.startswith('VIRTUAL_') or key in ('NONEXISTENT', 'ALSO_MISSING', 'MISSING'):
            raise KeyError(key)
        return _original_environ[key]  # pyright: ignore[reportUnknownVariableType]

    def __contains__(self, key: object) -> bool:
        if isinstance(key, str):
            if key in VIRTUAL_ENV:
                return True
            if key.startswith('VIRTUAL_') or key in ('NONEXISTENT', 'ALSO_MISSING', 'MISSING'):
                return False
        return key in _original_environ

    def __len__(self) -> int:
        # Return only virtual env length for tests that check len(os.environ)
        return len(VIRTUAL_ENV)

    def get(self, key: str, default: str | None = None) -> str | None:
        # Check key type first - pass through to original environ to get proper error
        if not isinstance(key, str):  # pyright: ignore[reportUnnecessaryIsInstance]
            return _original_environ.get(key, default)  # pyright: ignore[reportArgumentType,reportUnknownMemberType,reportUnknownVariableType]
        if key in VIRTUAL_ENV:
            return VIRTUAL_ENV[key]
        if key.startswith('VIRTUAL_') or key in ('NONEXISTENT', 'ALSO_MISSING', 'MISSING'):
            return default
        return _original_environ.get(key, default)  # pyright: ignore[reportUnknownMemberType,reportUnknownVariableType]

    def keys(self):
        """Return keys from virtual environment only (for test isolation)."""
        return VIRTUAL_ENV.keys()

    def values(self):
        """Return values from virtual environment only (for test isolation)."""
        return VIRTUAL_ENV.values()

    def items(self):
        """Return items from virtual environment only (for test isolation)."""
        return VIRTUAL_ENV.items()


# Monkey-patch os.environ to use virtual environment for test keys
os.environ = VirtualEnviron()


# All external functions available to iter mode tests
ITER_MODE_GLOBALS: dict[str, object] = {
    'add_ints': add_ints,
    'concat_strings': concat_strings,
    'return_value': return_value,
    'get_list': get_list,
    'raise_error': raise_error,
    'make_point': make_point,
    'make_mutable_point': make_mutable_point,
    'make_user': make_user,
    'make_empty': make_empty,
    'async_call': async_call,
}




------------------------------------------
File: scripts/run_traceback.py
------------------------------------------

"""
Run a Python file and return formatted traceback for testing.

This script uses runpy.run_path() to execute a file, ensuring full traceback
information (including caret lines) is preserved. The file path in the traceback
is replaced with 'test_file.py'.
"""

import os
import re
import runpy
import sys
import tempfile
import traceback
from threading import Lock

from iter_test_methods import ITER_MODE_GLOBALS

lock = Lock()


def run_file_and_get_traceback(
    fixture_file_path: str,
    recursion_limit: int | None = None,
    iter_mode: bool = False,
    async_mode: bool = False,
) -> str | None:
    """
    Execute a Python file and return the formatted traceback if an exception occurs.

    The traceback will have the basename as the filename for the executed code,
    with caret lines (`~~~~~`) properly shown for all frames.

    Args:
        fixture_file_path: Path to the Python file to execute.
        recursion_limit: Recursion limit for execution. CPython adds ~5 frames
            of overhead for runpy, so the effective limit for user code is
            approximately recursion_limit - 5.
        iter_mode: If True, inject external function implementations into globals
            for iter mode tests (tests that use external functions like add_ints).
        async_mode: If True, wrap code in an async context for tests with
            top-level await that Monty supports but CPython doesn't.

    Returns:
        Formatted traceback string with '^' replaced by '~', or None if no exception.
    """
    # Get absolute path for consistent replacement
    abs_path = os.path.abspath(fixture_file_path)
    file_name = os.path.basename(fixture_file_path)

    # Async line offset: 1 lines for "async def __test_main():\n"
    line_offset = 0

    with open(abs_path) as f:
        code = f.read()

    if async_mode:
        # Wrap code in async context: indent everything by 4 spaces and add wrapper
        indented = '\n'.join([f'    {line}' if line else '' for line in code.split('\n')])

        code = f'async def __test_main():\n{indented}\nimport asyncio as __asy\n__asy.run(__test_main())'
        # Async line offset: 1 lines for "async def __test_main():\n"
        line_offset = 1

    with lock:
        # Set recursion limit for testing.
        previous_recursion_limit = sys.getrecursionlimit()
        if recursion_limit is not None:
            sys.setrecursionlimit(recursion_limit + 5)

        # Prepare init_globals for iter mode tests
        init_globals = dict(ITER_MODE_GLOBALS) if iter_mode else None

        with tempfile.NamedTemporaryFile(mode='w', suffix='.py') as tmp_file:
            tmp_file.write(code)
            tmp_file.flush()
            file_path = tmp_file.name

            try:
                runpy.run_path(file_path, init_globals=init_globals, run_name='__main__')
            except SystemExit:
                pass  # don't error on ctrl+c
            except BaseException as e:
                # Format the traceback
                stack = traceback.format_exception(type(e), e, e.__traceback__)

                result_frames: list[str] = []
                found_user_code = False

                for frame in stack:
                    # Keep the "Traceback (most recent call last):" header
                    if frame.startswith('Traceback'):
                        result_frames.append(frame)
                        continue
                    elif '__asy.run(__test_main())' in frame:
                        # Skip the asyncio.run(__test_main()) wrapper frame
                        continue
                    elif '/asyncio/' in frame:
                        # Skip asyncio internal frames
                        continue
                    elif iter_mode:
                        # In iter mode, skip frames from helper modules
                        if 'iter_test_methods.py", ' in frame:
                            continue
                        # python's doing something weird and show the file as <string> for dataclass exceptions
                        if frame.startswith('  File "<string>"'):
                            continue

                    # Skip until we see our test file
                    if not found_user_code and frame.startswith(f'  File "{file_path}"'):
                        found_user_code = True

                    if found_user_code:
                        if async_mode:
                            if adjusted_frame := _adjust_async_frame(frame, file_path, file_name, line_offset):
                                result_frames.append(adjusted_frame)
                        else:
                            result_frames.append(frame.replace(file_path, file_name))

                # Restore a high limit for traceback formatting
                sys.setrecursionlimit(previous_recursion_limit)
                lines = (''.join(result_frames)).splitlines()
                return '\n'.join(map(normalize_debug_range, lines)).rstrip()


def _adjust_async_frame(frame: str, tmp_path: str, file_name: str, line_offset: int) -> str | None:
    """
    Adjust a traceback frame from the async wrapper to show original line numbers.

    Returns the adjusted frame, or None if the frame should be skipped.
    """
    # Parse the frame to extract and adjust the line number
    # Format: '  File "path", line N, in func\n    code\n    ~~~~\n'
    frame = frame.replace(tmp_path, file_name)

    # Replace __test_main with <module> since it represents module-level code
    frame = frame.replace('in __test_main', 'in <module>')

    # Find and adjust line number using regex
    match = re.search(r'line (\d+)', frame)
    if match:
        old_line = int(match.group(1))
        new_line = old_line - line_offset
        if new_line < 1:
            return None  # Skip frames from wrapper code
        frame = frame.replace(f'line {old_line}', f'line {new_line}')

    return frame


def format_full_traceback(e: Exception):
    stack = traceback.format_exception(type(e), e, e.__traceback__)

    lines = (''.join(stack)).splitlines()
    return '\n'.join(map(normalize_debug_range, lines)).rstrip()


def normalize_debug_range(line: str) -> str:
    line = line.replace('dataclasses.FrozenInstanceError:', 'FrozenInstanceError:')
    if re.fullmatch(r' +[\~\^]+', line):
        return line.replace('^', '~')
    else:
        return line


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print(f'Usage: {sys.argv[0]} <file.py>', file=sys.stderr)
        sys.exit(1)

    file_path = sys.argv[1]
    if not os.path.exists(file_path):
        print(f'Error: File not found: {file_path}', file=sys.stderr)
        sys.exit(1)

    result = run_file_and_get_traceback(file_path)
    if result:
        print(result)
    else:
        print('No exception raised')




------------------------------------------
File: scripts/startup_performance.py
------------------------------------------

# /// script
# requires-python = ">=3.14"
# dependencies = [
#     "daytona>=0.136.0",
#     "mcp-run-python>=0.0.22",
#     "pydantic-monty>=0.0.1",
#     "starlark-pyo3>=2025.2.5",
# ]
# ///
import asyncio
import os
import subprocess
import time
from typing import Any

from mcp_run_python import code_sandbox

from pydantic_monty import Monty

code = '1 + 1'


def run_monty():
    start = time.perf_counter()
    result = Monty('1 + 1').run()
    diff = time.perf_counter() - start
    assert result == 2, f'Unexpected result: {result!r}'
    print(f'Monty cold start time: {(diff * 1000):.3f} milliseconds')


def run_pyodide():
    async def run() -> Any:
        async with code_sandbox(dependencies=['numpy']) as sandbox:
            return await sandbox.eval(code)

    start = time.perf_counter()
    result = asyncio.run(run())
    diff = time.perf_counter() - start
    assert result == {'status': 'success', 'output': [], 'return_value': 2}, f'Unexpected result: {result!r}'
    print(f'Pyodide cold start time: {(diff * 1000):.3f} milliseconds')


def run_docker():
    start = time.perf_counter()
    result = subprocess.run(
        ['docker', 'run', '--rm', 'python:3.14-alpine', 'python', '-c', f'print({code})'],
        capture_output=True,
        text=True,
    )
    diff = time.perf_counter() - start
    output = result.stdout.strip()
    assert output == '2', f'Unexpected result: {output!r}'
    print(f'Docker cold start time: {(diff * 1000):.3f} milliseconds')


def run_starlark():
    import starlark as sl

    start = time.perf_counter()
    glb = sl.Globals.standard()
    mod = sl.Module()
    ast = sl.parse('bench.star', code)
    result = sl.eval(mod, ast, glb)
    diff = time.perf_counter() - start
    assert result == 2, f'Unexpected result: {result!r}'
    print(f'Starlark cold start time: {(diff * 1000):.3f} milliseconds')


def run_daytona():
    from daytona import Daytona, DaytonaConfig

    api_key = os.getenv('DAYTONA_API_KEY')
    if not api_key:
        print('DAYTONA_API_KEY environment variable is not set, skipping daytona')
        return

    # Initialize the Daytona client
    daytona = Daytona(DaytonaConfig(api_key=api_key))

    start = time.perf_counter()
    response = daytona.create().process.code_run(f'print({code})')
    diff = time.perf_counter() - start
    assert response.result == '2', f'Unexpected result: {response.result!r}'
    print(f'Daytona cold start time: {(diff * 1000):.3f} milliseconds')


def run_wasmer():
    # requires wasmer to be installed, see https://docs.wasmer.io/install
    start = time.perf_counter()
    result = subprocess.run(
        ['wasmer', 'run', 'python/python', '--', '-c', f'print({code})'],
        capture_output=True,
        text=True,
    )
    diff = time.perf_counter() - start
    output = result.stdout.strip()
    assert output == '2', f'Unexpected result: {output!r}'
    print(f'Wasmer cold start time: {(diff * 1000):.3f} milliseconds')


def run_subprocess_python():
    start = time.perf_counter()
    result = subprocess.run(
        ['python', '-c', f'print({code})'],
        capture_output=True,
        text=True,
    )
    diff = time.perf_counter() - start
    output = result.stdout.strip()
    assert output == '2', f'Unexpected result: {output!r}'
    print(f'Subprocess Python cold start time: {(diff * 1000):.3f} milliseconds')


def run_exec_python():
    start = time.perf_counter()
    result = eval(code)
    diff = time.perf_counter() - start
    assert result == 2, f'Unexpected result: {result!r}'
    print(f'Exec Python cold start time: {(diff * 1000):.3f} milliseconds')


if __name__ == '__main__':
    run_monty()
    run_pyodide()
    run_docker()
    run_starlark()
    run_daytona()
    run_wasmer()
    run_subprocess_python()
    run_exec_python()
